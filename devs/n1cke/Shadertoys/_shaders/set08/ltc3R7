{"Shader":{"ver":"0.1","info":{"id":"ltc3R7","date":"1468376822","viewed":470,"name":"Gas Explosion","username":"TimoKinnunen","description":"After much trial and error a supernova explosion has become a more earthly gasoline\/gas explosion. You can zoom in with 1,2,3 keys and mouse left-right axis orbits the camera.","likes":28,"published":3,"flags":16,"tags":["explosion","fire","volumetric","smoke","looping","gas"],"hasliked":0},"renderpass":[{"inputs":[{"id":15,"src":"\/presets\/tex10.png","ctype":"texture","channel":2,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Based on https:\/\/www.shadertoy.com\/view\/lsySzd\n\/\/\n\/\/ \"Volumetric explosion\" by Duke\n\/\/-------------------------------------------------------------------------------------\n\/\/ Based on \"Supernova remnant\" (https:\/\/www.shadertoy.com\/view\/MdKXzc) \n\/\/ and other previous shaders \n\/\/ otaviogood's \"Alien Beacon\" (https:\/\/www.shadertoy.com\/view\/ld2SzK)\n\/\/ and Shane's \"Cheap Cloud Flythrough\" (https:\/\/www.shadertoy.com\/view\/Xsc3R4) shaders\n\/\/ Some ideas came from other shaders from this wonderful site\n\/\/ Press 1-2-3 to zoom in and zoom out.\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/-------------------------------------------------------------------------------------\n\/\/\n\/\/ And based on https:\/\/www.shadertoy.com\/view\/XlcGRn\n\/\/\n\/\/ \"Space Elevator\" by dr2 - 2016\n\/\/ License: Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License\n\/\/\n\/\/ And based on https:\/\/www.shadertoy.com\/view\/4djSRW\n\/\/\n\/\/ Hash without Sine\n\/\/ Creative Commons Attribution-ShareAlike 4.0 International Public License\n\/\/ Created by David Hoskins.\n\/\/\n\/\/ With varous small tweaks to have the effect play nice against a colorful background,\n\/\/ keeping the black smoky look.\n\/\/\n\/\/ Explosion colors\nconst vec3 veDensityBeg  = vec3(0.22,0.16,0.046);\nconst vec3 veDensityEnd  = vec3(0.403,0.291,0.216);\nconst vec3 veMediaCenter = vec3(0.305,0.49,0.616);\nconst vec3 veMediaEdge   = vec3(0.918,0.796,0.495);\n\/\/ Sky colors\nconst vec3 veColSkyHigh = vec3(0.2, 0.4, 0.6);\nconst vec3 veColSkyLow  = vec3(0.0, 0.1, 0.3);\nconst vec3 veColStars   = vec3(0.8, 0.9, 1.0);\nconst float accuscale = -0.005;\nconst float scalestar = 18.1  ;\nconst float subdiv    = 11.714;\nconst float variable  = 0.612 ;\nconst float variable2 = 1.171 ;\n\/\/ Default\nconst bool veBOTH         = false;\nconst bool veLEFT         = true ;\nconst bool veLOW_QUALITY  = false;\nconst bool veDITHERING    = true ;\nconst bool veTONEMAPPING  = false;\nconst bool veBackground   = true ;\nconst float veBackgroundCutoff      = 0.891;\nconst float veBackgroundCutoffStart = 0.387;\n\nfloat veProgress = mod(iGlobalTime * 0.1, 1.);\n\/\/-------------------\n#define HASHSCALE1 .1031\n#define HASHSCALE3 vec3(.1031, .1030, .0973)\n#define HASHSCALE4 vec4(1031, .1030, .0973, .1099)\n\n#define pi 3.14159265\n\nvec4 texture(sampler2D s, vec2 p) {\n    return texture2D(s, p);\n}\nvec4 texture(sampler2D s, vec2 p, float b) {\n    return texture2D(s, p, b);\n}\nvoid veR( inout vec2 p, in float a) {\n\tp = cos(a) * p + sin(a) * vec2(p.y, -p.x);\n}\n\n\/\/ iq's noise\nfloat veNoise( in vec3 x) {\n\tvec3 p = floor(x);\n\tvec3 f = fract(x);\n\tf = f * f * (3.0 - 2.0 * f);\n\tvec2 uv = (p.xy + vec2(37.0, 17.0) * p.z) + f.xy;\n\tvec2 rg = texture(iChannel0, (uv + 0.5) \/ 256.0, -100.0).yx;\n\treturn 1. - 0.82 * mix(rg.x, rg.y, f.z);\n}\n\nfloat veFBM(vec3 p) {\n\treturn veNoise(p * .06125) * .5 + veNoise(p * .125) * .25\n\t\t\t+ veNoise(p * .25) * .125 + veNoise(p * .4) * .2;\n}\n\nfloat veSphere(vec3 p, float r) {\n\treturn length(p) - r * 1.92 * veProgress;\n}\n\n\/\/==============================================================\n\/\/ otaviogood's noise from https:\/\/www.shadertoy.com\/view\/ld2SzK\n\/\/--------------------------------------------------------------\n\/\/ This spiral noise works by successively adding and rotating sin waves while increasing frequency.\n\/\/ It should work the same on all computers since it's not based on a hash function like some other noises.\n\/\/ It can be much faster than other noise functions if you're ok with some repetition.\nconst float veNudge = 100.3 * 4.;\t\/\/ size of perpendicular vector\nfloat veNormalizer = 1.0 \/ sqrt(1.0 + veNudge * veNudge);\t\/\/ pythagorean theorem on that perpendicular to maintain scale\nfloat veSpiralNoiseC(vec3 p) {\n\tfloat n = 1.5 - 6. * veProgress; \/\/ noise amount\n\tfloat iter = 2.0;\n\tfor (int i = 0; i < 8; i++) {\n\t\t\/\/ add sin and cos scaled inverse with the frequency\n\t\tn += -abs(sin(p.y * iter) + cos(p.x * iter)) \/ iter; \/\/ abs for a ridged look\n\t\t\/\/ rotate by adding perpendicular and scaling down\n\t\tp.xy += vec2(p.y, -p.x) * veNudge;\n\t\tp.xy *= veNormalizer;\n\t\t\/\/ rotate on other axis\n\t\tp.xz += vec2(p.z, -p.x) * veNudge;\n\t\tp.xz *= veNormalizer;\n\t\t\/\/ increase the frequency\n\t\titer *= 1.733733;\n\t}\n\treturn n;\n}\n\nfloat veVolumetricExplosion(vec3 p) {\n\tfloat fin = veSphere(p, 4.);\n\tif (veLOW_QUALITY) {\n\t\tfin += veNoise(p * 12.5) * .2;\n\t} else {\n\t\tfin += veFBM(p * 50.);\n\t}\n\tfin += veSpiralNoiseC(p.zxy * 0.4132 + 333. * floor(iMouse.y * 0.1)) * 1.25; \/\/1.25;\n\n\treturn fin;\n}\n\nfloat veMap(vec3 p) {\n\t\/\/veR(p.yz, iMouse.x * 0.008 * pi + 4. * veProgress);\n\tveR(p.yz, 4. * veProgress);\n\tfloat VolExplosion = veVolumetricExplosion(p * 2.) * 0.5; \/\/ scale\n\treturn VolExplosion;\n}\n\/\/--------------------------------------------------------------\n\n\/\/ assign color to the media\nvec3 veComputeColor(float density, float radius) {\n\t\/\/ color based on density alone, gives impression of occlusion within\n\t\/\/ the media\n\tvec3 result = mix(veDensityBeg, veDensityEnd, 1. - density);\n\n\t\/\/ color added to the media\n\tvec3 colCenter = 7. * veMediaCenter;\n\tvec3 colEdge = 1.5 * veMediaEdge;\n\tresult *= mix(colCenter, colEdge, min((radius + .05) \/ .9, 1.15));\n\n\treturn result;\n}\n\nbool veRaySphereIntersect(vec3 org, vec3 dir, out float near, out float far) {\n\tfloat b = dot(dir, org);\n\tfloat c = dot(org, org) - 8. * 4. * veProgress;\n\tfloat delta = b * b - c;\n\tif (delta < 0.0)\n\t\treturn false;\n\tfloat deltasqrt = sqrt(delta);\n\tnear = -b - deltasqrt;\n\tfar = -b + deltasqrt;\n\treturn far > 0.0;\n}\n\n\/\/ Applies the filmic curve from John Hable's presentation\n\/\/ More details at : http:\/\/filmicgames.com\/archives\/75\nvec3 veToneMapFilmicALU(vec3 _color) {\n\t_color = max(vec3(0), _color - vec3(0.004));\n\t_color = (_color * (6.2 * _color + vec3(0.5)))\n\t\t\t\/ (_color * (6.2 * _color + vec3(1.7)) + vec3(0.06));\n\treturn _color;\n}\n\nvec3 veAddZoom(vec3 rd, vec3 ro) {\n\tconst float KEY_1 = 49.5 \/ 256.0;\n\tconst float KEY_2 = 50.5 \/ 256.0;\n\tconst float KEY_3 = 51.5 \/ 256.0;\n\tfloat key = 0.0;\n\tkey += 0.7 * texture(iChannel1, vec2(KEY_1, 0.25)).x;\n\tkey += 1.4 * texture(iChannel1, vec2(KEY_2, 0.25)).x;\n\tkey += 2.1 * texture(iChannel1, vec2(KEY_3, 0.25)).x;\n\treturn ro - (ro - rd) * key * 1.6 \/ 6.;\n}\n\nconst vec4 vecHashA4 = vec4(0., 1., 57., 58.);\nconst vec3 vecHashA3 = vec3(1., 57., 113.);\nconst float vecHashM = 43758.54;\n\nvec4 veHashv4f(float p) {\n\treturn fract(sin(p + vecHashA4) * vecHashM);\n}\n\nfloat veNoisefv2(vec2 p) {\n\tvec4 t;\n\tvec2 ip, fp;\n\tip = floor(p);\n\tfp = fract(p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tt = veHashv4f(dot(ip, vecHashA3.xy));\n\treturn mix(mix(t.x, t.y, fp.x), mix(t.z, t.w, fp.x), fp.y);\n}\n\nfloat veNoisefv3(vec3 p) {\n\tvec4 t1, t2;\n\tvec3 ip, fp;\n\tfloat q;\n\tip = floor(p);\n\tfp = fract(p);\n\tfp = fp * fp * (3. - 2. * fp);\n\tq = dot(ip, vecHashA3);\n\tt1 = veHashv4f(q);\n\tt2 = veHashv4f(q + vecHashA3.z);\n\treturn mix(mix(mix(t1.x, t1.y, fp.x), mix(t1.z, t1.w, fp.x), fp.y),\n\t\t\tmix(mix(t2.x, t2.y, fp.x), mix(t2.z, t2.w, fp.x), fp.y), fp.z);\n}\n\nfloat veFbm3(vec3 p) {\n\tfloat f, a;\n\tf = 0.;\n\ta = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\tf += a * veNoisefv3(p);\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn f;\n}\n\nfloat veFbmn(vec3 p, vec3 n) {\n\tvec3 s;\n\tfloat a;\n\ts = vec3(0.);\n\ta = 1.;\n\tfor (int i = 0; i < 5; i++) {\n\t\ts += a * vec3(veNoisefv2(p.yz), veNoisefv2(p.zx), veNoisefv2(p.xy));\n\t\ta *= 0.5;\n\t\tp *= 2.;\n\t}\n\treturn dot(s, abs(n));\n}\n\nvec3 veSpaceCol(vec3 ro, vec3 rd) {\n\tvec3 rds, col;\n\trds = floor(2000. * rd);\n\trds = 0.00015 * rds + 0.1 * veNoisefv3(0.0005 * rds.yzx);\n\tfor (int j = 0; j < 19; j++)\n\t\trds = abs(rds) \/ dot(rds, rds) - 0.9;\n\tcol = veColStars * min(1., 0.5e-3 * pow(min(6., length(rds)), 5.));\n\tfloat s = pow(max(0., abs(dot(rd, vec3(0.0, 1.0, 0.0)))), 1.60);\n\tcol = veColSkyLow + col * (1. - smoothstep(0.9, 1., s));\n\ts = pow(s, 128.);\n\tcol += veColSkyHigh * (0.2 * s + 0.9 * pow(s, 8.));\n\treturn col;\n}\n\/\/----------------------------------------------------------------------------------------\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 1 in...\nfloat hash11(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 2 in...\nfloat hash12(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  1 out, 3 in...\nfloat hash13(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE1);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  2 out, 1 in...\nvec2 hash21(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 2 in...\nvec2 hash22(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  2 out, 3 in...\nvec2 hash23(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(vec2((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/  3 out, 1 in...\nvec3 hash31(float p) {\n\tvec3 p3 = fract(vec3(p) * HASHSCALE3);\n\tp3 += dot(p3, p3.yzx + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 2 in...\nvec3 hash32(vec2 p) {\n\tvec3 p3 = fract(vec3(p.xyx) * HASHSCALE3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/\/  3 out, 3 in...\nvec3 hash33(vec3 p3) {\n\tp3 = fract(p3 * HASHSCALE3);\n\tp3 += dot(p3, p3.yxz + 19.19);\n\treturn fract(\n\t\t\tvec3((p3.x + p3.y) * p3.z, (p3.x + p3.z) * p3.y, (p3.y + p3.z) * p3.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 1 in...\nvec4 hash41(float p) {\n\tvec4 p4 = fract(vec4(p) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 2 in...\nvec4 hash42(vec2 p) {\n\tvec4 p4 = fract(vec4(p.xyxy) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 3 in...\nvec4 hash43(vec3 p) {\n\tvec4 p4 = fract(vec4(p.xyzx) * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\n\/\/----------------------------------------------------------------------------------------\n\/\/ 4 out, 4 in...\nvec4 hash44(vec4 p4) {\n\tp4 = fract(p4 * HASHSCALE4);\n\tp4 += dot(p4, p4.wzxy + 19.19);\n\treturn fract(\n\t\t\tvec4((p4.x + p4.y) * p4.z, (p4.x + p4.z) * p4.y, (p4.y + p4.z) * p4.w,\n\t\t\t\t\t(p4.z + p4.w) * p4.x));\n}\n\/\/ From iq's website\nfloat sdCapsule(vec3 p, vec3 a, vec3 b, float r) {\n\tvec3 pa = p - a, ba = b - a;\n\tfloat h = clamp(dot(pa, ba) \/ dot(ba, ba), 0.0, 1.0);\n\treturn length(pa - ba * h) - r;\n}\nfloat parabola(float x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), k);\n}\nvec4 parabola(vec4 x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), vec4(k));\n}\nvec3 parabola(vec3 x, float k) {\n\treturn pow(4.0 * x * (1.0 - x), vec3(k));\n}\nfloat pcurve(float x, float a, float b) {\n\tfloat k = pow(a + b, a + b) \/ (pow(a, a) * pow(b, b));\n\treturn k * pow(x, a) * pow(1.0 - x, b);\n}\nvec3 veStars(vec3 ro, vec3 rd) {\n\tvec3 bs[8];\n\tvec3 srd = rd;\n\tfloat size = floor(subdiv);\n\trd *= length(rd) \/ max(abs(rd.x), max(abs(rd.y), abs(rd.z)));\n\trd *= size;\n\tvec3 lower = floor(rd + 0.5);\n\tvec3 point = rd - lower;\n\tvec3 ba = rd - ro;\n\tvec3 nba = normalize(ba);\n\tfloat ilba = 1.0 \/ dot(ba, ba);\n\tvec3 nbatilba = nba * ilba;\n\tfloat d = 99999999.0;\n    \n\tfor (int xi = -1; xi <= 1; xi++) {\n\t\tfor (int yi = -1; yi <= 1; yi++) {\n\t\t\tfor (int zi = -1; zi <= 1; zi++) {\n\t\t\t\tfor (int i = 0; i < 5; i++) {\n\t\t\t\t\tvec3 box = lower + vec3(float(xi), float(yi), float(zi));\n\t\t\t\t\tvec4 a = vec4(0.0);\n\t\t\t\t\tfor (int t = 0; t < 4; t++) {\n\t\t\t\t\t\tfloat v = float(t + 1) * .152;\n\t\t\t\t\t\tvec3 pos = (box * v + float(5 * i));\n\t\t\t\t\t\ta += hash43(pos);\n\t\t\t\t\t}\n\t\t\t\t\tvec3 local = a.xyz \/ 4.0 - 0.5;\n\t\t\t\t\tfloat dist = sdCapsule(ro + srd, ro, ro + box + local,\n\t\t\t\t\t\t\ta.w * accuscale);\n\t\t\t\t\td = min(d, dist);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\tvec3 result = pow(\n\t\t\tclamp(pcurve(d * scalestar, 0.0, 1.0 + 31.0 * variable), 0.0, 1.0),\n\t\t\tvariable2) * veColStars;\n\treturn result;\n}\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n\tvec2 uv = fragCoord \/ iResolution.xy;\n\n\t\/\/ ro: ray origin\n\t\/\/ rd: direction of the ray\n\tvec3 rd = normalize(\n\t\t\tvec3((fragCoord.xy - 0.5 * iResolution.xy) \/ iResolution.y, 1.));\n\tvec3 ro = vec3(0., 0., -6.);\n\tro = veAddZoom(rd, ro);\n\tveR(rd.yz, iMouse.x * 0.008 * pi);\n\n\t\/\/ ld, td: local, total density \n\t\/\/ w: weighting factor\n\tfloat ld = 0., td = 0., w = 0.;\n\n\t\/\/ t: length of the ray\n\t\/\/ d: distance function\n\tfloat density = 1., t = 0.;\n\tconst float h = 0.1;\n\tvec4 sum = vec4(0.0);\n\tfloat min_dist = 0.0, max_dist = 0.0;\n\tif (veRaySphereIntersect(ro, rd, min_dist, max_dist)) {\n\t\tt = min_dist * step(t, min_dist);\n\t\t\/\/ raymarch loop\n\t\tfor (int i = 0; i < 86; i++) {\n\t\t\tif (veLOW_QUALITY && i >= 56) {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t\tvec3 pos = ro + t * rd;\n\t\t\t\/\/ Loop break conditions.\n\t\t\tif (td > 0.99 || t > max_dist)\n\t\t\t\tbreak;\n\t\t\t\/\/ evaluate distance function\n\t\t\tfloat d = veMap(pos);\n\t\t\tif (veBOTH) {\n\t\t\t\tif (uv.y < 0.5) {\n\t\t\t\t\td = abs(d) + 0.07;\n\t\t\t\t}\n\t\t\t} else if (veLEFT) {\n\t\t\t\td = abs(d) + 0.07;\n\t\t\t}\n\t\t\t\/\/ change this string to control density\n\t\t\td = max(d, 0.0000003);\t\/\/0.03\n\t\t\t\/\/ point light calculations\n\t\t\tvec3 ldst = vec3(0.0) - pos;\n\t\t\tfloat lDist = max(length(ldst), 0.000000000001);\n\t\t\t\/\/ the color of light\n\t\t\tvec3 lightColor = vec3(1.0, 0.5, 0.25);\n\t\t\t\/\/ bloom\n\t\t\tvec3 halo = lightColor \/ exp(pow(lDist, 3.) * 0.108);\n\t\t\tsum.rgb += (halo * 0.0333 * smoothstep(0.5, 0.1, veProgress));\n\t\t\tif (d < h) {\n\t\t\t\t\/\/ compute local density\n\t\t\t\tld = h - d;\n\t\t\t\t\/\/ compute weighting factor\n\t\t\t\tw = (1. - td) * ld;\n\t\t\t\t\/\/ accumulate density\n\t\t\t\ttd += w + 1. \/ 20000.;\n\t\t\t\tvec4 col = vec4(veComputeColor(td, lDist), td);\n\t\t\t\t\/\/ emission\n\t\t\t\tsum += sum.a * vec4(sum.rgb, 0.0) * 0.2 \/ lDist;\n\t\t\t\t\/\/ uniform scale density\n\t\t\t\tcol.a *= 0.2;\n\t\t\t\t\/\/ colour by alpha\n\t\t\t\tcol.rgb *= col.a;\n\t\t\t\t\/\/ alpha blend in contribution\n\t\t\t\tsum = sum + col * (1.0 - sum.a);\n\t\t\t}\n\t\t\ttd += 1. \/ 70.;\n\t\t\tif (veDITHERING) {\n\t\t\t\t\/\/ idea from https:\/\/www.shadertoy.com\/view\/lsj3Dw\n\t\t\t\tvec2 uvd = uv;\n\t\t\t\tuvd.y *= 120.;\n\t\t\t\tuvd.x *= 280.;\n\t\t\t\tfloat sine = sin(4. * veProgress + uvd.y * 4.0);\n\t\t\t\tvec2 texUV = vec2(uvd.y, -uvd.x + 0.5 * sine);\n\t\t\t\tvec4 tex = texture(iChannel2, texUV);\n\t\t\t\td = abs(d) * (.8 + 0.08 * tex.r);\n\t\t\t}\n\t\t\t\/\/ trying to optimize step size\n\t\t\tif (veLOW_QUALITY) {\n\t\t\t\tt += max(d * 0.25, 0.01);\n\t\t\t} else {\n\t\t\t\tt += max(d * 0.08 * max(min(length(ldst), d), 2.0), 0.01);\n\t\t\t}\n\t\t}\n\t\t\/\/ simple scattering\n\t\tif (veLOW_QUALITY) {\n\t\t\tsum *= 1. \/ exp(ld * 0.2) * 0.9;\n\t\t} else {\n\t\t\tsum *= 1. \/ exp(ld * 0.2) * 0.8;\n\t\t}\n\t\tsum = clamp(sum, 0.0, 1.0);\n\t\tsum.xyz = sum.xyz * sum.xyz * (3.0 - 2.0 * sum.xyz);\n\t}\n\tif (veBackground) {\n\t\t\/\/ stars background\n\t\t\/\/vec3 stars = vec3(veNoise(rd * 200.0) * 0.5 + 0.5);\n\t\tvec3 stars = veStars(ro, rd);\n\t\tvec3 starbg = mix(veColSkyHigh, veColSkyLow,\n\t\t\t\tabs(1.5 * dot(normalize(rd), vec3(0., 1., 0.))));\n\t\t\/\/vec3 starbg = mix(veColSkyHigh, veColSkyLow, uv.y);\n\t\t\/\/vec3 brightness = smoothstep(0.95, 1.0, stars);\n\t\t\/\/float limits = dot(vec3(0.0), rd) + 0.75;\n\t\t\/\/starbg += veColStars * brightness * limits;\n\/\/\t\tif (td < veBackgroundCutoff) {\n\/\/\t\t}\n\t\tfloat pass = smoothstep(veBackgroundCutoff, veBackgroundCutoffStart, td);\n\t\t\/\/starbg *= pass;\n\t\tsum.xyz += (starbg + stars) * pass * (1.0 - sum.a);\n\t\t\/\/sum.xyz += (veSpaceCol(ro, rd) * pass + starbg) * (1.0 - sum.a);\n\t\t\/\/sum.xyz += veSpaceCol(ro, rd) * (1 - sum.a);\n\t}\n\tif (veTONEMAPPING) {\n\t\tfragColor = vec4(veToneMapFilmicALU(sum.xyz * 2.2), 1.0);\n\t} else {\n\t\tfragColor = vec4(sum.xyz, 1.0);\n\t}\n    gl_FragColor = fragColor;\n}","name":"Image","description":"","type":"image"}]}}