{"Shader":{"ver":"0.1","info":{"id":"4ltGW8","date":"1469044361","viewed":158,"name":"RayMarching3_sp","username":"SmartPointer","description":"A very simple ray marcher.","likes":0,"published":3,"flags":0,"tags":["raymarching"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"const int MAX_ITER = 100;\nconst float EPSILON = 0.001;\n\nfloat sphereDist(vec3 rayPos, vec3 spherePos, float radius) {\n    float l = 1.0;\t \t\/\/ length of the cube's edges\n    \n    \/\/ long version\n    \/*\n    float dN = rayDir.y - l;\n    float dS = -l - rayDir.y;\n    float dE = rayDir.x - l;\n    float dW = -l - rayDir.x;\n    float dF = rayDir.z - l;\n    float dB = -l - rayDir.z;\n    \n    float x = max(dE, dW);\n    float y = max(dN, dS);\n    float z = max(dF, dB);\n    \n    return max(max(x, z), y);\n\t*\/\n    \n    \/*\n    rayDir.x = mod(rayDir.x, 4.0);\n    rayDir.y = mod(rayDir.y, 4.0);\n    rayDir.z = mod(rayDir.z, 4.0);\n\t*\/\n    \n    rayPos = mod(abs(rayPos), 5.0) - 2.5;\n    \n    \/\/ more efficient version\n    vec3 q = abs(rayPos) - vec3(l);\n    float dist = max(max(q.x, q.y), q.z);\n    if (q.x > 0.0 && q.y > 0.0 && q.z > 0.0) {\t\t\/\/ use the sphere distance function\n        dist = length(q);\n    }\n   \tdist += 0.2;\n    \n    return dist;\n}\n\nfloat scene(vec3 rayPos) {\n    return sphereDist(rayPos, vec3(0.1), 1.4) + 0.04;\n}\n\nvec3 getNormal(in vec3 p) {\n    return normalize(vec3(\n        scene(vec3(p.x + EPSILON, p.y, p.z)) - scene(vec3(p.x - EPSILON, p.y, p.z)),\n        scene(vec3(p.x, p.y + EPSILON, p.z)) - scene(vec3(p.x, p.y - EPSILON, p.z)),\n        scene(vec3(p.x, p.y, p.z + EPSILON)) - scene(vec3(p.x, p.y, p.z - EPSILON))\n    ));\n}\n\nvec3 applyLighting(vec3 color, vec3 rayPos, vec3 lightPos, vec3 cameraOrigin) {\n    vec3 n = getNormal(rayPos);\n\n    \/\/ diffuse\n    vec3 l = normalize(lightPos - rayPos);\n    color = vec3(color.x, color.y, color.z);\n    vec3 diffuseColor = 4.0 * color * max(dot(n, l), 0.0);\n    \n    \/\/ specular\n    vec3 r = normalize(reflect(l, n));\t\t\t\/\/vec3 r = normalize((2.0 * dot(n, l)) * n - l);\n    float s = max(dot(normalize(-cameraOrigin - rayPos), r), 0.0);\n    vec3 specularColor = color * pow(s, 8.0);\n    \n    \/\/return specularColor;\n    return specularColor + diffuseColor;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord) {\n    vec3 color = vec3(0.0);\n\n    \/\/ camera\n    vec3 cameraTarget = vec3(0.0);\n    vec3 cameraOrigin = vec3(2.5 * cos(iGlobalTime * 0.2), 2.5 * cos(iGlobalTime * 0.2), 2.5 * sin(iGlobalTime * 0.2));\n    \/\/vec3 cameraOrigin = vec3(0.0, 0.0, 2.7);\n    vec3 cameraDir = normalize(cameraTarget - cameraOrigin);\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 cameraRight = normalize(cross(cameraDir, up));\n    vec3 cameraUp = normalize(cross(cameraRight, cameraDir));\n\n    \/\/ screen\n    vec2 screenPos = fragCoord.xy \/ iResolution.xy * 2.0 - 1.0;\n    screenPos.x *= iResolution.x \/ iResolution.y;\n    \n    vec3 pixel = cameraOrigin + cameraDir + cameraRight * screenPos.x + cameraUp * screenPos.y;\n    vec3 rayDir = normalize(pixel - cameraOrigin);\n\n    vec3 sphereColor = vec3(0.1, 0.2, 0.3); \n    float totalDist = 0.0;\n    for (int i = 0; i < MAX_ITER; i++) {\n        vec3 rayPos = rayDir * totalDist + cameraOrigin;\n        float dist = scene(rayPos);\n        totalDist += dist;\n        if (dist < EPSILON) {\n            color = applyLighting(sphereColor, rayPos, vec3(0.0, 1.0, 2.0), cameraOrigin);\n            break;\n        }\n    }\n\n    fragColor = vec4(color, 1.0);\n}\n\n\n","name":"Image","description":"","type":"image"}]}}