{"Shader":{"ver":"0.1","info":{"id":"ls3XW2","date":"1461501409","viewed":258,"name":"Distance Field Boilerplate","username":"finalman","description":"A good place to start for distance field based shaders","likes":8,"published":3,"flags":0,"tags":["distancefield","boilerplate"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"const float EPSILON = 1e-5;\nconst float PI = 3.1415926535897932384626433832795;\n\nfloat sphere(vec3 pos, float radius, vec3 sample)\n{\n    return distance(pos, sample) - radius;\n}\n\nfloat plane(vec3 pos, vec3 normal, vec3 sample)\n{\n    return dot(sample - pos, normal);\n}\n\nfloat map(vec3 sample)\n{\n    float t = fract(iGlobalTime * 0.5);\n    float h = (t - t * t) * 3.0;\n    \n    return min(\n        sphere(vec3(0.0, h, 0.0), 1.0, sample),\n        plane(vec3(0, -1, 0), vec3(0, 1, 0), sample)\n   \t);\n}\n\nvec3 normal(vec3 sample)\n{\n    float RANGE = 0.01;\n    float c = map(sample);\n    float x = map(sample + vec3(RANGE, 0, 0));\n    float y = map(sample + vec3(0, RANGE, 0));\n    float z = map(sample + vec3(0, 0, RANGE));\n\treturn normalize(vec3(x, y, z) - c);\n}\n\nfloat occlusion(vec3 sample, vec3 normal)\n{\n    float RANGE = 0.5;\n    return clamp(map(sample + normal * RANGE) \/ RANGE, 0.0, 1.0);\n}\n\nvec3 march(vec3 origin, vec3 direction)\n{\n    const int MAX_STEPS = 400;\n\tconst float MAX_DIST = 200.0;\n    \n    vec3 pos = origin;\n    float dist = 0.0;\n    \n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        float m = map(pos);\n        dist += m;\n        pos = origin + direction * dist;\n        \n        if (m < EPSILON)\n        {\n            return pos;\n        }\n        \n        if (dist > MAX_DIST)\n        {\n            break;\n        }\n    }\n    \n    return origin + direction * MAX_DIST;\n}\n\nfloat lightContribution(vec3 pos, vec3 normal, vec3 lightDirection, vec3 viewDirection)\n{\n    const float ROUGHNESS = 80.0;\n    const float FRESNEL_POWER = 20.0;\n    const float MIN_REFLECTANCE = 0.65;\n    const float MAX_REFLECTANCE = 0.99;\n    \n    float diffuse = max(dot(normal, lightDirection), 0.0);\n    float specular = pow(max(dot(reflect(viewDirection, normal), lightDirection), 0.0), ROUGHNESS);\n    float fresnel = pow(length(cross(normal, viewDirection)), FRESNEL_POWER);\n    float reflectance = mix(MIN_REFLECTANCE, MAX_REFLECTANCE, fresnel);\n    \n    return mix(diffuse, specular, reflectance);\n}\n\nvec3 lighting(vec3 pos, vec3 normal, vec3 viewDirection)\n{\n    const vec3 LIGHT_1_DIRECTION = normalize(vec3(-0.5, 1.0, -0.7));\n    const vec3 LIGHT_2_DIRECTION = normalize(vec3(1.0, 0.1, 0.9));\n    const vec3 LIGHT_1_COLOR = vec3(0.90, 0.85, 0.80);\n    const vec3 LIGHT_2_COLOR = vec3(0.05, 0.06, 0.07);\n    const vec3 AMBIENT_COLOR = vec3(0.02, 0.02, 0.03);\n    \n    float ambient = occlusion(pos, normal);\n\tfloat light1 = lightContribution(pos, normal, LIGHT_1_DIRECTION, viewDirection);\n    float light2 = lightContribution(pos, normal, LIGHT_2_DIRECTION, viewDirection);\n    \n    return ambient * AMBIENT_COLOR + \n        light1 * LIGHT_1_COLOR + \n        light2 * LIGHT_2_COLOR;\n}\n\nvec3 fog(vec3 c, float dist)\n{\n    const float FOG_DENSITY = 0.1;\n    const vec3 FOG_COLOR = vec3(0.01, 0.02, 0.02);\n    \n    float fogAmount = 1.0 - exp(-dist * FOG_DENSITY);\n        \n    return mix(c, FOG_COLOR, fogAmount);\n}\n\nvec3 render(vec3 origin, vec3 direction)\n{\n    vec3 p = march(origin, direction);\n    vec3 n = normal(p);\n    vec3 c = lighting(p, n, direction);\n    return fog(c, distance(origin, p));\n}\n\nvec3 gammaCorrect(vec3 c)\n{\n    return pow(c, vec3(1.0 \/ 2.2));\n}\n\nvec3 camera(vec3 origin, vec3 lookAt, vec3 up, float fov, vec2 fragCoord)\n{\n    lookAt -= origin;\n    vec3 forward = normalize(lookAt);\n    vec3 right = normalize(cross(up, forward));\n    up = normalize(cross(forward, right));\n    vec2 screen = (fragCoord - iResolution.xy * 0.5) \/ iResolution.y;\n    float viewPlane = -tan(fov * PI \/ 360.0 + PI * 0.5);\n    return normalize(right * screen.x + up * screen.y + forward * viewPlane);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n\tvec3 origin = vec3(0, 0, -4);\n    vec3 direction = camera(origin, vec3(0, 0.1, 0), vec3(0, 1, 0), 90.0, fragCoord);\n\tvec3 color = render(origin, direction);\n    \n    fragColor = vec4(gammaCorrect(color), 1.0);\n}","name":"Image","description":"","type":"image"}]}}