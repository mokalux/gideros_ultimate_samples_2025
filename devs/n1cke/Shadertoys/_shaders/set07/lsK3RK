{"Shader":{"ver":"0.1","info":{"id":"lsK3RK","date":"1455412655","viewed":5520,"name":"Racing Concept","username":"Imp5","description":"W,S,A,D or Arrow Keys - control car\nR - restart\n3d version by eiffie: [url]https:\/\/www.shadertoy.com\/view\/MsKGWy[\/url]","likes":70,"published":3,"flags":48,"tags":["2d","game","racing","playable","cars"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ GLSL Racing Concept\n\/\/ Created by Alexey Borisov \/ 2016\n\/\/ License: GPLv2\n\n\/\/ v1.04 restart after resolution changes\n\/\/ v1.03 fixed \"error normalizing a const\" in some browsers\n\/\/ v1.02 better behavior on FPS drops\n\/\/ v1.01 added arrow keys\n\/\/ v1.00 public release\n\nconst float OFFSET = 0.1;\nconst float IS_INITED = 0.5;\nconst float CAR_POSE = 1.5;\nconst float CAR_VEL = 2.5;\nconst float DEBUG_DOT = 3.5;\nconst float CAR_PROGRESS = 4.5;\n\nconst float LAPS = 6.0;\n\nconst float carLength = 0.045;\nconst float carWidth = 0.02;\nconst float carLengthInv = 1.0 \/ carLength;\nconst float carWidthInv = 1.0 \/ carWidth;\nconst float cameraScale = 2.0;\n\n\nconst vec4 wheelColor = vec4(1.0, 1.0, 1.0, 1.0);\nconst vec4 finishColor = vec4(0.9, 0.8, 0.5, 1.0);\nconst vec2 finishDir = vec2(1, 1.5);\n\nvec2 track_distort(vec2 pos)\n{\n    pos *= 0.5;    \n    pos -= vec2(cos(pos.y * 2.4), sin(pos.x * 2.0 - 0.3 * sin(pos.y * 4.0))) * 0.59;\n    return pos;\n}\n\nfloat track_val(vec2 pos)\n{\n    pos = track_distort(pos);\n    return abs(1.0 - length(pos)) * 8.0 - 1.0;\n}\n\nfloat get_wheels_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)\n{\n    float k = 0.0;\n    k = max(k, 1.0 - length((uv + carDir * carLength * 0.65 + carLeft * carWidth * 0.6) * 70.0));\n    k = max(k, 1.0 - length((uv - carDir * carLength * 0.65 + carLeft * carWidth * 0.6) * 70.0));\n    k = max(k, 1.0 - length((uv + carDir * carLength * 0.65 - carLeft * carWidth * 0.6) * 70.0));\n    k = max(k, 1.0 - length((uv - carDir * carLength * 0.65 - carLeft * carWidth * 0.6) * 70.0));\n    return k;\n}\n\nfloat get_car_window_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)\n{\n    float curv = cos(dot(uv, carLeft) * carWidthInv);\n    float k = clamp((1.0 - length(vec2(abs(dot(uv + carDir * 0.028 * curv, carDir) * carLengthInv * 12.0), abs(dot(uv, carLeft) * carWidthInv * 1.2)))) * 3.0, 0.0, 1.0);\n    k = max(k, clamp((1.0 - length(vec2(abs(dot(uv - carDir * 0.013 * curv, carDir) * carLengthInv * 9.0), abs(dot(uv, carLeft) * carWidthInv * 1.2)))) * 4.0, 0.0, 1.0));\n    return k;\n}\n\nfloat get_car_box_alpha(vec2 uv, vec2 carPos, vec2 carDir, vec2 carLeft)\n{\n    return 1.0 - max(abs(dot(uv, carDir) * carLengthInv), abs(dot(uv, carLeft) * carWidthInv));\n}\n\nvec4 render_car(vec4 backgroundColor, vec4 carColor, vec2 uv, vec2 carPos, vec2 carDir)\n{\n    uv -= carPos;\n    vec2 carLeft = vec2(-carDir.y, carDir.x);\n    float k = get_wheels_alpha(uv, carPos, carDir, carLeft);\n    backgroundColor = mix(backgroundColor, wheelColor, clamp(k * 20.0, 0.0, 1.0));    \n    k = get_car_box_alpha(uv, carPos, carDir, carLeft);\n    vec4 res = mix(backgroundColor, carColor, clamp(k * 20.0, 0.0, 1.0));\n    res = mix(res, carColor * 0.6, get_car_window_alpha(uv, carPos, carDir, carLeft));\n    return res;\n}\n\nvec4 render_debug_dot(vec4 color, vec2 uv, vec4 dotPos)\n{\n    return mix(vec4(1, dotPos.z, 1, 1), color, clamp(length(dotPos.xy - uv) * 70.0, 0.0, 1.0));\n}\n\nvec4 car_color_from_index(int i)\n{\n    return abs(vec4(cos(float(i) * 6.3) - 0.1001, cos(float(i) * 82.0) - 0.1, cos(float(i) * 33.0) - 0.1, 1.0));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 cameraPos = texture2D(iChannel1, vec2(CAR_POSE, 0.0) \/ iResolution.xy).xy * 0.95;    \n\tvec2 uv = (fragCoord.xy * cameraScale) \/ (iResolution.x) - vec2(cameraScale * 0.5, cameraScale * 0.25) + cameraPos;\n\n    \n    float c = track_val(uv);\n    vec4 outerColor = vec4(0.35 + (fract(uv.y * 5.0) > 0.5 ? 0.16 : 0.0), 0.8 + (fract(uv.x * 4.0) > 0.5 ? 0.03 : 0.0), 0.3, 1);\n    vec4 innerColor = vec4(0.1 + (fract(uv.y * 15.0) > 0.5 ? 0.04 : 0.0), 0.1 + (fract(uv.x * 14.0) > 0.5 ? 0.025 : 0.0), 0.1, 1);\n    innerColor = mix(innerColor, finishColor, clamp(dot(normalize(finishDir), normalize(uv)) * 100000.0 - 99999.0, 0.0, 1.0));\n    vec4 color = mix(innerColor, outerColor, clamp(c * 40.0, 0.0, 1.0));\n\n    for (int i = 0; i < 8; i++)\n    {\n        float carIdx = float(i) + OFFSET;\n    \tvec4 carPose = texture2D(iChannel1, vec2(CAR_POSE, carIdx) \/ iResolution.xy);\n        if (length(uv - carPose.xy) < carLength)\n        {\n    \t\tvec2 carPos = carPose.xy;\n    \t\tvec2 carDir = carPose.zw;\n\t        vec4 carColor = car_color_from_index(i);\n\t    \tcolor = render_car(color, carColor, uv, carPos, carDir);\n\t    \tcolor = render_debug_dot(color, uv, texture2D(iChannel1, vec2(DEBUG_DOT, carIdx) \/ iResolution.xy));\n        }\n    }\n    \n    if (fragCoord.y < iResolution.y * 0.08)\n    {            \n        uv = fragCoord.xy \/ iResolution.xx;\n        \n        color = mix(color, vec4(0.0, 0.0, 0.0, 1.0),\n                    clamp(1.0 - max(abs(uv.y - 0.02) * 200.0, abs(uv.x - 0.5) * 210.0 - 100.0), 0.0, 1.0));\n        \n        for (int i = 0; i < 8; i++)\n        {\n            float carIdx = float(i) + OFFSET;\n            vec4 carProgress = texture2D(iChannel1, vec2(CAR_PROGRESS, carIdx) \/ iResolution.xy);\n            vec2 pos = vec2(0.02 + clamp(carProgress.x \/ LAPS, 0.0, 1.0) * 0.96, 0.02);\n            vec4 carColor = car_color_from_index(i);\n\n            float rad = (i == 0) ? 80.0 : 150.0;\n            \n            float k = clamp(4.0 - length((uv - pos) * rad) * 3.0, 0.0, 1.0);\n            color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), k);\n            k = clamp(4.0 - length((uv - pos) * rad * 1.15) * 3.0, 0.0, 1.0);\n            color = mix(color, carColor, k);\n        }\n    }\n\n    \/\/ start lights\n    {\n    \tvec4 carProgress = texture2D(iChannel1, vec2(CAR_PROGRESS, 0) \/ iResolution.xy);\n        if (carProgress.w < 1.4)\n        {\n        \tuv = (iResolution.xy - fragCoord.xy) \/ iResolution.xx;\n            \n            for (int i = 0; i < 3; i++)\n            {            \n                vec4 lightColor = carProgress.w >= 1.0 ? vec4(0.0, 1.0, 0.0, 1.0) :\n                \tvec4(carProgress.w > float(i + 1) \/ 3.0 ? 1.0 : 0.0, 0.0, 0.0, 1.0);\n                vec2 pos = vec2(0.5 - float(i - 1) * 0.1, 0.1);\n                float rad = 25.0;\n                float k = clamp(17.0 - length((uv - pos) * rad) * 16.0, 0.0, 1.0);\n                color = mix(color, vec4(0.0, 0.0, 0.0, 1.0), k);\n                k = clamp(17.0 - length((uv - pos) * rad * 1.15) * 16.0, 0.0, 1.0);\n                color = mix(color, lightColor, k);\n            }\n        }\n    }\n    \n    \n\tfragColor = color; \/\/vec4(0, is_key_pressed(KEY_A), 0, 1);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ GLSL Racing Concept\n\/\/ Created by Alexey Borisov \/ 2016\n\/\/ License: GPLv2\n\n\/\/ v1.04 restart after resolution changes\n\/\/ v1.03 fixed \"error normalizing a const\" in some browsers\n\/\/ v1.02 better behavior on FPS drops\n\/\/ v1.01 added arrow keys\n\/\/ v1.00 public release\n\nconst float PI = 3.141592653;\n\nconst float OFFSET = 0.1;\n\nconst float KEY_A = 65.5 \/ 256.0;\nconst float KEY_W = 87.5 \/ 256.0;\nconst float KEY_S = 83.5 \/ 256.0;\nconst float KEY_D = 68.5 \/ 256.0;\nconst float KEY_R = 82.5 \/ 256.0;\nconst float KEY_LEFT = 37.5 \/ 256.0;\nconst float KEY_UP = 38.5 \/ 256.0;\nconst float KEY_DOWN = 40.5 \/ 256.0;\nconst float KEY_RIGHT = 39.5 \/ 256.0;\n\nconst float LAPS = 6.0;\n\nconst float IS_INITED = 0.5;\nconst float CAR_POSE = 1.5;\nconst float CAR_VEL = 2.5;\nconst float DEBUG_DOT = 3.5;\nconst float CAR_PROGRESS = 4.5;\n\nconst float MAX_SPEED = 1.2;\n\nconst float carLength = 0.045;\nconst float carWidth = 0.02;\n\nfloat is_key_pressed(float key_code)\n{\n    return texture2D(iChannel0, vec2((key_code), 0.0)).x;\n}\n\nvec2 track_distort(vec2 pos)\n{\n    pos *= 0.5;    \n    pos -= vec2(cos(pos.y * 2.4), sin(pos.x * 2.0 - 0.3 * sin(pos.y * 4.0))) * 0.59;\n    return pos;\n}\n\nfloat track_val(vec2 pos)\n{\n    pos = track_distort(pos);\n    return abs(1.0 - length(pos)) * 8.0 - 1.0;\n}\n\nvec2 track_grad(vec2 pos)\n{\n    const float d = 0.01;\n    float v0 = track_val(pos);\n    return vec2(track_val(pos + vec2(d, 0)) - v0, track_val(pos + vec2(0, d)) - v0) \/ d;\n}\n\nvec2 get_point_on_track(vec2 pos)\n{\n    for (int i = 8; i >= 0; i--)\n        pos = pos - track_grad(pos) * float(i) * 0.001;\n    \n    return pos;\n}\n\nvec4 get_val(float variable, float index)\n{\n    return texture2D(iChannel1, vec2(variable + OFFSET, index) \/ iResolution.xy);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = vec4(0.45, 0.0, 0.0, 1.0);\n    vec4 debugDot = vec4(100.0, 100.0, 1.0, 1.0);\n        \n    if (fragCoord.y <= 8.0 && fragCoord.x <= 10.0)\n    {\n        float resolutionHash = iResolution.x;\n        float carIdx = fragCoord.y + OFFSET;\n        if (abs(get_val(IS_INITED, carIdx).x - resolutionHash) > 8.0\n            || is_key_pressed(KEY_R) > 0.5) \/\/ not inited\n        {\n            if (fragCoord.x < ceil(IS_INITED))\n                fragColor = vec4(resolutionHash, 0, 0, 1);\n            else if (fragCoord.x < ceil(CAR_POSE))\n            {\n                fragColor = vec4(1.2 + carIdx * 0.094 + (fract(carIdx * 0.5) - 0.2) * 0.2, 1.85 - carIdx * 0.074, -1.0, 0.8);\n                fragColor.zw = normalize(fragColor.zw);\n            }\n            else if (fragCoord.x < ceil(CAR_VEL))\n                fragColor = vec4(0.0, 0.0, 0.0, 0.0);\n            else if (fragCoord.x < ceil(DEBUG_DOT))\n                fragColor = vec4(1.0, 0.0, 0.0, 1.0);\n            else\n                fragColor = vec4(0.0, 0.0, 0.0, 0.0);               \n        }\n        else \/\/ inited\n        {\n            vec4 carPose = get_val(CAR_POSE, carIdx);\n            vec2 carPos = carPose.xy;\n            vec2 prevPos = carPos;\n            vec2 carDir = carPose.zw;\n            vec2 carLeft = normalize(vec2(-carDir.y, carDir.x));\n            vec3 carVel3 = get_val(CAR_VEL, carIdx).xyz;\n            vec2 carVel = carVel3.xy;\n            float carOmega = carVel3.z;\n            vec4 carProgress = get_val(CAR_PROGRESS, carIdx);\n            \n            \/\/ Detect dt manually,\n            \/\/ this is workaround for iTimeDelta issue\n            float timeLoop = mod(iGlobalTime, 128.0);\n            float dt = clamp(timeLoop - carProgress.z, 0.01, 1.0 \/ 30.0);\n            carProgress.z = timeLoop;\n\n            carOmega *= 0.85 - (dt - 1.0 \/ 60.0) * 11.0;\n            \n            \n            float timeAfterFinish = min(carProgress.y, 1.0);\/\/clamp(iGlobalTime - 3.0, 0.0, 1.0);\n            \n            if (carIdx <= 1.0 && timeAfterFinish <= 0.0)\n            {\n                if (is_key_pressed(KEY_W) > 0.5 || is_key_pressed(KEY_UP) > 0.5)\n                    carVel += 1.0 * carDir * dt;\n                if (is_key_pressed(KEY_S) > 0.5 || is_key_pressed(KEY_DOWN) > 0.5)\n                    carVel -= 1.0 * carDir * dt;\n\n                \/\/carSpeed = min(length(carVel), MAX_SPEED);\n                \n                if (is_key_pressed(KEY_A) > 0.5 || is_key_pressed(KEY_LEFT) > 0.5)\n                {\n                    carOmega += 6.0 * dt;\n                    carVel *= 0.999;\n                }\n                if (is_key_pressed(KEY_D) > 0.5 || is_key_pressed(KEY_RIGHT) > 0.5)\n                {\n                    carOmega -= 6.0 * dt;\n                    carVel *= 0.999;                \n                }\n            }\n            else\n            {                \n                float accel = min(1.0, 0.9 +\n                \t0.1 * sin(carIdx + iGlobalTime * (0.25 + carIdx * 0.2)) - (floor(carIdx \/ 2.0) - 0.85) * 0.13);\n\n                carVel += accel * carDir * dt;\n                \n                carVel *= clamp((5.0 - timeAfterFinish), 0.0, 1.0);\n                \/\/carSpeed = length(carVel);\n                \n                float posOnTrack = sin((carIdx + 2.0) * iGlobalTime * 0.2 + carIdx) * 0.025 + 0.97;\n                                \n                vec2 wishPos = posOnTrack * get_point_on_track(carPos + normalize(carDir) * (0.2 + length(carVel) * 0.4));\n                wishPos += vec2(0.0, 0.5) * timeAfterFinish;\n                vec2 wishDir = normalize(wishPos - carPos);\n                carOmega += 8.0 * dt * clamp(dot(wishDir, carLeft) * (5.0 - carIdx * 0.5), -1.0, 1.0) * min(carProgress.w - 0.8, 1.0);\n                                \n\t         \/\/   debugDot.xy = wishPos;\n            }\n            \n            if (carProgress.w < 1.0)\n            \tcarVel = vec2(0.0, 0.0);\n            \n            carOmega = clamp(carOmega, -1.0, 1.0);\n            carDir += carLeft * dt * min(length(carVel) * 4.0 * carOmega, 2.0);\n            carDir = normalize(carDir);\n                        \n            float wall =\n                max(track_val(carPos - carLeft * carWidth - carDir * carLength), 0.0) +\n                max(track_val(carPos - carLeft * carWidth + carDir * carLength), 0.0) +\n                max(track_val(carPos + carLeft * carWidth - carDir * carLength), 0.0) +\n                max(track_val(carPos + carLeft * carWidth + carDir * carLength), 0.0);\n\n            \/\/ collision with walls\n            if (timeAfterFinish < 0.001)\n            {\n            \tif (wall > 0.0)\n            \t{\n\t                carVel *= 1.0 - 0.04 * min(wall * 10.0, 1.0);\n\t            \tcarPos -= track_grad(carPos) * min(wall * 0.02, 0.02);\n\t                vec2 grad = track_grad(carPos);\n\t                vec2 gradLeft = normalize(vec2(-grad.y, grad.x));\n\t                carDir = normalize(carDir + dot(gradLeft, carDir) * gradLeft * length(carVel) * dt * 5.0);\n\t            }\n            }\n            else\n            {\n                carVel *= 1.0 - clamp((wall - 1.0) * 0.02, 0.0, 1.0);\n            }\n            \n            \/\/ collision with cars\n            {\n                for (int i = 0; i < 8; i++)\n                {\n                   \tfloat secondIdx = float(i) + OFFSET;\n                    if (abs(secondIdx - carIdx) > 0.5)\n                    {\n                        vec4 secondPose = get_val(CAR_POSE, secondIdx);\n                        vec2 secondPos = secondPose.xy;\n                        vec2 secondDir = secondPose.wz;\n                        vec2 secondVel = get_val(CAR_VEL, secondIdx).xy;\n                        \n                        vec2 dir = normalize(carPos - secondPos);\n                        float cDist = (carLength - carWidth);\n                        float cWidth = carWidth * 2.1;\n                        float k = 0.0;\n                        k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos - cDist * secondDir)) \/ cWidth);\n                        k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos - cDist * secondDir)) \/ cWidth);\n                        k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos + cDist * secondDir)) \/ cWidth);\n                        k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos + cDist * secondDir)) \/ cWidth);\n                        k = max(k, (cWidth - length(carPos - cDist * carDir - secondPos)) \/ cWidth);\n                        k = max(k, (cWidth - length(carPos + cDist * carDir - secondPos)) \/ cWidth);\n\n                        carPos += dir * 0.02 * k;\n                        carVel += dir * 0.2 * k;\n                        carDir = normalize(carDir + secondDir * 0.1 * k);\n                    }\n                }\n            }\n            \n            \/\/ friction\n            {\n                float carSpeed = min(length(carVel), MAX_SPEED * 1.1);\n            \tfloat fr = carSpeed \/ MAX_SPEED;\n            \tcarSpeed = max(carSpeed - dt * (0.1 + fr * fr * fr), 0.0);\n            \tif (carSpeed > 0.00001)\n\t            \tcarVel = carSpeed * normalize(carVel + carDir * dt * 4.0);\n            }\n                                \n\n            carPos += carVel * dt;\n            \n            \/\/progress\n            {\n                vec2 trackPrev = prevPos;\n                vec2 trackCur = carPos;\n            \tfloat prevAngle = atan(trackPrev.y, trackPrev.x);\n            \tfloat angle = atan(trackCur.y, trackCur.x);\n            \tfloat dAngle = angle - prevAngle;\n            \tdAngle = abs(dAngle) > 1.0 ? 0.0 : dAngle;\n\t                            \n\t            carProgress.x += dAngle \/ (2.0 * PI);\n                \n                if (carProgress.x > LAPS)\n                    carProgress.y += dt;\n                \n                carProgress.w += dt * 0.3333;\n            }\n            \n                        \n            if (fragCoord.x < ceil(IS_INITED))\n                fragColor = vec4(resolutionHash, 1, 1, 1);\n            else if (fragCoord.x < ceil(CAR_POSE))\n            {\n                fragColor.xy = carPos;\n                fragColor.zw = carDir;\n            }\n            else if (fragCoord.x < ceil(CAR_VEL))\n                fragColor = vec4(mix(carVel, carVel3.xy, 0.25), carOmega, 0.0);\n            else if (fragCoord.x < ceil(DEBUG_DOT))\n                fragColor = debugDot;\n            else if (fragCoord.x < ceil(CAR_PROGRESS))\n                fragColor = carProgress;\n        }\n    }\n    else\n        fragColor = vec4(0.0, 1.0, 0.0, 1.0);    \n}\n","name":"Buf A","description":"","type":"buffer"}]}}