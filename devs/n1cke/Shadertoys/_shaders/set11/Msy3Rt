{"Shader":{"ver":"0.1","info":{"id":"Msy3Rt","date":"1455818233","viewed":229,"name":"SmoothInternalQuadGradient","username":"Bers","description":"A possible implementation of smooth internal gradient, while preserving (g == 0) on boundaries.","likes":1,"published":3,"flags":0,"tags":["distancefield"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/Simple utility function which returns the distance from point \"p\" to a given line segment defined by 2 points [a,b]\nfloat distanceToLineSeg(vec2 p, vec2 a, vec2 b)\n{\n    \/\/e = capped [0,1] orthogonal projection of ap on ab\n    \/\/       p\n    \/\/      \/\n    \/\/     \/\n    \/\/    a--e-------b\n    vec2 ap = p-a;\n    vec2 ab = b-a;\n    vec2 e = a+clamp(dot(ap,ab)\/dot(ab,ab),0.0,1.0)*ab;\n    return length(p-e);\n}\n\nbool isOutside(vec2 uv, vec2 c1, vec2 c2, vec2 c3, vec2 c4)\n{\n    return dot( (c1-c2).yx*vec2(-1,1), uv-c1) < 0.\n        || dot( (c2-c3).yx*vec2(-1,1), uv-c2) < 0.\n    \t|| dot( (c3-c4).yx*vec2(-1,1), uv-c3) < 0.\n    \t|| dot( (c4-c1).yx*vec2(-1,1), uv-c4) < 0.;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float h = iResolution.y\/iResolution.x;\n\tvec2 uv = -0.5+2.0*fragCoord.xy \/ iResolution.xx;\n    \n    vec2 c1 = vec2(1.+cos(iGlobalTime)*0.2,h+sin(iGlobalTime)*0.2);\n    vec2 c2 = vec2(1.+cos(iGlobalTime*0.621)*0.2,0.+sin(iGlobalTime*.841)*0.2);\n    vec2 c3 = vec2(0.+cos(iGlobalTime*0.395)*0.2,0.+sin(iGlobalTime*.563)*0.2);\n    vec2 c4 = vec2(0.+cos(iGlobalTime*0.511)*0.2,h+sin(iGlobalTime*0.601)*0.2);\n    float da = distanceToLineSeg(uv, c3, c2);\n    float db = distanceToLineSeg(uv, c2, c1);\n    float dc = distanceToLineSeg(uv, c1, c4);\n    float dd = distanceToLineSeg(uv, c4, c3);\n    \n    \/\/Note : a parameter controls smoothness (and scales value)\n    float a = 0.01;\n    float NORMALIZATION_TERM = log((1.+a)\/a);\n    da = log((da+a)\/a)\/NORMALIZATION_TERM;\n    db = log((db+a)\/a)\/NORMALIZATION_TERM;\n    dc = log((dc+a)\/a)\/NORMALIZATION_TERM;\n    dd = log((dd+a)\/a)\/NORMALIZATION_TERM;\n    float internalGradient = da*db*dc*dd;\n    \n    if(isOutside(uv,c1,c2,c3,c4))\n    {\n        fragColor = vec4(0,0,0.3,0);\n        return;\n    }\n        \n    float stripeHz = 20.0;\/\/BW Stripe frequency\n    float stripeTh = 0.25; \/\/Switchover value, in the [0.-0.5] range. (0.25 = right in the middle)\n    float aa = 0.001; \/\/aa = transition width (pixel \"antialiazing\" or smoothness)\n    float stripeIntensity = smoothstep(stripeTh-aa*stripeHz,stripeTh+aa*stripeHz,abs(fract(iGlobalTime+internalGradient*stripeHz)-0.5));\n    \n    fragColor = vec4((uv.x>0.5+sin(iGlobalTime))?stripeIntensity:internalGradient*3.0);\n}","name":"Image","description":"","type":"image"}]}}