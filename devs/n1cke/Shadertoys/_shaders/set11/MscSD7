{"Shader":{"ver":"0.1","info":{"id":"MscSD7","date":"1460454391","viewed":309,"name":"Temporal AA + Variance Clipping","username":"Vil","description":"A temporal AA implementation using Marco Salvi's Variance Clipping algorithm for temporal antialiasing. Variance Clipping is described here: https:\/\/www.dropbox.com\/sh\/dmye840y307lbpx\/AAAQpC0MxMbuOsjm6XmTPgFJa","likes":3,"published":3,"flags":32,"tags":["3d"],"hasliked":0},"renderpass":[{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 fragUV = fragCoord \/ iResolution.xy;\n    fragColor = texture2D(iChannel0, fragUV);\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":26,"src":"\/presets\/cube04_0.png","ctype":"cubemap","channel":1,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"false","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Render the current frame\n\nprecision highp float;\n\nconst vec3 target = vec3(0.0, 0.5, 0.0);\nconst float epsilon = 1e-5;\nconst float backgroundT = 1000.0;\n\n\nfloat hitBox(in vec3 ro, in vec3 rd, in vec3 pos, in vec3 s, out vec3 N)\n{\n    vec3 tLo = (pos - s - ro) \/ rd;\n    vec3 tHi = (pos + s - ro) \/ rd;\n    vec3 tNear = min(tLo, tHi);\n    vec3 tFar = max(tLo, tHi);\n    \n    float t0 = max(tNear.x, max(tNear.y, tNear.z));\n    float t1 = min(tFar.x, min(tFar.y, tFar.z));\n    if (t0 > t1) {\n        N = rd;\n        return 1e20;\n    }\n    float t = (t0 >= 0.0) ? t0 : t1;\n    \n    vec3 n = ro + rd * t - pos;\n    float maxN = max(abs(n.x), max(abs(n.y), abs(n.z)));\n    if (abs(n.x) < maxN) n.x = 0.0;\n    if (abs(n.y) < maxN) n.y = 0.0;\n    if (abs(n.z) < maxN) n.z = 0.0;\n\n\tN = normalize(n);\n    return t;\n}\n\n\nfloat hitSphere(in vec3 ro, in vec3 rd, in vec3 pos, in float r, out vec3 N)\n{\n    vec3 op = pos - ro;\n    float eps = 1e-4;\n    float b = dot(op, rd);\n    float det = b * b - dot(op, op) + r * r;\n    float t = 1e20;\n    if (det >= 0.0) {\n        det = sqrt(det);\n        t = b - det;\n        if (t <= eps)\n            t = b + det;\n        if (t <= eps)\n            t = 0.0;\n        N = normalize(ro + rd * t - pos);\n    }\n    return t;\n}\n\n\nfloat hitScene(in vec3 ro, in vec3 rd, out vec3 N)\n{\n    vec3 boxPos = vec3(0.0);\n    vec3 boxHalfWidth = vec3(0.9);\n    vec3 spherePos = vec3(0.0);\n    float sphereRadius = 1.2;\n    \n    vec3 n;\n    float t = hitBox(ro, rd, boxPos, boxHalfWidth, n);    \n    if (t >= backgroundT) {\n        N = n;\n        return t;\n    }\n    \n    \/\/ If the point where we hit the box is inside the sphere, \n    \/\/ find where we exit the sphere.\n    vec3 hit = ro + rd * t;\n    if (distance(hit, spherePos) <= sphereRadius) {\n        t += hitSphere(hit, rd, spherePos, sphereRadius, n);\n        hit = ro + rd * t;\n        \/\/ If the point where we exit the sphere is inside the box, \n        \/\/ that's our intersection point.\n        vec3 test = abs(hit - boxPos);\n        if (test.x <= boxHalfWidth.x && test.y <= boxHalfWidth.y && test.z <= boxHalfWidth.z) {\n            N = -n;\n            return t;\n        }\n        \n        \/\/ If we get here, we've exited the sphere outside the box\n        N = rd;\n        return backgroundT;\n    }\n    N = n;\n    return t;\n}\n\n\nvec3 camera(float time)\n{\n    return vec3(cos(time), 1.2 + sin(time) * 0.5, 3.0);\n}\n\n\nvec3 light()\n{\n    return vec3(10.0, 10.0, 10.0);\n}\n\n\nvec3 background(in vec3 dir)\n{\n    return textureCube(iChannel1, dir).rgb;\n}\n\n\nvec4 render(in vec2 fragCoord, in float fov)\n{\n    vec3 pos = camera(iGlobalTime);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(target - pos);\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n    \n    float imgU = tan(fov) * distance(pos, target);\n    float imgV = imgU * iResolution.y \/ iResolution.x;\n\n    vec2 uv = fragCoord \/ iResolution.xy * 2.0 - 1.0;\n    \n    dir = normalize(target + uv.x * imgU * right + uv.y * imgV * up - pos);\n\n    vec3 n = dir;\n    float t = hitScene(pos, dir, n);\n    if (t < backgroundT) {\n        vec3 r = reflect(dir, n);\n        float NdotR = max(0.0, dot(-dir, r));\n        vec3 ambient = background(reflect(dir, n)) * NdotR * 0.3;\n        \n        vec3 p = pos + dir * t;\n        vec3 l = normalize(light() - p);\n        float NdotL = max(0.0, dot(n, l));\n        vec3 direct = vec3(1.0, 0.5, 0.5) * NdotL;\n        \n        return vec4(ambient + direct, t);\n    }\n    \n    return vec4(background(dir), backgroundT);\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame == 0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n    \n    if (fragCoord.y < 1.0 && fragCoord.x < 1.0) {\n        float prevTime = texture2D(iChannel0, vec2(0.0)).x;\n        fragColor = vec4(iGlobalTime, prevTime, 0.0, 0.0);\n        return;\n    }\n    \n    float fov = radians(50.0);    \n    fragColor = render(fragCoord, fov);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Calculate motion vectors for each pixel\n\nprecision highp float;\n\n\nconst vec3 target = vec3(0.0, 0.5, 0.0);\n\n\nvec3 camera(float time)\n{\n    return vec3(cos(time), 1.2 + sin(time) * 0.5, 3.0);\n}\n\n\nvec3 hitPos(in vec2 uv, in float t, in float fov)\n{\n    float currTime = texture2D(iChannel0, vec2(0.0, 0.0)).r;\n    vec3 pos = camera(currTime);\n    \n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(target - pos);\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n\n    float dist = distance(pos, target);\n    float imgU = tan(fov) * dist;\n    float imgV = imgU * iResolution.y \/ iResolution.x;\n\n    vec2 uvR = uv * 2.0 - 1.0;\n    dir = normalize(target + uvR.x * imgU * right + uvR.y * imgV * up - pos);\n\n    return pos + dir * t;\n}\n\n\nvec2 reproject(in vec3 hit, in float fov)\n{\n    float prevTime = texture2D(iChannel0, vec2(0.0, 0.0)).g;\n    vec3 pos = camera(prevTime);\n\n    vec3 up = vec3(0.0, 1.0, 0.0);\n    vec3 dir = normalize(target - pos);\n    vec3 right = normalize(cross(dir, up));\n    up = normalize(cross(right, dir));\n\n    float dist = distance(pos, target);\n    float imgU = tan(fov) * dist;\n    float imgV = imgU * iResolution.y \/ iResolution.x;\n    \n    vec3 hitDir = normalize(hit - pos);\n    \n    float t = dist \/ dot(hitDir, dir);\n    vec3 h = pos + hitDir * t - target;\n    \n    vec2 uv = vec2(dot(h, right) \/ imgU, dot(h, up) \/ imgV) * 0.5 + 0.5;\n    return uv;\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 pixelUV = 1.0 \/ iResolution.xy;\n    vec2 uv = fragCoord * pixelUV;;\n    vec4 sample = texture2D(iChannel0, uv);\n    \n    if (iFrame == 0 || (fragCoord.y < 1.0 && fragCoord.x < 1.0)) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    float fov = radians(50.0);\n\n    vec3 hit = hitPos(uv, sample.a, fov);\n\n    vec2 oldUV = reproject(hit, fov);\n    if (oldUV.x <= pixelUV.x * 3.0 && oldUV.y <= pixelUV.y * 3.0) {\n        oldUV = uv;\n    }\n    fragColor = vec4(oldUV - uv, 0.0, 0.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"\/\/\/ Buf C\n\n\/\/ Apply temporal AA using:\n\/\/ - New frame from Buf A\n\/\/ - Motion vectors from Buf B\n\/\/ - History frame from Buf C\nprecision highp float;\n\n\nbool inAABB(vec3 val, vec3 lo, vec3 hi)\n{\n    return val.x >= lo.x && val.x <= hi.x\n        && val.y >= lo.y && val.y <= hi.y\n        && val.z >= lo.z && val.z <= hi.z;\n}\n\n\nvec3 clipLineToAABB(vec3 from, vec3 to, vec3 lo, vec3 hi)\n{\n    vec3 motion = to - from;\n    vec3 t0 = (lo - from) \/ motion;\n\tvec3 t1 = (hi - from) \/ motion;\n    \n    \/\/float minT = min(t.x, min(t.y, t.z));\n    \n    float minT = 1.0;\n    if (t0.x >= 0.0 && t0.x < minT) { minT = t0.x; }\n    if (t0.y >= 0.0 && t0.y < minT) { minT = t0.y; }\n    if (t0.z >= 0.0 && t0.z < minT) { minT = t0.z; }\n    if (t1.x >= 0.0 && t1.x < minT) { minT = t1.x; }\n    if (t1.y >= 0.0 && t1.y < minT) { minT = t1.y; }\n    if (t1.z >= 0.0 && t1.z < minT) { minT = t1.z; }\n    return from + motion * minT;\n}\n\n\nvec3 rgb2ycocg(in vec3 rgb)\n{\n    float co = rgb.r - rgb.b;\n    float t = rgb.b + co \/ 2.0;\n    float cg = rgb.g - t;\n    float y = t + cg \/ 2.0;\n    return vec3(y, co, cg);\n}\n\n\nvec3 ycocg2rgb(in vec3 ycocg)\n{\n    float t = ycocg.r - ycocg.b \/ 2.0;\n    float g = ycocg.b + t;\n    float b = t - ycocg.g \/ 2.0;\n    float r = ycocg.g + b;\n    return vec3(r, g, b);\n}\n\n\nvec2 motionVec(in vec2 uv)\n{\n    float du = 1.0 \/ iResolution.x;\n    float dv = 1.0 \/ iResolution.y;\n\n    vec2 offsets[8];\n    offsets[0] = vec2(-du, -dv);\n    offsets[1] = vec2(0.0, -dv);\n    offsets[2] = vec2( du, -dv);\n    offsets[3] = vec2(-du, 0.0);\n    offsets[4] = vec2( du, 0.0);\n    offsets[5] = vec2(-du,  dv);\n    offsets[6] = vec2(0.0,  dv);\n    offsets[7] = vec2( du,  dv);\n    \n    vec2 motion = texture2D(iChannel1, uv).xy;\n    float motionLength = length(motion);\n    \n    for (int i = 0; i < 8; ++i) {\n        vec2 tmp = texture2D(iChannel1, uv + offsets[i]).xy;\n        float tmpLength = length(tmp);\n        if (tmpLength > motionLength) {\n            motion = tmp;\n            motionLength = tmpLength;\n        }\n    }\n    \n    return motion;\n}\n\n\nvec3 varianceClip(in vec2 uv, in vec3 historyPixel, in vec3 newPixel)\n{\n    float du1 = 1.0 \/ iResolution.x;\n    float dv1 = 1.0 \/ iResolution.y;\n \n    vec2 offsets[4];\n    offsets[0] = vec2( 0.0, -dv1);\n    offsets[1] = vec2(-du1,  0.0);\n    offsets[2] = vec2( du1,  0.0);\n    offsets[3] = vec2( 0.0,  dv1);\n    \n    vec3 newColor = rgb2ycocg(newPixel);\n    vec3 m1 = newColor;\n    vec3 m2 = newColor * newColor;\n    for (int i = 0; i < 4; ++i) {\n        vec3 color = rgb2ycocg(texture2D(iChannel0, uv + offsets[i]).rgb);\n        m1 += color;\n        m2 += color * color;\n    }\n    \n    vec3 mu = m1 \/ 5.0;\n    vec3 sigma = sqrt(m2 \/ 5.0 - m1 * m1);\n    \n    const float gamma = 1.0;\n    vec3 lo = mu - gamma * sigma;\n    vec3 hi = mu + gamma * sigma;\n    \n    vec3 historyColor = rgb2ycocg(historyPixel);\n    return inAABB(historyColor, lo, hi) ? historyPixel : ycocg2rgb(clipLineToAABB(historyColor, newColor, lo, hi));\n}\n\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{    \n    if (iFrame == 0) {\n        fragColor = vec4(0.0);\n        return;\n    }\n\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec4 newPixel = texture2D(iChannel0, uv);\n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0) {\n        fragColor = newPixel;\n        return;\n    }\n\n    vec2 motion = motionVec(uv);\n    vec4 historyPixel = texture2D(iChannel2, uv + motion);\n\n    fragColor.rgb = mix(varianceClip(uv, historyPixel.rgb, newPixel.rgb), newPixel.rgb, 0.1);\n    fragColor.a = 1.0;\n}","name":"Buf C","description":"","type":"buffer"}]}}