{"Shader":{"ver":"0.1","info":{"id":"MsV3D3","date":"1456946368","viewed":2657,"name":"Procedural Grass","username":"Imp5","description":"Fast self-shadowed procedural grass","likes":41,"published":3,"flags":0,"tags":["2d","grass"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ FastGrass\n\/\/ Created by Alexey Borisov \/ 2016\n\/\/ License: GPLv2\n\n\/\/ v1.02 decreased width of grass leaves, added color post-processing\n\/\/ v1.01 added elevation (click and move)\n\/\/ v1.00 public release\n\n#define COLOR_POSTPROCESSING 1\n\n#define SKY_MULT 0.98\n#define GRASS_CONTRAST (5.5)\n#define GRASS_SHADOW_CONTRAST (3.6)\n#define GRASS_CONTRAST_INV (1.0 \/ GRASS_CONTRAST)\n#define GRASS_SHADOW_CONTRAST_INV (1.0 \/ GRASS_SHADOW_CONTRAST)\n#define GRASS_WIDTH (0.03)\n#define GRASS_WIDTH_INV (1.0 \/ GRASS_WIDTH)\n#define GRASS_BENDING_AMP 5.0\n#define GRASS_BENDING_PERIOD 0.03\n#define GP2 0.4317\n\nvec4 get_grass(vec2 uv, float seed)\n{\n    if (uv.y > 1.0)\n        return vec4(0.0);\n    else if (uv.y < 0.0)\n        return vec4(1.0);\n    else \n    {        \n        float seed2 = seed * 11.2;\n        float seed3 = seed * 3.621 - 43.32;\n        float bending = abs(0.5 - fract(seed2 + uv.x * GRASS_BENDING_PERIOD * GRASS_WIDTH_INV)) - 0.25;\n        uv.x += GRASS_WIDTH * GRASS_BENDING_AMP * 4.0 * uv.y * uv.y * uv.y * bending;\n        float shadowX = uv.x - uv.y * (0.25 + fract(seed2) * 0.22);\n        float top = 4.0 * abs(0.5 - fract(seed + uv.x * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 + uv.x * GRASS_WIDTH_INV * GP2));\n        float topB= 3.0 * abs(0.5 - fract(seed + (uv.x + 0.005) * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 + (uv.x - 0.009) * GRASS_WIDTH_INV * GP2));\n        float topR= 3.0 * abs(0.5 - fract(seed + (uv.x + 0.006 * (1.0 - uv.y)) * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 + (uv.x + 0.009 * (1.0 - uv.y)) * GRASS_WIDTH_INV * GP2));\n        float topS= 2.5 * abs(0.5 - fract(seed + 0.7 * (shadowX + 0.31) * GRASS_WIDTH_INV)) * abs(0.5 - fract(seed3 +  0.7 * (shadowX + 0.161) * GRASS_WIDTH_INV * GP2));\n        uv.y = uv.y * uv.y;\n        float alpha = GRASS_CONTRAST * (uv.y - (1.0 - GRASS_CONTRAST_INV) * top);\n        float bright = GRASS_CONTRAST * (uv.y - topB);\n        float bright2 = GRASS_CONTRAST * (uv.y - topR);\n        float shadow = GRASS_SHADOW_CONTRAST * (uv.y - (1.0 - GRASS_SHADOW_CONTRAST_INV) * topS);\n        return clamp(vec4(1.0 - alpha, bright, 1.0 - shadow, bright2), 0.0, 1.0);\n    }\n}\n\nvoid mainImage(out vec4 result, in vec2 fragCoord)\n{\n    result = vec4(0, 0, 0, 1);\n    fragCoord -= iResolution.xy * 0.5;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n     \n    vec3 c = mix(vec3(0.53, 0.63, 0.78), vec3(0.42, 0.52, 0.65), uv.y - uv.x * 0.5) * SKY_MULT;\n    \n    float elevation = iMouse.y \/ iResolution.y;\n    \n    uv.y += 0.3 - elevation * 0.8;\n    uv.y *= 1.8;\n    float k = 1.0;\n    \n    vec3 grassColor = vec3(0.4, 0.9, 0.1);\n    vec3 grassBackColor = grassColor * (0.25 + elevation * 0.2);\n    vec3 grassColorR = vec3(0.65, 0.7, 0.3);\n    vec3 grassShadow = grassColor * vec3(0.15, 0.2, 0.9);\n    \n    float pos = iGlobalTime * 3.0;\n    float iPos = floor(pos);\n    float fPos = fract(pos);\n    \n    uv.x += sin(pos * 0.3) * 0.4;\n    \n    for (int i = 10; i >= 0; i--)\n    {\n        float dist = (float(i) - fPos) \/ 10.0;\n        vec2 uv2 = uv;\n        uv2 *= 0.15 + dist * 1.4;\n        uv2.y += elevation + 0.45 - dist * (0.5 + elevation);\n        vec4 grass = get_grass(uv2, fract((iPos + float(i)) * 43.2423));\n        vec3 color = mix(grassBackColor, grassColor, grass.y);\n        color = mix(color, grassColorR, grass.w);\n        color = mix(color, grassShadow, grass.z);\n        if (i == 0)\n            grass.x *= smoothstep(0.0, 1.0, 1.0 - fPos);\n        if (i == 10)\n            grass.x *= fPos;\n        c = mix(c, color, grass.x);\n    }\n       \n#if COLOR_POSTPROCESSING == 1\n    c = -smoothstep(0.0, 1.0, c + 0.25) * 0.1 + c * 1.28;\n    c -= vec3(-0.4, 0.4, 0.25) * (max(c.r - 0.8, 0.0) + max(c.g - 0.85, 0.0) + max(c.b - 0.95, 0.0));\n#endif\n    \n\tresult = vec4(c, 1.0);\n}","name":"Image","description":"","type":"image"}]}}