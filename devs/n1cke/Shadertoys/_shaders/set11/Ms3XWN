{"Shader":{"ver":"0.1","info":{"id":"Ms3XWN","date":"1459916847","viewed":8952,"name":"Pacman Game","username":"iq","description":"Arrow keys to move. SPACE bar to restart. I'll implement levels next time I have some more time to spare","likes":89,"published":3,"flags":48,"tags":["procedural","2d","game","pacman"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/ postprocess (thanks to Timothy Lottes for the CRT filter - https:\/\/www.shadertoy.com\/view\/XsjSzR)\n\nconst vec2 txPacmanPos       = vec2(31.0,1.0);\nconst vec2 txPacmanMovDirNex = vec2(31.0,3.0);\nconst vec2 txPoints          = vec2(31.0,5.0);\nconst vec2 txState           = vec2(31.0,7.0);\nconst vec2 txGhost0PosDir    = vec2(31.0, 9.0);\nconst vec2 txGhost1PosDir    = vec2(31.0,11.0);\nconst vec2 txGhost2PosDir    = vec2(31.0,13.0);\nconst vec2 txGhost3PosDir    = vec2(31.0,15.0);\nconst vec2 txMode            = vec2(31.0,17.0);\nconst vec2 txLives           = vec2(31.0,19.0);\nconst vec4 txCells           = vec4(0.0,0.0,27.0,31.0);\n\n\n\/\/============================================================\n\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\/\/============================================================\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\n\nvec2 cell2ndc( vec2 c )\n{\n\tc = (c+0.5) \/ 31.0;\n    c.x -= 0.5*(1.0-iResolution.x\/iResolution.y); \/\/ center\n    return c;\n}\n\n\nvec3 drawMap( vec3 col, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.y;\n    p.x += 0.5*(1.0-iResolution.x\/iResolution.y); \/\/ center\n    float wp = 1.0\/iResolution.y;\n\n    p *= 31.0;\n    vec2 q = floor(p);\n    vec2 r = fract(p);\n    float wr = 31.0*wp;\n\n    if( q.x>=0.0 && q.x<=27.0 )\n    {\n        float c = texture2D( iChannel0, (q+0.5)\/iResolution.xy, -100.0 ).x;\n\n        \/\/ points\n        if( abs(c-2.0)<0.5 )\n        {\n            float d = sdCircle(r-0.5, 0.15);\n            col += 0.3*vec3(1.0,0.7,0.4)*exp(-22.0*d*d); \/\/ glow\n        }\n    }\n    \n\t\/\/ balls\n    \n    vec2 bp[4];\n    \n    bp[0] = vec2( 1.0, 7.0) + 0.5;\n    bp[1] = vec2(25.0, 7.0) + 0.5;\n    bp[2] = vec2( 1.0,27.0) + 0.5;\n    bp[3] = vec2(25.0,27.0) + 0.5;\n    \n    for( int i=0; i<4; i++ )\n    {\n        float c = texture2D( iChannel0, (bp[i]+0.5)\/iResolution.xy, -100.0 ).x;\n        if( abs(c-3.0)<0.5 )\n        {\n        float d = length(p - bp[i]);\n        col += 0.35*vec3(1.0,0.7,0.4)*exp(-1.0*d*d)*smoothstep( -1.0, -0.5, sin(2.0*6.2831*iGlobalTime) );\n        }\n    }\n    \n    return col;\n}\n\n\nvec3 drawPacman( vec3 col, in vec2 fragCoord, in vec4 pacmanPos, in vec3 pacmanMovDirNex )\n{\n    vec2 off = dir2dis(pacmanMovDirNex.x);\n    \n    vec2 mPacmanPos = pacmanPos.xy;\n    \/\/vec2 mPacmanPos = pacmanPos.xy + off*pacmanPos.z*pacmanPos.w;\n\n    vec2 p = fragCoord\/iResolution.y;\n    float eps = 1.0 \/ iResolution.y;\n\n    vec2 q = p - cell2ndc( mPacmanPos );\n\n    float c = max(0.0,sdCircle(q, 0.023));\n\n    \/\/ glow\n    col += 0.25*vec3(1.0,0.8,0.0)*exp(-400.0*c*c);\n\n    return col;\n}\n\nvec3 drawGhost( vec3 col, in vec2 fragCoord, in vec3 pos, in float dir, in float id, in vec3 mode )\n{\n    vec2 off = dir2dis(dir);\n\n    vec2 gpos = pos.xy;\n\n    vec2 p = fragCoord\/iResolution.y;\n    float eps = 1.0 \/ iResolution.y;\n\n    vec2 q = p - cell2ndc( gpos );\n\n    float c = max(0.0,sdCircle(q, 0.023));\n   \n    vec3 gco = 0.5 + 0.5*cos( 5.0 + 0.7*id + vec3(0.0,2.0,4.0) );\n    float g = mode.x;\n    if( mode.z>0.75 )\n    {\n        g *= smoothstep(-0.2,0.0,sin(3.0*6.28318*(iGlobalTime-mode.y)));\n    }\n    gco = mix( gco, vec3(0.1,0.5,1.0), g );\n\n    \/\/ glow\n    col += 0.2*gco*exp(-300.0*c*c);\n\n    return col;\n}\n\nvec3 drawScore( in vec3 col, in vec2 fragCoord, vec2 score, float lives )\n{\n    \/\/ score\n    vec2 p = fragCoord\/iResolution.y;\n    \/\/ lives\n    float eps = 1.0 \/ iResolution.y;\n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i);\n        vec2 q = p - vec2(0.1 + 0.075*h, 0.7 );\n        if( h + 0.5 < lives )\n        {\n            float c = max(0.0,sdCircle(q, 0.023));\n\n            col += 0.17*vec3(1.0,0.8,0.0)*exp(-1500.0*c*c);\n        }\n    }\n\n    return col;\n}\n\n\/\/============================================================\n\n\/\/\n\/\/ PUBLIC DOMAIN CRT STYLED SCAN-LINE SHADER\n\/\/\n\/\/   by Timothy Lottes\n\/\/\n\/\/ This is more along the style of a really good CGA arcade monitor.\n\/\/ With RGB inputs instead of NTSC.\n\/\/ The shadow mask example has the mask rotated 90 degrees for less chromatic aberration.\n\/\/\n\/\/ Left it unoptimized to show the theory behind the algorithm.\n\/\/\n\/\/ It is an example what I personally would want as a display option for pixel art games.\n\/\/ Please take and use, change, or whatever.\n\/\/\n\n\/\/ Emulated input resolution.\n\n\/\/vec2 res = 640.0*vec2(1.0,iResolution.y\/iResolution.x);\nvec2 res = iResolution.xy\/floor(1.0+iResolution.xy\/512.0);\n\n\/\/ Hardness of scanline.\n\/\/  -8.0 = soft\n\/\/ -16.0 = medium\nconst float hardScan=-8.0;\n\n\/\/ Hardness of pixels in scanline.\n\/\/ -2.0 = soft\n\/\/ -4.0 = hard\nconst float hardPix=-3.0;\n\n\/\/ Display warp.\n\/\/ 0.0 = none\n\/\/ 1.0\/8.0 = extreme\nconst vec2 warp=vec2(1.0\/32.0,1.0\/24.0); \n\n\/\/ Amount of shadow mask.\nconst float maskDark=0.6;\nconst float maskLight=2.0;\n\n\/\/------------------------------------------------------------------------\n\n\/\/ sRGB to Linear.\n\/\/ Assuing using sRGB typed textures this should not be needed.\nfloat ToLinear1(float c){return(c<=0.04045)?c\/12.92:pow((c+0.055)\/1.055,2.4);}\nvec3 ToLinear(vec3 c){return vec3(ToLinear1(c.r),ToLinear1(c.g),ToLinear1(c.b));}\n\n\/\/ Linear to sRGB.\n\/\/ Assuing using sRGB typed textures this should not be needed.\nfloat ToSrgb1(float c){return(c<0.0031308?c*12.92:1.055*pow(c,0.41666)-0.055);}\nvec3 ToSrgb(vec3 c){return vec3(ToSrgb1(c.r),ToSrgb1(c.g),ToSrgb1(c.b));}\n\n\/\/ Nearest emulated sample given floating point position and texel offset.\n\/\/ Also zero's off screen.\nvec3 Fetch(vec2 pos,vec2 off){\n  pos=floor(pos*res+off)\/res;\n  if(max(abs(pos.x-0.5),abs(pos.y-0.5))>0.5)return vec3(0.0,0.0,0.0);\n  return ToLinear(texture2D(iChannel1,pos.xy,-16.0).rgb);}\n\n\/\/ Distance in emulated pixels to nearest texel.\nvec2 Dist(vec2 pos){pos=pos*res;return -((pos-floor(pos))-vec2(0.5));}\n    \n\/\/ 1D Gaussian.\nfloat Gaus(float pos,float scale){return exp2(scale*pos*pos);}\n\n\/\/ 3-tap Gaussian filter along horz line.\nvec3 Horz3(vec2 pos,float off){\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  float dst=Dist(pos).x;\n  \/\/ Convert distance to weight.\n  float scale=hardPix;\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  \/\/ Return filtered sample.\n  return (b*wb+c*wc+d*wd)\/(wb+wc+wd);}\n\n\/\/ 5-tap Gaussian filter along horz line.\nvec3 Horz5(vec2 pos,float off){\n  vec3 a=Fetch(pos,vec2(-2.0,off));\n  vec3 b=Fetch(pos,vec2(-1.0,off));\n  vec3 c=Fetch(pos,vec2( 0.0,off));\n  vec3 d=Fetch(pos,vec2( 1.0,off));\n  vec3 e=Fetch(pos,vec2( 2.0,off));\n  float dst=Dist(pos).x;\n  \/\/ Convert distance to weight.\n  float scale=hardPix;\n  float wa=Gaus(dst-2.0,scale);\n  float wb=Gaus(dst-1.0,scale);\n  float wc=Gaus(dst+0.0,scale);\n  float wd=Gaus(dst+1.0,scale);\n  float we=Gaus(dst+2.0,scale);\n  \/\/ Return filtered sample.\n  return (a*wa+b*wb+c*wc+d*wd+e*we)\/(wa+wb+wc+wd+we);}\n\n\/\/ Return scanline weight.\nfloat Scan(vec2 pos,float off){\n  float dst=Dist(pos).y;\n  return Gaus(dst+off,hardScan);}\n\n\/\/ Allow nearest three lines to effect pixel.\nvec3 Tri(vec2 pos){\n  vec3 a=Horz3(pos,-1.0);\n  vec3 b=Horz5(pos, 0.0);\n  vec3 c=Horz3(pos, 1.0);\n  float wa=Scan(pos,-1.0);\n  float wb=Scan(pos, 0.0);\n  float wc=Scan(pos, 1.0);\n  return a*wa+b*wb+c*wc;}\n\n\n\/\/ Shadow mask.\nvec3 Mask(vec2 pos)\n{\n  pos.x+=pos.y*3.0;\n  vec3 mask=vec3(maskDark,maskDark,maskDark);\n  pos.x=fract(pos.x\/6.0);\n  if(pos.x<0.333)mask.r=maskLight;\n  else if(pos.x<0.666)mask.g=maskLight;\n  else mask.b=maskLight;\n  return mask;}    \n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/------------------------\n    \/\/ CRT\n    \/\/------------------------\n    vec3 col = ToSrgb( Tri(fragCoord.xy\/iResolution.xy)*Mask(fragCoord.xy) );\n    \/\/col = texture2D( iChannel1, fragCoord.xy\/iResolution.xy ).xyz;\n\n    \/\/------------------------\n    \/\/ glow\n    \/\/------------------------\n       \n    vec4  pacmanPos = loadValue( txPacmanPos );\n    vec3  pacmanDir = loadValue( txPacmanMovDirNex ).xyz;\n    vec4  ghostPos[4];\n    ghostPos[0]     = loadValue( txGhost0PosDir );\n    ghostPos[1]     = loadValue( txGhost1PosDir );\n    ghostPos[2]     = loadValue( txGhost2PosDir );\n    ghostPos[3]     = loadValue( txGhost3PosDir );\n    vec2  points    = loadValue( txPoints ).xy;\n    float state     = loadValue( txState ).x;\n    float lives     = loadValue( txLives ).x;\n    vec3 mode       = loadValue( txMode ) .xyz;\n\n    \/\/ map\n    col = drawMap( col, fragCoord );\n\n    \/\/ pacman\n    col = drawPacman( col, fragCoord, pacmanPos, pacmanDir );\n\n    \/\/ ghosts\n    for( int i=0; i<4; i++ )\n        col = drawGhost( col, fragCoord, ghostPos[i].xyz, ghostPos[i].w, float(i), mode );\n    \n    \/\/ score\n    col = drawScore( col, fragCoord, points, lives );\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/ game play\n\n#define _ 0. \/\/ empty\n#define W 1. \/\/ wall\n#define P 2. \/\/ point\n#define B 3. \/\/ ball\n#define PA(a,b,c,d,e,f,g) (a+4.*(b+4.*(c+4.*(d+4.*(e+4.*(f+4.*(g)))))))\n#define DD(id,c0,c1,c2,c3,c4,c5,c6,c7,c8,c9,c10,c11,c12,c13) if(y==id) m=(x<7)?PA(c0,c1,c2,c3,c4,c5,c6):PA(c7,c8,c9,c10,c11,c12,c13);\nfloat map( in vec2 p ) \n{\n    ivec2 q = ivec2( p );\n    if( q.x>13 ) q.x = q.x = 26-q.x;\n\tint x = q.x;\n\tint y = q.y;\n\tfloat m = 0.0;\n    DD(30, W,W,W,W,W,W,W,W,W,W,W,W,W,W)\n    DD(29, W,P,P,P,P,P,P,P,P,P,P,P,P,W)\n    DD(28, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(27, W,B,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(26, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD(25, W,P,P,P,P,P,P,P,P,P,P,P,P,P)\n    DD(24, W,P,W,W,W,W,P,W,W,P,W,W,W,W)\n    DD(23, W,P,W,W,W,W,P,W,W,P,W,W,W,W)\n    DD(22, W,P,P,P,P,P,P,W,W,P,P,P,P,W)\n    DD(21, W,W,W,W,W,W,P,W,W,W,W,W,_,W)\n    DD(20, _,_,_,_,_,W,P,W,W,W,W,W,_,W)\n    DD(19, _,_,_,_,_,W,P,W,W,_,_,_,_,_)\n    DD(18, _,_,_,_,_,W,P,W,W,_,W,W,W,_)\n    DD(17, W,W,W,W,W,W,P,W,W,_,W,_,_,_)\n    DD(16, _,_,_,_,_,_,P,_,_,_,W,_,_,_)\n    DD(15, W,W,W,W,W,W,P,W,W,_,W,_,_,_)\n    DD(14, _,_,_,_,_,W,P,W,W,_,W,W,W,W)\n    DD(13, _,_,_,_,_,W,P,W,W,_,_,_,_,_)\n    DD(12, _,_,_,_,_,W,P,W,W,_,W,W,W,W)\n    DD(11, W,W,W,W,W,W,P,W,W,_,W,W,W,W)\n    DD(10, W,P,P,P,P,P,P,P,P,P,P,P,P,W)\n    DD( 9, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD( 8, W,P,W,W,W,W,P,W,W,W,W,W,P,W)\n    DD( 7, W,B,P,P,W,W,P,P,P,P,P,P,P,_)\n    DD( 6, W,W,W,P,W,W,P,W,W,P,W,W,W,W)\n    DD( 5, W,W,W,P,W,W,P,W,W,P,W,W,W,W)\n    DD( 4, W,P,P,P,P,P,P,W,W,P,P,P,P,W)\n    DD( 3, W,P,W,W,W,W,W,W,W,W,W,W,P,W)\n    DD( 2, W,P,W,W,W,W,W,W,W,W,W,W,P,W)\n    DD( 1, W,P,P,P,P,P,P,P,P,P,P,P,P,P)\n    DD( 0, W,W,W,W,W,W,W,W,W,W,W,W,W,W)\n\treturn mod(floor(m\/pow(4.,mod(float(x),7.0))),4.);\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\n\nconst vec2 txPacmanPos       = vec2(31.0, 1.0);\nconst vec2 txPacmanMovDirNex = vec2(31.0, 3.0);\nconst vec2 txPoints          = vec2(31.0, 5.0);\nconst vec2 txState           = vec2(31.0, 7.0);\nconst vec2 txGhost0PosDir    = vec2(31.0, 9.0);\nconst vec2 txGhost1PosDir    = vec2(31.0,11.0);\nconst vec2 txGhost2PosDir    = vec2(31.0,13.0);\nconst vec2 txGhost3PosDir    = vec2(31.0,15.0);\nconst vec2 txMode            = vec2(31.0,17.0);\nconst vec2 txLives           = vec2(31.0,19.0);\n\nconst vec4 txCells           = vec4(0.0,0.0,27.0,31.0);\n\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\n\nconst float speedPacman = 7.0;\nconst float speedGhost  = 6.0;\nconst float intelligence = 0.53;\nconst float modeTime = 5.0;\n\/\/----------------------------------------------------------------------------------------------\n\nfloat hash(float seed)\n{\n    return fract(sin(seed)*158.5453 );\n}\n\n\/\/----------------------------------------------------------------------------------------------\n\nfloat isInside( vec2 p, vec2 c ) { vec2 d = abs(p-0.5-c) - 0.5; return -max(d.x,d.y); }\nfloat isInside( vec2 p, vec4 c ) { vec2 d = abs(p-0.5-c.xy-c.zw*0.5) - 0.5*c.zw - 0.5; return -max(d.x,d.y); }\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\nvoid storeValue( in vec2 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\nvoid storeValue( in vec4 re, in vec4 va, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = ( isInside(fragCoord,re) > 0.0 ) ? va : fragColor;\n}\n\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/ don't compute gameplay outside of the data area\n    if( fragCoord.x > 32.0 || fragCoord.y>32.0 ) discard;\n    \n    \/\/---------------------------------------------------------------------------------   \n\t\/\/ load game state\n\t\/\/---------------------------------------------------------------------------------\n    vec4  ghostPos[4];\n    vec4  pacmanPos       = loadValue( txPacmanPos );\n    vec3  pacmanMovDirNex = loadValue( txPacmanMovDirNex ).xyz;\n    vec2  points          = loadValue( txPoints ).xy;\n    float state           = loadValue( txState ).x; \/\/ -1 = start game, 0 = start life, 1 = playing, 2 = game over\n    vec3  mode            = loadValue( txMode ).xyz;\n    float lives           = loadValue( txLives ).x;\n    float cell            = loadValue( fragCoord-0.5 ).x;\n    ghostPos[0]           = loadValue( txGhost0PosDir );\n    ghostPos[1]           = loadValue( txGhost1PosDir );\n    ghostPos[2]           = loadValue( txGhost2PosDir );\n    ghostPos[3]           = loadValue( txGhost3PosDir );\n\t\n    \/\/---------------------------------------------------------------------------------\n    \/\/ reset\n\t\/\/---------------------------------------------------------------------------------\n\tif( iFrame==0 ) state = -1.0;\n\n    if( state<0.5 )\n    {\n        pacmanPos       = vec4(13.0,13.0,0.0,0.0);\n        pacmanMovDirNex = vec3(0.0,0.0,0.0);\n        mode            = vec3(0.0,-100.0,0.0);\n        ghostPos[0]     = vec4(13.0,19.0,0.0,1.0);\n        ghostPos[1]     = vec4(13.0,17.0,0.0,1.0);\n        ghostPos[2]     = vec4(12.0,16.0,0.0,1.0);\n        ghostPos[3]     = vec4(14.0,15.0,0.0,1.0);\n    }\n    \n    if( state < -0.5 )\n    {\n        state           = 0.0;\n        points          = vec2(0.0,0.0);\n        lives           = 3.0;\n        if( fragCoord.x<27.0 && fragCoord.y<31.0 ) \n            cell = map( fragCoord );\n    }\n    else if( state < 0.5 )\n    {\n        state = 1.0;\n    }\n    else if( state < 1.5 ) \n\t{\n\n        \/\/-------------------\n        \/\/ pacman\n        \/\/-------------------\n\n        \/\/ move with keyboard\n        if( texture2D( iChannel1, vec2(KEY_RIGHT,0.25) ).x>0.5 ) pacmanMovDirNex.z = 1.0;\n        if( texture2D( iChannel1, vec2(KEY_LEFT, 0.25) ).x>0.5 ) pacmanMovDirNex.z = 2.0;\n        if( texture2D( iChannel1, vec2(KEY_UP,   0.25) ).x>0.5 ) pacmanMovDirNex.z = 3.0;\n        if( texture2D( iChannel1, vec2(KEY_DOWN, 0.25) ).x>0.5 ) pacmanMovDirNex.z = 4.0;\n\n        \/\/ execute desired turn as soon as possible\n        if( pacmanMovDirNex.z>0.5 && abs(loadValue( pacmanPos.xy + dir2dis(pacmanMovDirNex.z) ).x-W)>0.25 )\n        {\n            pacmanMovDirNex = vec3( pacmanMovDirNex.zz, 0.0 );\n        }\n        \n        \n        if( pacmanMovDirNex.x>0.5 ) pacmanPos.z += iTimeDelta*speedPacman;\n\n        vec2 off = dir2dis(pacmanMovDirNex.x);\n        vec2 np = pacmanPos.xy + off;\n        float c = loadValue( np ).x;\n        pacmanPos.w = step( 0.25, abs(c-W) );\n\n                \n        if( pacmanPos.z>=1.0 )\n        {\n            pacmanPos.z = 0.0;\n            float c = loadValue( np ).x;\n\n            if( abs(c-W)<0.25 )\n            {\n                pacmanMovDirNex.x = 0.0;\n            }\n            else\n            {\n                pacmanPos.xy = np;\n                \/\/ tunnel!\n                     if( pacmanPos.x< 0.0 ) pacmanPos.x=26.0;\n                else if( pacmanPos.x>26.0 ) pacmanPos.x= 0.0;\n            }\n\n            float isin = isInside( fragCoord, pacmanPos.xy );\n            c = loadValue( pacmanPos.xy ).x;\n            if( abs(c-P)<0.2 )\n            {\n                if( isin>0.0 ) cell = _;\n                points += vec2(10.0,1.0);\n            }\n            else if( abs(c-B)<0.2 )\n            {\n                if( isin>0.0 ) cell = _;\n                points += vec2(50.0,1.0);\n                mode.x = 1.0;\n                mode.y = iGlobalTime;\n            }\n            if( points.y>241.5 )\n            {\n                state = 2.0;\n            }\n        }\n        \n        \/\/-------------------\n        \/\/ ghost\n        \/\/-------------------\n\n        for( int i=0; i<4; i++ )\n        {\n            float seed = float(iFrame)*13.1 + float(i)*17.43;\n\n            ghostPos[i].z += iTimeDelta*speedGhost;\n\n            if( ghostPos[i].z>=1.0 )\n            {\n                ghostPos[i].z = 0.0;\n\n                float c = loadValue( ghostPos[i].xy+dir2dis(ghostPos[i].w) ).x;\n\n                bool wr = abs(loadValue( ghostPos[i].xy+vec2( 1.0, 0.0) ).x-W)<0.25;\n                bool wl = abs(loadValue( ghostPos[i].xy+vec2(-1.0, 0.0) ).x-W)<0.25;\n                bool wu = abs(loadValue( ghostPos[i].xy+vec2( 0.0, 1.0) ).x-W)<0.25;\n                bool wd = abs(loadValue( ghostPos[i].xy+vec2( 0.0,-1.0) ).x-W)<0.25;\n\n                vec2 ra = vec2( hash( seed + 0.0),\n                                hash( seed + 11.57) );\n                if( abs(c-W) < 0.25) \/\/ found a wall on the way\n                {\n                    if( ghostPos[i].w < 2.5 ) \/\/ was moving horizontally\n                    {\n                             if( !wu &&  wd )                ghostPos[i].w = 3.0;\n                        else if(  wu && !wd )                ghostPos[i].w = 4.0;\n                        else if( pacmanPos.y>ghostPos[i].y ) ghostPos[i].w = 3.0+mode.x;\n                        else if( pacmanPos.y<ghostPos[i].y ) ghostPos[i].w = 4.0-mode.x;\n                        else                                 ghostPos[i].w = 3.0-ghostPos[i].w;\n                    }\n                    else                          \/\/ was moving vertically\n                    {\n                             if( !wr &&  wl )                ghostPos[i].w = 1.0;\n                        else if(  wr && !wl )                ghostPos[i].w = 2.0;\n                        else if( pacmanPos.x>ghostPos[i].x ) ghostPos[i].w = 1.0+mode.x;\n                        else if( pacmanPos.x<ghostPos[i].x ) ghostPos[i].w = 2.0-mode.x;\n                        else                                 ghostPos[i].w = 7.0-ghostPos[i].w;\n                    }\n\n                }\n                else if( ra.x < intelligence ) \/\/ found an intersection and it decided to find packman\n                {\n                    if( ghostPos[i].w < 2.5 ) \/\/ was moving horizontally\n                    {\n                             if( !wu && pacmanPos.y>ghostPos[i].y ) ghostPos[i].w = 3.0;\n                        else if( !wd && pacmanPos.y<ghostPos[i].y ) ghostPos[i].w = 4.0;\n                    }\n                    else                          \/\/ was moving vertically\n                    {\n                             if( !wr && pacmanPos.x>ghostPos[i].x ) ghostPos[i].w = 1.0;\n                        else if( !wl && pacmanPos.x<ghostPos[i].x ) ghostPos[i].w = 2.0;\n                    }\n                }\n                else\n                {\n                         if( ra.y<0.15 ) { if( !wr ) ghostPos[i].w = 1.0; }\n                    else if( ra.y<0.30 ) { if( !wl ) ghostPos[i].w = 2.0; }\n                    else if( ra.y<0.45 ) { if( !wu ) ghostPos[i].w = 3.0; }\n                    else if( ra.y<0.60 ) { if( !wd ) ghostPos[i].w = 4.0; }\n                }\n\n                if( abs(ghostPos[i].x-13.0)<0.25 &&\n                    abs(ghostPos[i].y-19.0)<0.25 && \n                    abs(ghostPos[i].w-4.0)<0.25 )\n                {\n                    ghostPos[i].w = 1.0;\n                }\n                \n                ghostPos[i].xy += dir2dis(ghostPos[i].w);\n                    \n                    \/\/ tunnel!\n                     if( ghostPos[i].x< 0.0 ) ghostPos[i].x=26.0;\n                else if( ghostPos[i].x>26.0 ) ghostPos[i].x= 0.0;\n            }\n            \n            \n            \/\/ collision\n            if( abs(pacmanPos.x-ghostPos[i].x)<0.5 && abs(pacmanPos.y-ghostPos[i].y)<0.5 )\n            {\n                if( mode.x<0.5 )\n                {\n                    lives -= 1.0;\n                    if( lives<0.5 )\n                    {\n                \t\tstate = 2.0;\n                    }\n                    else\n                    {\n                        state = 0.0;\n                    }\n                }\n                else\n                {\n                    points.x += 200.0;\n                    ghostPos[i] = vec4(13.0,19.0,0.0,1.0);\n                }\n            }\n        }\n \n        \/\/-------------------\n        \/\/ mode\n        \/\/-------------------\n        mode.z = (iGlobalTime-mode.y)\/modeTime;\n        if( mode.x>0.5 && mode.z>1.0 )\n        {\n            mode.x = 0.0;\n        }\n    }\n    else \/\/if( state > 0.5 )\n    {\n        float pressSpace = texture2D( iChannel1, vec2(KEY_SPACE,0.25) ).x;\n        if( pressSpace>0.5 )\n        {\n            state = -1.0;\n        }\n    }\n  \n\t\/\/---------------------------------------------------------------------------------\n\t\/\/ store game state\n\t\/\/---------------------------------------------------------------------------------\n    fragColor = vec4(0.0);\n \n    \n    storeValue( txPacmanPos,        vec4(pacmanPos),             fragColor, fragCoord );\n    storeValue( txPacmanMovDirNex,  vec4(pacmanMovDirNex,0.0),   fragColor, fragCoord );\n    storeValue( txGhost0PosDir,     vec4(ghostPos[0]),           fragColor, fragCoord );\n    storeValue( txGhost1PosDir,     vec4(ghostPos[1]),           fragColor, fragCoord );\n    storeValue( txGhost2PosDir,     vec4(ghostPos[2]),           fragColor, fragCoord );\n    storeValue( txGhost3PosDir,     vec4(ghostPos[3]),           fragColor, fragCoord );\n    storeValue( txPoints,           vec4(points,0.0,0.0),        fragColor, fragCoord );\n    storeValue( txState,            vec4(state,0.0,0.0,0.0),     fragColor, fragCoord );\n    storeValue( txMode,             vec4(mode,0.0),              fragColor, fragCoord );\n    storeValue( txLives,            vec4(lives,0.0,0.0,0.0),     fragColor, fragCoord );\n    storeValue( txCells,            vec4(cell,0.0,0.0,0.0),      fragColor, fragCoord );\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\n\/\/ rendering\n\nconst vec2 txPacmanPos       = vec2(31.0,1.0);\nconst vec2 txPacmanMovDirNex = vec2(31.0,3.0);\nconst vec2 txPoints          = vec2(31.0,5.0);\nconst vec2 txState           = vec2(31.0,7.0);\nconst vec2 txGhost0PosDir    = vec2(31.0, 9.0);\nconst vec2 txGhost1PosDir    = vec2(31.0,11.0);\nconst vec2 txGhost2PosDir    = vec2(31.0,13.0);\nconst vec2 txGhost3PosDir    = vec2(31.0,15.0);\nconst vec2 txMode            = vec2(31.0,17.0);\nconst vec2 txLives           = vec2(31.0,19.0);\nconst vec4 txCells           = vec4(0.0,0.0,27.0,31.0);\n\n\/\/============================================================\n\nfloat sdBox( vec2 p, vec2 b )\n{\n  vec2 d = abs(p) - b;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdBox( vec2 p, vec2 a, vec2 b )\n{\n  p -= (a+b)*0.5;\n  vec2 d = abs(p) - 0.5*(b-a);\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat sdCircle( in vec2 p, in float r )\n{\n    return length( p ) - r;\n}\n\n\n\/\/============================================================\n\nfloat SampleDigit(const in float n, const in vec2 vUV)\n{\n    if( abs(vUV.x-0.5)>0.5 || abs(vUV.y-0.5)>0.5 ) return 0.0;\n\n    \/\/ digit data by P_Malin (https:\/\/www.shadertoy.com\/view\/4sf3RN)\n    float data = 0.0;\n         if(n < 0.5) data = 7.0 + 5.0*16.0 + 5.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 1.5) data = 2.0 + 2.0*16.0 + 2.0*256.0 + 2.0*4096.0 + 2.0*65536.0;\n    else if(n < 2.5) data = 7.0 + 1.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 3.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 4.5) data = 4.0 + 7.0*16.0 + 5.0*256.0 + 1.0*4096.0 + 1.0*65536.0;\n    else if(n < 5.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 6.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 1.0*4096.0 + 7.0*65536.0;\n    else if(n < 7.5) data = 4.0 + 4.0*16.0 + 4.0*256.0 + 4.0*4096.0 + 7.0*65536.0;\n    else if(n < 8.5) data = 7.0 + 5.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    else if(n < 9.5) data = 7.0 + 4.0*16.0 + 7.0*256.0 + 5.0*4096.0 + 7.0*65536.0;\n    \n    vec2 vPixel = floor(vUV * vec2(4.0, 5.0));\n    float fIndex = vPixel.x + (vPixel.y * 4.0);\n    \n    return mod(floor(data \/ pow(2.0, fIndex)), 2.0);\n}\n\nfloat PrintInt( in vec2 uv, in float value )\n{\n    float res = 0.0;\n    float maxDigits = 1.0+ceil(.01+log2(value)\/log2(10.0));\n    float digitID = floor(uv.x);\n    if( digitID>0.0 && digitID<maxDigits )\n    {\n        float digitVa = mod( floor( value\/pow(10.0,maxDigits-1.0-digitID) ), 10.0 );\n        res = SampleDigit( digitVa, vec2(fract(uv.x), uv.y) );\n    }\n\n    return res;\n}\n\nvec4 loadValue( in vec2 re )\n{\n    return texture2D( iChannel0, (0.5+re) \/ iChannelResolution[0].xy, -100.0 );\n}\n\n\/\/============================================================\n\nvec3 drawMap( vec3 col, in vec2 fragCoord )\n{\n    vec2 p = fragCoord\/iResolution.y;\n    p.x += 0.5*(1.0-iResolution.x\/iResolution.y); \/\/ center\n    float wp = 1.0\/iResolution.y;\n\n    vec2 q = floor(p*31.0);\n    vec2 r = fract(p*31.0);\n    float wr = 31.0*wp;\n\n    if( q.x>=0.0 && q.x<=27.0 )\n    {\n        float c = texture2D( iChannel0, (q+0.5)\/iResolution.xy, -100.0 ).x;\n\n        \/\/ empty\n        if( c<0.5 )\n        {\n        }\n        \/\/ walls\n        else if( c<1.5 )\n        {\n            vec2 wmi = vec2( texture2D( iChannel0, (q-vec2(1.0,0.0)+0.5)\/iResolution.xy ).x,\n                             texture2D( iChannel0, (q-vec2(0.0,1.0)+0.5)\/iResolution.xy ).x );\n            vec2 wma = vec2( texture2D( iChannel0, (q+vec2(1.0,0.0)+0.5)\/iResolution.xy ).x,\n                             texture2D( iChannel0, (q+vec2(0.0,1.0)+0.5)\/iResolution.xy ).x );\n\t\t\t\n            wmi = step( abs(wmi-1.0), vec2(0.25) );\n            wma = step( abs(wma-1.0), vec2(0.25) );\n            vec2 ba = -(0.16+0.35*wmi);\n            vec2 bb =  (0.16+0.35*wma);\n\n            \/\/bb = vec2(0.51); ba = -bb;\n\n            float d = sdBox(r-0.5, ba, bb);\n            float f = 1.0 - smoothstep( -0.01, 0.01, d );\n            \n            vec3 wco = 0.5 + 0.5*cos( 3.9 - 0.2*(wmi.x+wmi.y+wma.x+wma.y) + vec3(0.0,1.0,1.5) );\n            wco += 0.1*sin(40.0*d);\n            col = mix( col, wco, f );\n        }\n        \/\/ points\n        else if( c<2.5 )\n        {\n            float d = sdCircle(r-0.5, 0.15);\n            float f = 1.0 - smoothstep( -wr, wr, d );\n            col = mix( col, vec3(1.0,0.8,0.7), f );\n            \/\/col += 0.3*vec3(1.0,0.7,0.4)*exp(-12.0*d*d); \/\/ glow\n        }\n        \/\/ big alls\n        else\n        {\n            float d = sdCircle( r-0.5 ,0.40*smoothstep( -1.0, -0.5, sin(2.0*6.2831*iGlobalTime) ));\n            float f = 1.0 - smoothstep( -wr, wr, d );\n            col = mix( col, vec3(1.0,0.9,0.5), f );\n        }\n    }\n    \n    return col;\n}\n\nvec2 dir2dis( float dir )\n{\n    vec2 off = vec2(0.0);\n         if( dir<0.5 ) { off = vec2( 0.0, 0.0); }\n    else if( dir<1.5 ) { off = vec2( 1.0, 0.0); }\n    else if( dir<2.5 ) { off = vec2(-1.0, 0.0); }\n    else if( dir<3.5 ) { off = vec2( 0.0, 1.0); }\n    else               { off = vec2( 0.0,-1.0); }\n    return off;\n}\n\n\nvec2 cell2ndc( vec2 c )\n{\n\tc = (c+0.5) \/ 31.0;\n    c.x -= 0.5*(1.0-iResolution.x\/iResolution.y); \/\/ center\n    return c;\n}\n\n\nvec3 drawPacman( vec3 col, in vec2 fragCoord, in vec4 pacmanPos, in vec3 pacmanMovDirNex )\n{\n    vec2 off = dir2dis(pacmanMovDirNex.x);\n    \n    vec2 mPacmanPos = pacmanPos.xy;\n    \/\/vec2 mPacmanPos = pacmanPos.xy + off*pacmanPos.z*pacmanPos.w;\n\n    vec2 p = fragCoord\/iResolution.y;\n    float eps = 1.0 \/ iResolution.y;\n\n    vec2 q = p - cell2ndc( mPacmanPos );\n\n         if( pacmanMovDirNex.y<1.5 ) { q = q.xy*vec2(-1.0,1.0); }\n    else if( pacmanMovDirNex.y<2.5 ) { q = q.xy; }\n    else if( pacmanMovDirNex.y<3.5 ) { q = q.yx*vec2(-1.0,1.0); }\n    else                             { q = q.yx; }\n\n    float c = sdCircle(q, 0.023);\n    float f = c;\n\n    if( pacmanMovDirNex.y>0.5 )\n    {\n        float an = (0.5 + 0.5*sin(4.0*iGlobalTime*6.2831)) * 0.9;\n        vec2 w = normalize( q - vec2(0.005,0.0) );\n\n        w = vec2( w.x, abs( w.y ) );\n        float m = dot( w, vec2(sin(an),cos(an)));\n        f = max( f, -m );\n    }\n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, vec3(1.0,0.8,0.1), f );\n\n    \/\/ glow\n    \/\/col += 0.25*vec3(1.0,0.8,0.0)*exp(-300.0*c*c);\n\n    return col;\n}\n\nvec3 drawGhost( vec3 col, in vec2 fragCoord, in vec3 pos, in float dir, in float id, in vec3 mode )\n{\n    vec2 off = dir2dis(dir);\n\n    vec2 gpos = pos.xy;\n\n    \n    vec2 p = fragCoord\/iResolution.y;\n    float eps = 1.0 \/ iResolution.y;\n\n    vec2 q = p - cell2ndc( gpos );\n\n    float c = sdCircle(q, 0.023);\n    float f = c;\n\tf = max(f,-q.y);\n    float on = 0.0025*sin(1.0*6.28318*q.x\/0.025 + 6.2831*iGlobalTime);\n    f = min( f, sdBox(q-vec2(0.0,-0.0065+on), vec2(0.023,0.012) ) );\n   \n    vec3 gco = 0.5 + 0.5*cos( 5.0 + 0.7*id + vec3(0.0,2.0,4.0) );\n    float g = mode.x;\n    if( mode.z>0.75 )\n    {\n        g *= smoothstep(-0.2,0.0,sin(3.0*6.28318*(iGlobalTime-mode.y)));\n    }\n    gco = mix( gco, vec3(0.1,0.5,1.0), g );\n    \n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, gco, f );\n\n    f = sdCircle( vec2(abs(q.x-off.x*0.006)-0.011,q.y-off.y*0.006-0.008), 0.008);\n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, vec3(1.0), f );\n\n    f = sdCircle( vec2(abs(q.x-off.x*0.01)-0.011,q.y-off.y*0.01-0.008), 0.004);\n    f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n    col = mix( col, vec3(0.0), f );\n\n    \/\/ glow\n    \/\/col += 0.2*gco*exp(-300.0*c*c);\n\n    return col;\n}\n\n\nvec3 drawScore( in vec3 col, in vec2 fragCoord, vec2 score, float lives )\n{\n    \/\/ score\n    vec2 p = fragCoord\/iResolution.y;\n    col += PrintInt( (p - vec2(0.05,0.9))*20.0, score.x );\n    col += PrintInt( (p - vec2(0.05,0.8))*20.0, 242.0-score.y );\n    \n    \/\/ lives\n    float eps = 1.0 \/ iResolution.y;\n    for( int i=0; i<3; i++ )\n    {\n        float h = float(i);\n        vec2 q = p - vec2(0.1 + 0.075*h, 0.7 );\n        if( h + 0.5 < lives )\n        {\n            float c = sdCircle(q, 0.023);\n            float f = c;\n\n            {\n                vec2 w = normalize( q - vec2(0.005,0.0) );\n                w = vec2( w.x, abs( w.y ) );\n                float an = 0.5;\n                float m = dot( w, vec2(sin(an),cos(an)));\n                f = max( f, -m );\n            }\n            f = 1.0 - smoothstep( -0.5*eps, 0.5*eps, f );\n            col = mix( col, vec3(1.0,0.8,0.1), f );\n\n            \/\/ glow\n            \/\/col += 0.15*vec3(1.0,0.8,0.0)*exp(-1500.0*c*c);\n        }\n    }\n\n    return col;\n}\n\n\/\/============================================================\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/------------------------\n    \/\/ load game state\n    \/\/------------------------\n       \n    vec4  pacmanPos = loadValue( txPacmanPos );\n    vec3  pacmanDir = loadValue( txPacmanMovDirNex ).xyz;\n    vec4  ghostPos[4];\n    ghostPos[0]     = loadValue( txGhost0PosDir );\n    ghostPos[1]     = loadValue( txGhost1PosDir );\n    ghostPos[2]     = loadValue( txGhost2PosDir );\n    ghostPos[3]     = loadValue( txGhost3PosDir );\n    vec2  points    = loadValue( txPoints ).xy;\n    float state     = loadValue( txState ).x;\n    float lives     = loadValue( txLives ).x;\n    vec3 mode       = loadValue( txMode ) .xyz;\n\n\n    \/\/------------------------\n    \/\/ render\n    \/\/------------------------\n    vec3 col = vec3(0.0);\n    \n    \/\/ map\n    col = drawMap( col, fragCoord );\n    \n    \/\/ pacman\n    col = drawPacman( col, fragCoord, pacmanPos, pacmanDir );\n\n    \/\/ ghosts\n    for( int i=0; i<4; i++ )\n    {\n        col = drawGhost( col, fragCoord, ghostPos[i].xyz, ghostPos[i].w, float(i), mode );\n    }\n\n    \/\/ score\n    col = drawScore( col, fragCoord, points, lives );\n \n    \n    if( state>1.5 )\n    {\n        col = mix( col, vec3(0.3), smoothstep(-1.0,1.0,sin(2.0*6.2831*iGlobalTime)) );\n    }\n    \n\tfragColor = vec4( col, 1.0 );\n}","name":"Buf B","description":"","type":"buffer"}]}}