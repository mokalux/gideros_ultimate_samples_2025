{"Shader":{"ver":"0.1","info":{"id":"XsSSWW","date":"1411899696","viewed":767,"name":"Minimal ray tracer","username":"Zavie","description":"Only handles specular bounces (no GI) with perfect smoothness.<br\/>Bonus question: why are colors different in ANGLE and native?","likes":12,"published":3,"flags":0,"tags":["raytracing"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"#define MAX_BOUNCES 8\nfloat gamma = 2.2;\n\n\/\/ ---8<----------------------------------------------------------------------\n\/\/ Geometry\n\n#define PI 3.14159275358979\n\nstruct Ray\n{\n    vec3 o;\t\t\/\/ Origin\n    vec3 d;\t\t\/\/ Direction\n};\n\nstruct Hit\n{\n    float t;\t\/\/ ray solution\n    vec3 n;\t\t\/\/ normal\n    int m;\t\t\/\/ material\n};\nconst Hit noHit = Hit(1e10, vec3(0.), -1);\n\nstruct Plane\n{\n    float d;\t\/\/ offset\n    vec3 n;\t\t\/\/ normal\n    int m;\t\t\/\/ material\n};\n\nstruct Sphere\n{\n\tfloat r;\t\/\/ radius\n    vec3 p;\t\t\/\/ center position\n    int m;\t\t\/\/ material\n};\n\nstruct AABox\n{\n    vec3 s;\t\t\/\/ size\n    vec3 p;\t\t\/\/ center position\n    int m;\t\t\/\/ metrial\n};\n\nHit intersectPlane(Plane p, Ray r)\n{\n    float dotnd = -dot(p.n, r.d);\n    if (dotnd < 0.) return noHit;\n\n \tfloat t = (dot(p.n, r.o) + p.d) \/ dotnd;\n \treturn Hit(t, p.n, p.m);\n}\n\nbool isInside(vec2 a, vec2 b)\n{\n    return a.x < b.x && a.y < b.y;\n}\n\nvoid AAboxPlaneIntersection(vec3 o, vec3 d, vec3 s, inout float t, out float ndir)\n{\n    ndir = 0.;\n    if (d.x != 0.)\n    {\n        float tmin = (-0.5 * s.x - o.x) \/ d.x;\n        if (tmin >= 0. && tmin < t && isInside(abs(o.yz + tmin * d.yz), 0.5 * s.yz))\n        {\n            t = tmin;\n            ndir = -1.;\n        }\n\n        float tmax = (0.5 * s.x - o.x) \/ d.x;\n        if (tmax >= 0. && tmax < t && isInside(abs(o.yz + tmax * d.yz), 0.5 * s.yz))\n        {\n            t = tmax;\n            ndir = 1.;\n        }\n    }\n}\n    \nHit intersectBox(AABox b, Ray r)\n{\n    Hit hit = noHit;\n    vec3 ro = r.o - b.p;\n\n    float ndir = 0.;\n    AAboxPlaneIntersection(ro.xyz, r.d.xyz, b.s.xyz, hit.t, ndir);\n    if (ndir != 0.) { hit.n = vec3(ndir, 0., 0.); hit.m = b.m; }\n\n    AAboxPlaneIntersection(ro.yzx, r.d.yzx, b.s.yzx, hit.t, ndir);\n    if (ndir != 0.) { hit.n = vec3(0., ndir, 0.); hit.m = b.m; }\n\n    AAboxPlaneIntersection(ro.zxy, r.d.zxy, b.s.zxy, hit.t, ndir);\n    if (ndir != 0.) { hit.n = vec3(0., 0., ndir); hit.m = b.m; }\n\n    return hit;\n}\n\nHit intersectSphere(Sphere s, Ray r)\n{\n\tvec3 op = s.p - r.o;\n    float b = dot(op, r.d);\n    float det = b * b - dot(op, op) + s.r * s.r;\n    if (det < 0.) return noHit;\n    \n    det = sqrt(det);\n    float t = b - det;\n    if (t < 0.) t = b + det;\n    if (t < 0.) return noHit;\n    \n    return Hit(t, (r.o + t*r.d - s.p) \/ s.r, s.m);\n}\n\nHit intersectScene(Ray r)\n{\n    Sphere s1 = Sphere(1., vec3(-2., 1., 0.), 0);\n    Sphere s2 = Sphere(0.8, vec3(0.5, 0.8, -1.2), 3);\n    Sphere s3 = Sphere(0.8, vec3(2.0, 0.8, -0.8), 4);\n    Plane p = Plane(0., vec3(0., 1., 0.), 1);\n    AABox b = AABox(vec3(0.8, 0.1, 0.75), vec3(1.2, 0.1, 1.7), 2);\n\n    Hit hit = Hit(1e5, vec3(0.), -1);\n    Hit hitp = intersectPlane(p, r); if (hitp.m != -1 && hitp.t < hit.t) { hit = hitp; }\n    Hit hits1 = intersectSphere(s1, r); if (hits1.m != -1 && hits1.t < hit.t) { hit = hits1; }\n    Hit hits2 = intersectSphere(s2, r); if (hits2.m != -1 && hits2.t < hit.t) { hit = hits2; }\n    Hit hits3 = intersectSphere(s3, r); if (hits3.m != -1 && hits3.t < hit.t) { hit = hits3; }\n\tHit hitb = intersectBox(b, r); if (hitb.t != 0. && hitb.t < hit.t) { hit = hitb; }\n    return hit;\n}\n\n\/\/ ---8<----------------------------------------------------------------------\n\/\/ Physics\n\nstruct Material\n{\n    vec3 c;\t\t\/\/ diffuse color\n    vec3 f0;\t\/\/ specular color\n};\n\n#define NUM_MATERIALS 5\nMaterial materials[NUM_MATERIALS];\n\nMaterial getMaterial(Hit hit)\n{\n    \/\/ FIXME: what would be the correct way to do this?\n    Material m = Material(vec3(0.), vec3(0.));\n    for (int i = 0; i < NUM_MATERIALS; ++i)\n    {\n        if (i == hit.m) m = materials[i];\n    }\n    return m;\n}\n\nvec3 sunCol = vec3(1e3);\nvec3 sunDir = normalize(vec3(.8, .55, -1.));\nvec3 skyColor(vec3 d)\n{\n    float transition = pow(smoothstep(0.02, .5, d.y), 0.4);\n\n    vec3 sky = 2e2*mix(vec3(0.52, 0.77, 1), vec3(0.12, 0.43, 1), transition);\n    vec3 sun = vec3(1e7) * pow(abs(dot(d, sunDir)), 5000.);\n    return sky + sun;\n}\n\nfloat pow5(float x) { return x * x * x * x * x; }\n\n\/\/ Schlick approximation\nvec3 fresnel(vec3 h, vec3 v, vec3 f0)\n{\n  return pow5(1. - clamp(dot(h, v), 0., 1.)) * (1. - f0) + f0;\n}\n\nvec3 radiance(Ray r)\n{\n    float epsilon = 4e-4;\n\n    vec3 accum = vec3(0.);\n    vec3 filter = vec3(1.);\n\n    for (int i = 0; i <= MAX_BOUNCES; ++i)\n    {\n        Hit hit = intersectScene(r);\n\n        if (hit.m >= 0)\n        {\n            Material m = getMaterial(hit);\n            vec3 f = fresnel(hit.n, -r.d, m.f0);\n\n            \/\/ Diffuse\n            if (intersectScene(Ray(r.o + hit.t * r.d + epsilon * sunDir, sunDir)).m == -1)\n            {\n                accum += (1. - f) * filter * m.c * clamp(dot(hit.n, sunDir), 0., 1.) * sunCol;\n            }\n            \n            \/\/ Specular: next bounce\n            filter *= f;\n            vec3 d = reflect(r.d, hit.n);\n            r = Ray(r.o + hit.t * r.d + epsilon * d, d);\n        }\n        else\n        {\n            accum += filter * skyColor(r.d);\n            break;\n        }\n    }\n    return accum;\n}\n\n\/\/ ---8<----------------------------------------------------------------------\n\/\/ Tone mapping\n\n\/\/ See: http:\/\/filmicgames.com\/archives\/75\nvec3 Uncharted2ToneMapping(vec3 color)\n{\n\tfloat A = 0.15;\n\tfloat B = 0.50;\n\tfloat C = 0.10;\n\tfloat D = 0.20;\n\tfloat E = 0.02;\n\tfloat F = 0.30;\n\tfloat W = 11.2;\n\tfloat exposure = 0.012;\n\tcolor *= exposure;\n\tcolor = ((color * (A * color + C * B) + D * E) \/ (color * (A * color + B) + D * F)) - E \/ F;\n\tfloat white = ((W * (A * W + C * B) + D * E) \/ (W * (A * W + B) + D * F)) - E \/ F;\n\tcolor \/= white;\n\tcolor = pow(color, vec3(1. \/ gamma));\n\treturn color;\n}\n\n\/\/ ---8<----------------------------------------------------------------------\n\/\/ Scene\n\nvoid init()\n{\n    materials[0] = Material(vec3(1.0, 0.0, 0.2), vec3(0.02));\n    materials[1] = Material(vec3(0.5, 0.4, 0.3), vec3(0.02));\n    \/\/ Copper\n    materials[2] = Material(vec3(0.1), vec3(0.95, 0.64, 0.54));\n\n    \/\/ Chrome\n    materials[3] = Material(vec3(0.0), vec3(0.55, 0.56, 0.55));\n\n    \/\/ Gold\n    materials[4] = Material(vec3(0.0), vec3(1., 0.77, 0.34));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2. * fragCoord.xy \/ iResolution.xy - 1.;\n    \n    init();\n    \n    float o1 = 0.25;\n    float o2 = 0.75;\n    vec2 msaa[4];\n    msaa[0] = vec2( o1,  o2);\n    msaa[1] = vec2( o2, -o1);\n    msaa[2] = vec2(-o1, -o2);\n    msaa[3] = vec2(-o2,  o1);\n\n    vec3 color = vec3(0.);\n    for (int i = 0; i < 4; ++i)\n    {\n        vec3 p0 = vec3(0., 1.1, 4.);\n        vec3 p = vec3((2. * (iMouse.xy==vec2(0.)?.5*iResolution.xy:iMouse.xy) \/ iResolution.xy - 1.) * vec2(1., 1.), 0.) + p0;\n        vec3 offset = vec3(msaa[i] \/ iResolution.y, 0.);\n        vec3 d = normalize(vec3(iResolution.x\/iResolution.y * uv.x, uv.y, -1.5) + offset);\n        Ray r = Ray(p, d);\n        color += radiance(r) \/ 4.;\n    }\n\n\tfragColor = vec4(Uncharted2ToneMapping(color),1.0);\n}\n","name":"Image","description":"","type":"image"}]}}