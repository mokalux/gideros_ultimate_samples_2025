{"Shader":{"ver":"0.1","info":{"id":"XsK3Rd","date":"1455921464","viewed":381,"name":"Lorenz Attractor Divergence (3D)","username":"Flyguy","description":" A volumetric ray marched version of my previous shader: https:\/\/www.shadertoy.com\/view\/Msy3R3\nThe volumetric texture is computed in Buf A at a resolution of floor(cuberoot(resolution.x * resolution.y)).","likes":13,"published":3,"flags":48,"tags":["raymarching","math","volume","chaos","lorenz"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/Press space to reset.\n\n#define RotateX(v,a) v.yz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateY(v,a) v.xz *= mat2(cos(a),sin(a),-sin(a),cos(a))\n#define RotateZ(v,a) v.xy *= mat2(cos(a),sin(a),-sin(a),cos(a))\n\n#define MIN_MARCH_DIST 0.001\n#define MAX_MARCH_STEPS 64\n#define MAX_VOLUME_STEPS 290\n#define VOLUME_STEP_SIZE 0.02\n\n#define DISP_MODE XYZ\n\n#define XYZ 0\n#define XYZ_STEP 1\n#define LENGTH 2\n#define VOLUME_BUFFER 3\n\nvec3 vres = vec3(0);\n\nvec4 sample3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * vres), vres);\n    \n    \/\/XYZ -> Pixel index\n    float idx = (uvw.z * (vres.x*vres.y)) + (uvw.y * vres.x) + uvw.x;\n    \n    \/\/Pixel index -> Buffer uv coords\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx \/ iResolution.x));\n    \n    return texture2D(tex, (uv + 0.5) \/ iResolution.xy);\n}\n\nvec4 sample3DLinear(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    vec3 blend = fract(uvw*vres);\n    vec4 off = vec4(1.0\/vres, 0.0);\n    \n    \/\/2x2x2 sample blending\n    vec4 b000 = sample3D(tex, uvw + off.www, vres);\n    vec4 b100 = sample3D(tex, uvw + off.xww, vres);\n    \n    vec4 b010 = sample3D(tex, uvw + off.wyw, vres);\n    vec4 b110 = sample3D(tex, uvw + off.xyw, vres);\n    \n    vec4 b001 = sample3D(tex, uvw + off.wwz, vres);\n    vec4 b101 = sample3D(tex, uvw + off.xwz, vres);\n    \n    vec4 b011 = sample3D(tex, uvw + off.wyz, vres);\n    vec4 b111 = sample3D(tex, uvw + off.xyz, vres);\n    \n    return mix(mix(mix(b000,b100,blend.x), mix(b010,b110,blend.x), blend.y), \n               mix(mix(b001,b101,blend.x), mix(b011,b111,blend.x), blend.y),\n               blend.z);\n}\n\nvec4 Volume(vec3 pos)\n{\n      return sample3DLinear(iChannel0, pos*0.5+0.5, vres);\n}\n\nvec3 MarchVolume(vec3 orig, vec3 dir)\n{\n    \/\/Ray march to find the cube surface.\n    float t = 0.0;\n    vec3 pos = orig;\n    for(int i = 0;i < MAX_MARCH_STEPS;i++)\n    {\n        pos = orig + dir * t;\n        float dist = 100.0;\n        \n        dist = min(dist, 8.0-length(pos));\n        dist = min(dist, max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0);\/\/length(pos)-1.0);\n        \n        t += dist;\n        \n        if(dist < MIN_MARCH_DIST){break;}\n    }\n    \n    \/\/Step though the volume and add up the opacity.\n    vec4 col = vec4(0.0);\n    for(int i = 0;i < MAX_VOLUME_STEPS;i++)\n    {\n    \tt += VOLUME_STEP_SIZE;\n        \n    \tpos = orig + dir * t;\n        \n        \/\/Stop if the sample leaves the volume.\n        if(max(max(abs(pos.x),abs(pos.y)),abs(pos.z))-1.0 > 0.0) {break;}\n        \n        vec4 vol = vec4(0);\n        #if(DISP_MODE == XYZ)\n        \tvol = abs(Volume(pos)) * 0.001;\n        #elif(DISP_MODE == XYZ_STEP)\n        \tvol = smoothstep(6.0, 0.8, abs(Volume(pos))) * 0.02;\n        #elif(DISP_MODE == LENGTH)\n        \tvol = vec4(20.0 \/ pow(length(Volume(pos)),2.0) * 0.1);\n        #endif\n        \n        \n        col += vol;\n    }\n    \n    return col.rgb;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0\/3.0)));\n    \n    vec2 res = iResolution.xy \/ iResolution.y;\n\tvec2 uv = fragCoord.xy \/ iResolution.y;\n    \n    vec3 dir = normalize(vec3(uv-res\/2.0,1.0));\n    vec3 orig = vec3(0,0,-3.5);\n\n        \n    RotateX(dir,radians(iMouse.y));\n    RotateX(orig,radians(iMouse.y));\n    RotateY(dir,radians(-iMouse.x));\n    RotateY(orig,radians(-iMouse.x));\n    \n    vec3 color = MarchVolume(orig,dir);\n    \n    #if(DISP_MODE == VOLUME_BUFFER)\n    \tcolor = texture2D(iChannel0, uv\/res).rgb;\n    #endif\n    \n\tfragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/\/Temporary hack to fix a bug in sample3D on OpenGL\n#define OPENGL_FIX\n\n\/\/Constants\n#define KEY_SPACE 0x20\n\n\/\/Settings\n#define STEPS 64.0\n#define SPEED 0.005\n\n\/\/System Parameters\nfloat O = 10.0;\nfloat P = 28.0;\nfloat B = 8.0\/3.0;\n\n\/\/Initial Position (startOrig +\/- startRang)\nvec3 startOrig = vec3(64.0, 0.0, 30.0);\nvec3 startRang = vec3(50.0);\n\n\/\/Calculate the next position \nvec3 Integrate(vec3 cur, float dt)\n{\n\tvec3 next = vec3(0);\n    \n    next.x = O * (cur.y - cur.x);\n    next.y = cur.x * (P - cur.z) - cur.y;\n    next.z = cur.x*cur.y - B*cur.z;\n    \n    return cur + next * dt;\n}\n\nbool KeyPressed(int key)\n{\n    return texture2D(iChannel1, vec2(key, 0) \/ 256.0).r != 0.0;\n}\n\nvec3 iVResolution = vec3(0);\n\nvec4 sample3D(sampler2D tex, vec3 uvw, vec3 vres);\n\nvoid mainVolume( out vec4 voxColor, in vec3 voxCoord)\n{\n    vec3 uvw = voxCoord \/ iVResolution;\n    \n    #ifdef OPENGL_FIX\n    \tvec3 last = texture2D(iChannel0,gl_FragCoord.xy\/iResolution.xy).xyz;\n    #else\n    \tvec3 last = sample3D(iChannel0, uvw, iVResolution).xyz;\n\t#endif\n\n    vec3 next = vec3(0);\n    \n    for(float i = 0.0;i < STEPS;i++)\n    {\n    \tnext = Integrate(last, iTimeDelta * SPEED);\n        last = next;\n    } \n\t\n     \/\/Setup initial conditions.\n    if(iFrame <= 30 || KeyPressed(KEY_SPACE))\n    {\n        uvw = (uvw - 0.5) * 2.0;\n        \n        startOrig += uvw * startRang;\n        \n        voxColor = vec4(startOrig, 0);\n    }\n    else \/\/Save current position.\n    {\n        voxColor = vec4(next, 0);\n    } \n}\n\nvec4 sample3D(sampler2D tex, vec3 uvw, vec3 vres)\n{\n    uvw = mod(floor(uvw * iVResolution), iVResolution);\n    float idx = (uvw.z * (iVResolution.x*iVResolution.y)) + (uvw.y * iVResolution.x) + uvw.x;\n    vec2 uv = vec2(mod(idx, iResolution.x), floor(idx \/ iResolution.x));\n    \n    return texture2D(tex, (uv + 0.5) \/ iResolution.xy);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec3 vres = vec3(floor(pow(iResolution.x*iResolution.y, 1.0\/3.0)));    \n    vec2 uv = floor(fragCoord - 0.5);\n    \n    float idx = (uv.y * iResolution.x) + uv.x;\n    \n    vec3 uvw = mod(floor(vec3(idx) \/ vec3(1.0, vres.x, vres.x*vres.y)), vres);\n    \n    iVResolution = vres;\n    mainVolume(fragColor, uvw);\n}\n","name":"Buf A","description":"","type":"buffer"}]}}