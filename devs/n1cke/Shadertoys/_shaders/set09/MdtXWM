{"Shader":{"ver":"0.1","info":{"id":"MdtXWM","date":"1459780217","viewed":319,"name":"2nd Order Implicit Approximation","username":"sibaku","description":"Implicit trace using a second order approximation for the distance. Exact gradient\/hessian is generated using a forward autodiff scheme. Move the camera by holding down the left mouse button and drag it around. More in the instructions at the top","likes":6,"published":3,"flags":16,"tags":["distancefield","spheretracing","implicit","hessian","autodiff","automaticdifferentiation"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/*************** INSTRUCTIONS **********************\n\/\/\n\/\/ Press and hold 'f' to use the usual first order approximation\n\/\/\n\/\/ Press and hold 'p' to use an eigenvalue estimate instead of the frobenius norm\n\/\/ (not really a noticeable effect...) \n\/\/ \n\/\/ Change the value of 'SCENE' just below to switch to different implicits\n\/\/\n\/\/ Move the camera by dragging the mouse with left button held down\n\/\/\n\/\/***************************************************\n\n\/\/ Scene from 0 to 6\n\/\/ Strongest effects are seen in 1,4,5,6\n\/\/ Scene 6 was originally a sphere. Same technique can be used to slightly rectify\n\/\/ distorted distance fields. As an alternative to computing maximum jacobian derivatives\n#define SCENE 4\n\n\/\/********************************************************************\n\/\/\n\/\/ Global defines\n\/\/ \n\/\/********************************************************************\n\n\/\/ Infinity\n#define AUTO_INFINITY 3.402823e+38\n\n\nconst float eps = 0.00001;\nconst float pi = 3.14159265359;\n\n\n\/\/ Maximum number of sphere trace steps\nconst int maxSteps = 150;\n\n\nbool useFirstOrder = false;\nbool usePowerMethod = false;\n\nbool isPressed(int key)\n{\n    float val = texture2D( iChannel0, vec2( (float(key)+0.5)\/256.0, 0.25 ) ).x;\n\treturn val > 0.5;\n}\n\nbool isToggled(int key)\n{\n    float val = texture2D( iChannel0, vec2( (float(key)+0.5)\/256.0, 0.75 ) ).x;\n\treturn val > 0.5;\n}\n\n\n\/\/ My very simple (and probably not overly great) forward-autodiff code from:\n\/\/ https:\/\/github.com\/sibaku\/glsl-autodiff\n\n\/\/********************************************************************\n\/\/\n\/\/ General functions\n\/\/ \n\/\/********************************************************************\n\nmat2 a_outerProduct(in vec2 a, in vec2 b)\n{\n\treturn mat2(a * b.x, a * b.y);\n}\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n\treturn mat3(a * b.x, a * b.y, a * b.z);\n}\n\nmat4 a_outerProduct(in vec4 a, in vec4 b)\n{\n\treturn mat4(a * b.x, a * b.y, a * b.z, a * b.w);\n}\n\n\/\/********************************************************************\n\/\/\n\/\/ Data structure for holding information for 3D Hessian calculation. Gradient is also included\n\/\/ \n\/\/********************************************************************\n\n\nstruct HessNum3\n{\n\tfloat val;\n\tvec3 g;\n\tmat3 h;\n};\n    \n    \/\/********************************************************************\n\/\/\n\/\/ 3D Hessian functions\n\/\/ \n\/\/********************************************************************\n\n\nHessNum3 a_constH3(in float val)\n{\n\treturn HessNum3(val, vec3(0.), mat3(0.));\n}\n\nHessNum3 neg(in HessNum3 a)\n{\n\treturn HessNum3(-a.val,-a.g,-a.h);\n}\n\nHessNum3 add(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val + b.val, a.g + b.g, a.h + b.h);\n}\nHessNum3 add(in HessNum3 a, in float b)\n{\n\treturn HessNum3(a.val + b, a.g , a.h);\n}\n\nHessNum3 add(in float a, in HessNum3 b)\n{\n\treturn HessNum3(b.val + a, b.g , b.h);\n}\n\nHessNum3 sub(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val - b.val, a.g - b.g, a.h - b.h);\n}\nHessNum3 sub(in HessNum3 a, in float b)\n{\n\treturn HessNum3(a.val - b, a.g , a.h);\n}\n\nHessNum3 sub(in float a, in HessNum3 b)\n{\n\treturn HessNum3(a - b.val, -b.g , -b.h);\n}\n\nHessNum3 mult(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));\n}\n\nHessNum3 mult(in HessNum3 a, float b)\n{\n\treturn HessNum3(a.val*b, a.g*b, a.h*b);\n}\n\nHessNum3 mult(in float a, in HessNum3 b)\n{\n\treturn HessNum3(b.val*a, b.g*a, b.h*a);\n}\n\nHessNum3 div(in HessNum3 a, in HessNum3 b)\n{\n\tHessNum3 r = HessNum3(a.val \/ b.val, a.g, a.h );\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g \/ b.val;\n\t\n\tr.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);\n\tr.h = r.h \/ b.val;\n\t\n\treturn r;\n\t\n}\nHessNum3 div(in HessNum3 a, float b)\n{\n\treturn HessNum3(a.val\/b, a.g\/b, a.h\/b);\n}\n\nHessNum3 a_sin(in HessNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum3(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_cos(in HessNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum3(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_exp(in HessNum3 a)\n{\n\tfloat e = exp(a.val);\n\treturn HessNum3(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_log(in HessNum3 a)\n{\n\tfloat ai = 1.\/a.val;\n\treturn HessNum3(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_pow(in HessNum3 a, float k)\n{\n\tfloat ap = k*pow(a.val,k-1.);\n\treturn HessNum3(pow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*pow(a.val,k-2.) * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_abs(in HessNum3 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\t\/\/ Probably better to always make this 0\n\tfloat lpp = a.val == 0. ? AUTO_INFINITY : 0.;\n\treturn HessNum3(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_sqrt(in HessNum3 a)\n{\n\tfloat as = sqrt(a.val);\n\tfloat asd = 1. \/ (2.*as);\n\tfloat asdd = -1.\/(4.*pow(a.val,3.\/2.));\n\treturn HessNum3(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g)); \n}\n\nfloat frobenius(in mat3 m)\n{\n \treturn sqrt(dot(m[0],m[0]) + dot(m[1],m[1]) + dot(m[2],m[2]));   \n}\n\n\/\/********************************************************************\n\/\/\n\/\/ Hessians\n\/\/ \n\/\/********************************************************************\n#define HESSIAN3(f,u,v,w,result) { vec3 uGrad = vec3(1.,0.,0.); HessNum3 uHessian = HessNum3(u,uGrad,mat3(0.)); vec3 vGrad = vec3(0.,1.,0.); HessNum3 vHessian = HessNum3(v,vGrad,mat3(0.)); vec3 wGrad = vec3(0.,0.,1.); HessNum3 wHessian = HessNum3(w,wGrad,mat3(0.)); result = f(uHessian,vHessian,wHessian);}\n\n\n\n\/\/********************************************************************\n\/\/\n\/\/ Non autodiff code\n\/\/ \n\/\/********************************************************************\n\n\/\/ Simple power iteration to find the eigenvalue with largest absolute value\nfloat powerNorm(in mat3 m)\n{\n    vec3 bk = vec3(1.);\n    bk = normalize(m*bk);\n    bk = normalize(m*bk);\n    bk = normalize(m*bk);\n    bk = normalize(m*bk);\n    return length(m*bk);\n}\n\nfloat calcNorm(in mat3 m)\n{\n \tif(usePowerMethod)\n        return powerNorm(m);\n    else\n        return frobenius(m);\n}\n\/\/ Different implicit functions f(x,y,z)\nHessNum3 implicit(in HessNum3 x, in HessNum3 y, in HessNum3 z)\n{\n    \n    #if SCENE == 0\n \t\treturn sub(a_sqrt(add(add(mult(x,x),mult(y,y)),mult(z,z))),a_constH3(1.));  \n    #elif SCENE==1\n    \treturn sub(y,a_sin(add(x,y)));\n    #elif SCENE==1\n    \n    return \n        sub(\n        \tadd(\n                mult(x,x),mult(z,z)\n            ),\n        \tmult(\n                z,\n                sub(\n                    a_constH3(1.),mult(y,y)\n                )\n            )\n        );\n\t\n     #elif SCENE==2\n    return sub(add(add(a_pow(x,4.),a_pow(y,4.)),a_pow(z,4.)),a_constH3(1.));\n     #elif SCENE==3\n    \n    return \n        sub(\n            sub(\n                a_pow(\n                    sub(\n                        add(\n                            add(\n                            mult(2.,mult(x,x))\n                            ,\n                            mult(2.,mult(z,z))\n                            ),\n                            mult(y,y)\n                        )\n                        ,\n                        a_constH3(1.)\n                    )\n                    ,\n                    3.\n                    )\n                ,\n                mult(0.1,mult(mult(x,x),a_pow(y,3.)))\n                )\n        \t,\n            mult(mult(z,z),a_pow(y,3.))\n        );\n\t#elif SCENE==4\n    \tHessNum3 c2 = a_constH3(2.);\n    \tHessNum3 f1 = mult(a_pow(sub(x,c2),2.),a_pow(add(x,c2),2.));\n    \tHessNum3 f2 = mult(a_pow(sub(y,c2),2.),a_pow(add(y,c2),2.));\n    \tHessNum3 f3 = mult(a_pow(sub(z,c2),2.),a_pow(add(z,c2),2.));\n    \tHessNum3 f4 = mult(3., add(add(mult(mult(x,x),mult(y,y)),mult(mult(x,x),mult(z,z)))\n                          ,mult(mult(y,y),mult(z,z))));\n    \n    \tHessNum3 f5 = mult(mult(mult(6.,x),y),z);\n    \tHessNum3 f6 = mult(-10.,add(add(mult(x,x),mult(y,y)),mult(z,z)));\n                           \n\t\treturn add(add(add(add(add(add(f1,f2),f3),f4),f5),f6),a_constH3(22.));\n     #elif SCENE==5\n    return\n        add(add(add(\n        mult( mult(a_sin(x),a_sin(y)\n            ), a_sin(z))\n        ,\n        mult( mult(a_sin(x),a_cos(y)\n            ), a_cos(z)))\n        ,\n        \n        mult( mult(a_cos(x),a_sin(y)\n            ), a_cos(z)))\n        ,\n        \n        mult( mult(a_cos(x),a_cos(y)\n            ), a_sin(z))\n        );\n    #else\n    \tHessNum3 noise = mult(0.4*cos(iGlobalTime\/10.),\n                              mult(\n                                  \tmult(a_cos(mult(22.,y)),\n                                   a_sin(mult(15.,y)))\n                                  , a_sin(mult(14.,z))));\n   \n    \tnoise = add(noise,mult(0.4*sin(iGlobalTime\/5.),a_cos(mult(2.,z))));\n    \treturn add(noise,sub(a_sqrt(add(add(mult(x,x),mult(y,y)),mult(z,z))),a_constH3(1.)));\n    #endif\n}\nvoid getEye(out vec3 eye, out vec3 center)\n{\n    \n    #if SCENE == 4\n    \teye = vec3(7.,4.,5.);\n    \tcenter = vec3(0.);\n    #elif SCENE == 1\n    \teye = vec3(7.,5.,3.);\n    \tcenter = vec3(0.);\n    #else\n    \teye = vec3(3.,1.,0.);\n    \tcenter = vec3(0.);\n    #endif\n    \n}\n\nfloat DE(vec3 p)\n{\n \tHessNum3 result;\n    HESSIAN3(implicit,p.x,p.y,p.z,result);\n    \n    float g2 = dot(result.g,result.g);\n    float g = sqrt(g2);\n    float v= result.val;\n    \n    \/\/ First order distance estimation\n    if(useFirstOrder)\n    {\n        if(g < eps)\n        {\n            return v;   \n        }else\n            return v\/g;\n\t}\n\telse\n    {\n        \n        \/\/ Second order uses any compatible matrix norm\n        \/\/ Default here is frobenius ->  fast and simple\n        \/\/ power method assumes the hessian to be symmetric to calculate spectral norm\n        \/\/ (should be for functions with continuous second order partials)\n    float m = calcNorm(result.h);\n    \n    \/\/ Special cases for zero values\n    if(m < eps)\n    {\n       \tif(g < eps)\n            return v;\n        \n     \treturn v\/g;\n    }\n    else if(g < eps)\n    {\n        \n     \treturn sqrt(2.*abs(v)\/m)*sign(v);   \n    }\n    \n    return (sqrt(g2\/m\/m + 2.*abs(v)\/m) - g\/m)*sign(v);\n    }\n}\n\n\nbool trace(in vec3 p, in vec3 dir, out float t, out float dist, out int steps,\n           out vec3 pos)\n{\n   \n    \n    \n    steps = 0;\n    dist = 10000.0;\n    t = 0.;\n    \n    float lastT = 0.;\n    for(int i= 0; i < maxSteps;i++)\n    {\n        pos = p+t*dir;\n     \tfloat d = DE(pos);\n        \n        \n        if(d < eps)\n        {\n            dist = 0.;\n            t = lastT;\n            return true;\n        }\n        \n        lastT = t;\n        t += d;\n        steps++;\n        if(t > 100.)\n            return false;\n    }\n    \n    return false;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iGlobalTime),1.0);\n\n\tvec2 camRes = vec2(2.,2.*iResolution.y\/iResolution.x);\n    float focal = 1.;\n    \n    useFirstOrder = isPressed(70);\n    usePowerMethod = isPressed(80);\n    vec3 eye;\n    vec3 center;\n    getEye(eye,center);\n    \/\/eye += vec3(sin(2.*pi\/10.*iGlobalTime),0.,cos(2.*pi\/10.*iGlobalTime))*0.5;\n    \/\/ Camera thanks to stb\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5\/iResolution.xy) : iMouse.xy\/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    \n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 right = cross(dir,up);\n    \n    vec3 p = eye + focal*dir - right*camRes.x\/2.0 - up*camRes.y\/2.0 + uv.x*camRes.x*right + uv.y*camRes.y*up;\n    \n    \n    vec3 rayDir = normalize(p-eye);\n    \n    vec3 LPos = vec3(2.,5.,2.);\n    LPos += vec3(0.,sin(2.*pi\/10.*iGlobalTime),0.)*1.5;\n   \tvec3 col;\n    float t;\n    int steps;\n    float d;\n    vec3 P;\n    \n    if(trace(p,rayDir,t,d,steps,P))\n    {\n        \/\/float stepv = float(steps)\/float(maxSteps);\n     \t\/\/col = vec3(min(1.,exp(-20.*stepv*stepv)));\n        col = vec3(0.8);\n    }\n    else\n    {\n        col = vec3(0.);\n    }\n    \n    HessNum3 result;\n    HESSIAN3(implicit,P.x,P.y,P.z,result);\n    \n    vec3 L = normalize(LPos - P);\n   \tcol *= max(dot(L,normalize(result.g)),0.) + 0.1;\n    \n    fragColor = vec4( col,1.);\n    \n    \n   \n}","name":"Image","description":"","type":"image"}]}}