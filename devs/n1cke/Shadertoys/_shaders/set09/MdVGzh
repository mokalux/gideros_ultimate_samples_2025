{"Shader":{"ver":"0.1","info":{"id":"MdVGzh","date":"1453805421","viewed":530,"name":"Rendering Layered Materials","username":"koiava","description":"path tracing Layered Materials","likes":23,"published":3,"flags":32,"tags":["gi","materials","pathtracing","pbr"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2016\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0\n\n\/\/ Display : average down and do gamma adjustment\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    vec3 col = vec3(0.0);\n    \n    if( iFrame>0 )\n    {\n        col = texture2D( iChannel0, uv ).xyz;\n        col \/= float(iFrame);\n        col = pow( col, vec3(0.4545) );\n    }\n    \n    \n    \/\/ color grading and vigneting\n    col = pow( col, vec3(0.8,0.85,0.9) );\n    \n    col *= 0.5 + 0.5*pow( 16.0*uv.x*uv.y*(1.0-uv.x)*(1.0-uv.y), 0.1 );\n    \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"#define PIXEL_SAMPLES \t\t1\t\t\t\/\/Increase for higher quality\n#define EYE_PATH_LENGTH\t\t4\n#define INDIRECT_CLAMP \t\t10.0\t\t\t\/\/for removing fireflies(Lower value gives more bias)\n#define DOF\n\/\/#define MOTION_BLUR\n\/\/#define DIST_GGX\n#define GAMMA \t\t\t\t2.2\t\t\t\/\/\n#define NORMAL_MAP\n\n#ifdef DOF\n#define CAMERA_LENS_RADIUS\t0.4\t\t\t\/\/Increase for DoF\n#endif\n\n#ifdef MOTION_BLUR\n#define FRAME_TIME\t\t\t0.15\t\t\/\/Increase for Motion blur\n#endif\n\/\/#define OCULUS_VERSION\t\t\t\t\/\/Enable\/Disable Fisheye lens stereo render\n\n\nconst vec3 backgroundColor = vec3( 0.0 );\nfloat frameSta = 1.0;\/\/iGlobalTime;\n#ifdef MOTION_BLUR\nfloat frameEnd = frameSta + FRAME_TIME;\n#endif\n\n\/\/used macros and constants\n#define PI \t\t\t\t\t3.1415926\n#define TWO_PI \t\t\t\t6.2831852\n#define FOUR_PI \t\t\t12.566370\n#define INV_PI \t\t\t\t0.3183099\n#define INV_TWO_PI \t\t\t0.1591549\n#define INV_FOUR_PI \t\t0.0795775\n#define EPSILON \t\t\t0.00001 \n#define EQUAL_FLT(a,b,eps)\t(((a)>((b)-(eps))) && ((a)<((b)+(eps))))\n#define IS_ZERO(a) \t\t\tEQUAL_FLT(a,0.0,EPSILON)\n\/\/********************************************\n\n\/\/ random number generator **********\n\/\/ taken from iq :)\nfloat seed;\t\/\/seed initialized in main\nfloat rnd() { return fract(sin(seed++)*43758.5453123); }\n\/\/***********************************\n\nvec3 toVec3( vec4 v ) {\n    if( IS_ZERO( v.w ) ) {\n        return v.xyz;\n    }\n    \n    return v.xyz*(1.0\/v.w);\n}\n\nvec3 sphericalToCartesian(\tin float rho,\n                          \tin float phi,\n                          \tin float theta ) {\n    float sinTheta = sin(theta);\n    return vec3( sinTheta*cos(phi), sinTheta*sin(phi), cos(theta) )*rho;\n}\n\nvoid cartesianToSpherical( \tin vec3 xyz,\n                         \tout float rho,\n                          \tout float phi,\n                          \tout float theta ) {\n    rho = sqrt((xyz.x * xyz.x) + (xyz.y * xyz.y) + (xyz.z * xyz.z));\n    phi = asin(xyz.y \/ rho);\n\ttheta = atan( xyz.z, xyz.x );\n}\n\nmat3 mat3Inverse( in mat3 m ) {\n    return mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n\t\t\t\t\tvec3( m[0][1], m[1][1], m[2][1] ),\n                    vec3( m[0][2], m[1][2], m[2][2] ) );\n}\n\n\/\/fast inverse for orthogonal matrices\nmat4 mat4Inverse( in mat4 m ) {\n    mat3 rotate_inv = mat3(\tvec3( m[0][0], m[1][0], m[2][0] ),\n                          \tvec3( m[0][1], m[1][1], m[2][1] ),\n                          \tvec3( m[0][2], m[1][2], m[2][2] ) );\n    \n    return mat4(\tvec4( rotate_inv[0], 0.0 ),\n                \tvec4( rotate_inv[1], 0.0 ),\n                \tvec4( rotate_inv[2], 0.0 ),\n              \t\tvec4( (-rotate_inv)*m[3].xyz, 1.0 ) );\n}\n    \n#define BSDF_CONDUCTOR\t\t0\n#define BSDF_DIELECTRIC\t\t1\n#define BSDF_DIFFUSE\t\t2\n    \nstruct BSDFLayer {\n    int type_;\n    float thickness_;\t\t\/\/for dielectrics only\n    float IOR_;\t\t\t\t\/\/Index Of Refrection\n    float roughness_;\t\t\/\/microfacet surface roughness\n    vec3 color_;\t\t\t\/\/\n#ifdef NORMAL_MAP\n    int normal_map_;\t\t\t\/\/\n#endif\n};\n    \n#define LAYER_COUNT_MAX\t3\nstruct LayererdMaterial {\n    BSDFLayer layers_[LAYER_COUNT_MAX];\n    int layer_count_;\n};\n    \nstruct SurfaceHitInfo {\n    vec3 position_;\n\tvec3 normal_;\n    vec3 tangent_;\n    vec2 uv_;\n    int material_id_;\n};\n    \n#define MTL_COUNT_MAX\t4\nLayererdMaterial mtlLibrary[MTL_COUNT_MAX];\n\nvoid ReadMtl( int id, out LayererdMaterial mtl ) {\n    for( int i=0; i<MTL_COUNT_MAX; i++ ) {\n        if( i == id ) {\n            mtl.layer_count_ = mtlLibrary[i].layer_count_;\n            for( int l=0; l<LAYER_COUNT_MAX; l++ ) {\n            \tmtl.layers_[l] = mtlLibrary[i].layers_[l];\n            }\n            break;\n        }\n    }\n}\n    \n#define MTL_LIGHT\t\t\t\t0\n#define MTL_METALIC_PAINT\t\t1\n#define MTL_DIFFUSE_1\t\t\t2\n\nvoid createMtl_Light( out LayererdMaterial mtl ) {\n    \/\/Varnish layer coating rough alluminm surface\n    mtl.layer_count_ = 1;\n    \n    \/\/Varnish layer\n    mtl.layers_[0].type_ = BSDF_DIFFUSE;\n    mtl.layers_[0].thickness_ = 1.0;\t\t\t\t\/\/No metter\n    mtl.layers_[0].IOR_ = 1.0; \t\t\t\t\t\t\/\/No metter\n    mtl.layers_[0].roughness_ = 0.0;\t\t\t\t\/\/No metter\n    mtl.layers_[0].color_ = vec3( 1000.0 );\n#ifdef NORMAL_MAP\n    mtl.layers_[0].normal_map_ = -1;\n#endif\n}\n\nvoid createMtl_Diffuse1( out LayererdMaterial mtl ) {\n    \/\/Varnish layer coating rough alluminm surface\n    mtl.layer_count_ = 1;\n    \n    \/\/Varnish layer\n    mtl.layers_[0].type_ = BSDF_DIFFUSE;\n    mtl.layers_[0].thickness_ = 1.0;\t\t\t\t\/\/No metter\n    mtl.layers_[0].IOR_ = 1.0; \t\t\t\t\t\t\/\/No metter\n    mtl.layers_[0].roughness_ = 0.0;\t\t\t\t\/\/No metter\n    mtl.layers_[0].color_ = vec3( 0.1, 0.2, 0.1 );\n#ifdef NORMAL_MAP\n    mtl.layers_[0].normal_map_ = -1;\n#endif\n}\n\nvoid createMtl_MetalicPaint( out LayererdMaterial mtl ) {\n    \/\/Varnish layer coating rough alluminm surface\n    mtl.layer_count_ = 2;\n    \n    \/\/Varnish layer\n    mtl.layers_[0].type_ = BSDF_DIELECTRIC;\n    mtl.layers_[0].thickness_ = 4.5;\t\/\/Varnish layer thickness 1mm.\n    mtl.layers_[0].IOR_ = 1.45; \n    mtl.layers_[0].roughness_ = 0.03;\n    mtl.layers_[0].color_ = vec3( 0.9, 0.4, 0.4 );\/\/vec3( 0.9, 0.1, 0.2 );\n#ifdef NORMAL_MAP\n    mtl.layers_[0].normal_map_ = -1;\n#endif\n    \n    \n    \/\/alluminum layer\n    mtl.layers_[1].type_ = BSDF_CONDUCTOR;\n    mtl.layers_[1].IOR_ = 1.4;\n    mtl.layers_[1].roughness_ = 0.6;\n    mtl.layers_[1].color_ = vec3( 0.3, 0.5, 0.8 )*1.0;\n#ifdef NORMAL_MAP\n    mtl.layers_[1].normal_map_ = 1;\n#endif\n}\n\nvoid initMtlLibrary() {\n    createMtl_Light( mtlLibrary[MTL_LIGHT] );\n    createMtl_MetalicPaint( mtlLibrary[MTL_METALIC_PAINT] );\n    createMtl_Diffuse1( mtlLibrary[MTL_DIFFUSE_1] );\n}\n    \n#define OBJ_PLANE\t\t0\n#define OBJ_SPHERE\t\t1\n#define OBJ_CYLINDER\t2\n#define OBJ_AABB\t\t3\n    \nstruct Object {\n    int type_;\n    int mtl_id_;\n    mat4 transform_;\n    mat4 transform_inv_;\n    \n    float params_[6];\n};\n    \nstruct Ray { vec3 origin; vec3 dir; };\nstruct Camera {\n    mat3 rotate;\n    vec3 pos;\n    float fovV;\n#ifdef DOF\n\/\/    vec3 target;\n    float lensSize;\n    float focusDist;\n#endif\n};\nstruct LightPathNode { vec3 pos_; vec3 N; vec3 L; vec3 Li; int materialId; };\n\n    \n\/\/ ************ SCENE ***************\nObject objects[6];\nCamera camera;\n\/\/***********************************\n\n\nvoid initScene() {\n    float time = iGlobalTime;\n    \n    \/\/init lights\n    float r = 0.2;\n    objects[0].type_ = OBJ_SPHERE;\n    objects[0].mtl_id_ = MTL_LIGHT;\n    objects[0].transform_[0] = vec4( 1.0, 0.0, 0.0, 0.0 );\n    objects[0].transform_[1] = vec4( 0.0, 1.0, 0.0, 0.0 );\n    objects[0].transform_[2] = vec4( 0.0, 0.0, 1.0, 0.0 );\n    objects[0].transform_[3] = vec4( 4.0, 3.0 , -2.0, 1.0 );\n    objects[0].transform_inv_ = mat4Inverse( objects[0].transform_ );\n    objects[0].params_[0] = r;\t\t\t\/\/radius\n    objects[0].params_[1] = r*r;\t\t\/\/radius squared\n    objects[0].params_[2] = r*r*4.0*PI;\t\/\/Surface area\n    \n    \n    \/\/plane 1\n    objects[1].type_ = OBJ_PLANE;\n    objects[1].mtl_id_ = MTL_DIFFUSE_1;\n    objects[1].transform_[0] = vec4( 1.0, 0.0, 0.0, 0.0 );\n    objects[1].transform_[1] = vec4( 0.0, 1.0, 0.0, 0.0 );\n    objects[1].transform_[2] = vec4( 0.0, 0.0, 1.0, 0.0 );\n    objects[1].transform_[3] = vec4( 0.0, 5.0, -10.0, 1.0 );\n    objects[1].transform_inv_ = mat4Inverse( objects[1].transform_ );\n    objects[1].params_[0] = -10.0;\t\t\t\/\/min x\n    objects[1].params_[1] = -2.0;\t\t\t\/\/min y\n    objects[1].params_[2] = 10.0;\t\t\t\/\/max x\n    objects[1].params_[3] = 4.0;\t\t\t\/\/max y\n   \n    \/\/plane 2\n    objects[2].type_ = OBJ_PLANE;\n    objects[2].mtl_id_ = MTL_DIFFUSE_1;\n    objects[2].transform_[0] = vec4( 1.0, 0.0, 0.0, 0.0 );\n    objects[2].transform_[1] = vec4( 0.0, 0.0, -1.0, 0.0 );\n    objects[2].transform_[2] = vec4( 0.0, -1.0, 0.0, 0.0 );\n    objects[2].transform_[3] = vec4( 0.0, -1.0, -4.0, 1.0 );\n    objects[2].transform_inv_ = mat4Inverse( objects[2].transform_ );\n    objects[2].params_[0] = -10.0;\t\t\t\/\/min x\n    objects[2].params_[1] = -4.0;\t\t\t\/\/min y\n    objects[2].params_[2] = 10.0;\t\t\t\/\/max x\n    objects[2].params_[3] = 2.0;\t\t\t\/\/max y\n \n    \/\/Cylinder\n    objects[3].type_ = OBJ_CYLINDER;\n    objects[3].mtl_id_ = MTL_DIFFUSE_1;\n    objects[3].transform_[0] = vec4( 0.0, 1.0, 0.0, 0.0 );\n    objects[3].transform_[1] = vec4( 0.0, 0.0, 1.0, 0.0 );\n    objects[3].transform_[2] = vec4( 1.0, 0.0, 0.0, 0.0 );\n    objects[3].transform_[3] = vec4( -0.0, 3.0, -6.0, 1.0 );\n    objects[3].transform_inv_ = mat4Inverse( objects[3].transform_ );\n    objects[3].params_[0] = 4.0;\t\t\t\/\/radius\n    objects[3].params_[1] = -10.0;\t\t\t\/\/min z\n    objects[3].params_[2] = 10.0;\t\t\t\/\/max z\n    objects[3].params_[3] = PI\/2.0;\t\t\t\/\/max phi\n    \n    \/\/sphere\n    r = 1.0;\n    objects[4].type_ = OBJ_SPHERE;\n    objects[4].mtl_id_ = MTL_METALIC_PAINT;\n    objects[4].transform_[0] = vec4( 1.0, 0.0, 0.0, 0.0 );\n    objects[4].transform_[1] = vec4( 0.0, 1.0, 0.0, 0.0 );\n    objects[4].transform_[2] = vec4( 0.0, 0.0, 1.0, 0.0 );\n    objects[4].transform_[3] = vec4( 0.0, 0.0, -3.0, 1.0 );\n    objects[4].transform_inv_ = mat4Inverse( objects[4].transform_ );\n    objects[4].params_[0] = r;\t\t\t\/\/radius\n    objects[4].params_[1] = r*r;\t\t\/\/radius squared\n    objects[4].params_[2] = r*r*4.0*PI;\t\/\/Surface area\n    \n    \/\/AABB\n    vec3 xAcis = normalize( vec3( 0.9, 0.0, 0.2 ) );\n    vec3 yAcis = vec3( 0.0, 1.0, 0.0 );\n    objects[5].type_ = OBJ_AABB;\n    objects[5].mtl_id_ = MTL_METALIC_PAINT;\n    objects[5].transform_[0] = vec4( xAcis, 0.0 );\n    objects[5].transform_[1] = vec4( yAcis, 0.0 );\n    objects[5].transform_[2] = vec4( cross(xAcis,yAcis), 0.0 );\n    objects[5].transform_[3] = vec4( 2.5, 0.0, -4.0, 1.0 );\n    objects[5].transform_inv_ = mat4Inverse( objects[5].transform_ );\n    objects[5].params_[0] = -0.8;\t\t\t\/\/min x\n    objects[5].params_[1] = -1.0;\t\t\t\/\/min y\n    objects[5].params_[2] = -0.8;\t\t\t\/\/min z\n    objects[5].params_[3] = 0.8;\t\t\t\/\/max x\n    objects[5].params_[4] = 2.0;\t\t\t\/\/max y\n    objects[5].params_[5] = 0.8;\t\t\t\/\/max z\n}\n\n\/\/ ************************  INTERSECTION FUNCTIONS **************************\nbool solveQuadratic(float A, float B, float C, out float t0, out float t1) {\n\tfloat discrim = B*B-4.0*A*C;\n    \n\tif ( discrim <= 0.0 )\n        return false;\n    \n\tfloat rootDiscrim = sqrt( discrim );\n    \n    float t_0 = (-B-rootDiscrim)\/(2.0*A);\n    float t_1 = (-B+rootDiscrim)\/(2.0*A);\n    \n    t0 = min( t_0, t_1 );\n    t1 = max( t_0, t_1 );\n    \n\treturn true;\n}\n\nfloat solveCubic(float a1, float a2, float a3) {\n\tfloat Q, R, Q3, R2, sQ, d, an, theta;\n\tfloat A2;\n\t\n\tA2 = a1 * a1;\n\n\tQ = (A2 - 3.0 * a2) * (1.\/ 9.0);\n\n\t\/* Modified to save some multiplications and to avoid a floating point\n\t   exception that occured with DJGPP and full optimization. [DB 8\/94] *\/\n\n\tR = (a1 * (A2 - 4.5 * a2) + 13.5 * a3) * (1.\/ 27.0);\n\n\tQ3 = Q * Q * Q;\n\n\tR2 = R * R;\n\n\td = Q3 - R2;\n\n\tan = a1 * (1.\/3.);\n\n\tif (d >= 0.0)\n\t{\n\t\t\/* Three real roots. *\/ \/\/but only use the first!\n\n\t\td = R * inversesqrt(Q3);\n\n\t\ttheta = acos(d) * (1. \/ 3.0);\n\n\t\tsQ = -2.0 * sqrt(Q);\n\n\t\treturn sQ * cos(theta) - an;\n\t}\n\n\tsQ = pow(sqrt(R2 - Q3) + abs(R), 1.0 \/ 3.0);\n\n\tfloat t = sQ + Q \/ sQ;\n\t\n\tt = R < 0. ? t : -t;\n\treturn t - an;\n}\n\nvoid quartic_descartes( float A, float B, float C, float D, inout vec4 results) {\n    float c1 = A;\n    float c2 = B;\n    float c3 = C;\n    float c4 = D;\n\tfloat c12, z, p, q, q1, q2, r, d1, d2;\n\t\n\t\/* Compute the cubic resolvant *\/\n\n\tc12 = c1 * c1;\n\tp =  -6. * c12 + 4.*c2;\n\tq =  c12 * c1 - c1 * c2 + c3;\n\tq *= 8.;\n\tr = -3. * c12 * c12 + c12 *4.*c2 - c1 * 8.*c3 + 4.*c4;\n\t\t\t\t\n\tfloat cubic_a1 = -0.5 * p;\n\tfloat cubic_a2 = -r;\n\tfloat cubic_a3 = 0.5 * r * p - 0.125 * q * q;\n\n\tz = solveCubic(cubic_a1, cubic_a2, cubic_a3);\n\n\td1 = 2.0 * z - p;\n\n\tif (d1 < 0.0) {\n\t\tif (d1 > -EPSILON) {\n\t\t\td1 = 0.0;\n\t\t} else {\n\t\t\treturn;\n\t\t}\n\t}\n\n\tif (d1 < EPSILON) {\n\t\td2 = z * z - r;\n\n\t\tif (d2 < 0.0) {\n\t\t\treturn;\n\t\t}\n\n\t\td2 = sqrt(d2);\n\t} else {\n\t\td1 = sqrt(d1);\n\t\td2 = 0.5 * q * (1.\/ d1);\n\t}\n\n\t\/* Set up useful values for the quadratic factors *\/\n\n\tq1 = d1 * d1;\n\tq2 = -c1;\n\n\t\/* Solve the first quadratic *\/\n\n\tp = q1 - 4.0 * (z - d2);\n\n\tif (p > 0.0) {\n\t\tp = sqrt(p);\n\t\tresults[0] = -0.5 * (d1 + p) + q2;\n\t\tresults[1] = -0.5 * (d1 - p) + q2;\n\t}\n\n\t\/* Solve the second quadratic *\/\n\n\tp = q1 - 4.0 * (z + d2);\n\n\tif (p > 0.)\n\t{\n\t\tp = sqrt(p);\n\t\tresults[2] = 0.5 * (d1 + p) + q2;\n\t\tresults[3] = 0.5 * (d1 - p) + q2;\n\t}\n}\n\nvec4 Sort( vec4 a) {\n\tvec4 m = vec4(min(a.xz,a.yw), max(a.xz,a.yw) );\n\tvec4 r = vec4(min(m.xz,m.yw), max(m.xz,m.yw) ); \n\ta = vec4( r.x, min(r.y,r.z),  max(r.y,r.z), r.w );\n\treturn a;\n}\n\nvec3 normalTorus( in vec3 pos, float R, float r )\n{\n    return normalize( pos*(dot(pos,pos)- r*r - R*R*vec3(1.0,1.0,-1.0)));\n}\n\n\/\/http:\/\/research.microsoft.com\/en-us\/um\/people\/awf\/graphics\/ray-torus.html\nbool rayTorusIntersection( in Ray ray, float R, float r, in bool forShadowTest, out float t, out SurfaceHitInfo isect) {\n    float aa = dot(ray.origin,ray.origin);\n\tfloat ab = dot(ray.origin,ray.dir);\n\n\tfloat R2 = R*R;\n\tfloat K = aa - r*r - R2;\n\tK *= 0.5;\n\tfloat A = ab;\n\tfloat B = ab*ab + K + R2*ray.dir.z*ray.dir.z;\n\tfloat C = K*ab + R2*ray.origin.z*ray.dir.z;\n\tfloat D = K*K +  R2*(ray.origin.z*ray.origin.z - r*r);\n\t\n\tvec4 roots = vec4(1e10);\n\tquartic_descartes( A, B, C, D, roots );\n\t\n    t = 1000.0;\n    \n\tfor (int i=0; i<4; i++) {\n        if ( (roots[i] > 0.0) && (roots[i]<t) ) {\n\t\t\tt = roots[i];\n        }\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalTorus( isect.position_, R, r );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.position_, rho, phi, theta );\n        isect.uv_.x = phi\/PI;\n        isect.uv_.y = theta\/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\t\n\treturn (t < 1000.0);\n}\n\nbool raySphereIntersection( in Ray ray, in float radiusSquared, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    float t0, t1;\n    vec3 L = ray.origin;\n    float a = dot( ray.dir, ray.dir );\n    float b = 2.0 * dot( ray.dir, L );\n    float c = dot( L, L ) - radiusSquared;\n    \n    if (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n    \n    if( t0 > 0.0 ) {\n    \tt = t0;\n    } else {\n        if ( t1 > 0.0 ) {\n            t = t1;\n        } else {\n            return false;\n        }\n    }\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        isect.normal_ = normalize( isect.position_ );\n\n        float rho, phi, theta;\n        cartesianToSpherical( isect.normal_, rho, phi, theta );\n        isect.uv_.x = phi\/PI;\n        isect.uv_.y = theta\/TWO_PI;\n\n        isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n        vec3 tmp = cross( isect.normal_, isect.tangent_ );\n        isect.tangent_ = normalize( cross( tmp, isect.normal_ ) );\n    }\n\t\n\treturn true;\n}\n\nbool rayAAPlaneIntersection( in Ray ray, in float min_x, in float min_y, in float max_x, in float max_y, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    if ( IS_ZERO( ray.dir.z ) )\n    \treturn false;\n    \n    t = ( -ray.origin.z ) \/ ray.dir.z;\n    \n    isect.position_ = ray.origin + ray.dir*t;\n    \n    if( (isect.position_.x < min_x) ||\n       \t(isect.position_.x > max_x) ||\n      \t(isect.position_.y < min_y) ||\n      \t(isect.position_.y > max_y) )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.uv_.x \t\t= (isect.position_.x - min_x)\/(max_x - min_x);\n        isect.uv_.y \t\t= (isect.position_.y - min_y)\/(max_y - min_y);\n        isect.normal_ \t\t= vec3( 0.0, 0.0, 1.0 );\n        isect.tangent_ \t\t= vec3( 1.0, 0.0, 0.0 );\n    }\n    \n    return true;\n}\n\nbool rayCylinderIntersection( in Ray r, in float radius, in float minZ, in float maxZ, in float maxPhi, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n\tfloat phi;\n\tvec3 phit;\n    \n\t\/\/ Compute quadratic cylinder coefficients\n\tfloat a = r.dir.x*r.dir.x + r.dir.y*r.dir.y;\n\tfloat b = 2.0 * (r.dir.x*r.origin.x + r.dir.y*r.origin.y);\n\tfloat c = r.origin.x*r.origin.x + r.origin.y*r.origin.y - radius*radius;\n \n\t\/\/ Solve quadratic equation for _t_ values\n\tfloat t0, t1;\n\tif (!solveQuadratic( a, b, c, t0, t1))\n\t\treturn false;\n\n    if ( t1 < 0.0 )\n        return false;\n    \n\tt = t0;\n    \n\tif (t0 < 0.0)\n\t\tt = t1;\n\n\t\/\/ Compute cylinder hit point and $\\phi$\n\tphit = r.origin + r.dir*t;\n\tphi = atan(phit.y,phit.x);\n    phi += PI;\n    \n\tif (phi < 0.0)\n        phi += TWO_PI;\n \n\t\/\/ Test cylinder intersection against clipping parameters\n\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) ) {\n\t\tif (t == t1)\n            return false;\n\t\tt = t1;\n\t\t\/\/ Compute cylinder hit point and $\\phi$\n\t\tphit = r.origin + r.dir*t;\n\t\tphi = atan(phit.y,phit.x);\n        phi += PI;\n\n\t\tif ( (phit.z < minZ) || (phit.z > maxZ) || (phi > maxPhi) )\n\t\t\treturn false;\n\t}\n    \n    if( !forShadowTest ) {\n        isect.position_ = phit;\n        isect.uv_.x = (phit.z - minZ)\/(maxZ - minZ);\n        isect.uv_.y = phi\/maxPhi;\n        isect.normal_ = normalize( vec3( phit.xy, 0.0 ) );\n        isect.tangent_ = vec3( 0.0, 0.0, 1.0 );\n    }\n    \n\treturn true;\n}\n\nbool rayAABBIntersection( in Ray ray, float minX, float minY, float minZ, float maxX, float maxY, float maxZ, in bool forShadowTest, out float t, out SurfaceHitInfo isect ) {\n    vec3 boxMin = vec3( minX, minY, minZ );\n    vec3 boxMax = vec3( maxX, maxY, maxZ );\n    \n    vec3 OMIN = ( boxMin - ray.origin ) \/ ray.dir;\n    vec3 OMAX = ( boxMax - ray.origin ) \/ ray.dir;\n    vec3 MAX = max ( OMAX, OMIN );\n    vec3 MIN = min ( OMAX, OMIN );\n    float t1 = min ( MAX.x, min ( MAX.y, MAX.z ) );\n    t = max ( max ( MIN.x, 0.0 ), max ( MIN.y, MIN.z ) );\n    \n    if ( t1 <= t )\n        return false;\n    \n    if( !forShadowTest ) {\n        isect.position_ = ray.origin + ray.dir*t;\n        \n        if( EQUAL_FLT( isect.position_.x, minX, EPSILON ) ) {\n            isect.normal_ =  vec3( -1.0, 0.0, 0.0 );\n            isect.tangent_ \t\t= vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)\/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)\/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.x, maxX, EPSILON ) ) {\n            isect.normal_ =  vec3( 1.0, 0.0, 0.0 );\n            isect.tangent_ = vec3( 0.0, 1.0, 0.0 );\n            isect.uv_.x = (isect.position_.z - minZ)\/(maxZ - minZ);\n    \t\tisect.uv_.y = (isect.position_.y - minY)\/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.y, minY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, -1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)\/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)\/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.y, maxY, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 1.0, 0.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)\/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.z - minZ)\/(maxZ - minZ);\n        } else if( EQUAL_FLT( isect.position_.z, minZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, -1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)\/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)\/(maxY - minY);\n        } else if( EQUAL_FLT( isect.position_.z, maxZ, EPSILON ) ) {\n            isect.normal_ =  vec3( 0.0, 0.0, 1.0 );\n            isect.tangent_ = vec3( 1.0, 0.0, 0.0 );\n            isect.uv_.x = (isect.position_.x - minX)\/(maxX - minX);\n    \t\tisect.uv_.y = (isect.position_.y - minY)\/(maxY - minY);\n        }\n        \n        isect.uv_ \/= 2.0;\n    }\n    \n    return true;\n}\n\nbool rayObjectIntersect( in Ray ray, in Object obj, in float distMin, in float distMax, in bool forShadowTest, out SurfaceHitInfo hit, out float dist ) {\n    bool hitResult = false;\n    float t;\n    SurfaceHitInfo currentHit;\n\n    \/\/Convert ray to object space\n    Ray rayLocal;\n    rayLocal.origin = toVec3( obj.transform_inv_*vec4( ray.origin, 1.0 ) );\n    rayLocal.dir \t= toVec3( obj.transform_inv_*vec4( ray.dir   , 0.0 ) );\n\n    if( obj.type_ == OBJ_PLANE ) {\n        hitResult = rayAAPlaneIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_SPHERE ) {\n        hitResult = raySphereIntersection( \trayLocal, obj.params_[1], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_CYLINDER ) {\n        hitResult = rayCylinderIntersection(rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], forShadowTest, t, currentHit );\n    } else if( obj.type_ == OBJ_AABB ) {\n        float t1;\n        hitResult = rayAABBIntersection( rayLocal, obj.params_[0], obj.params_[1], obj.params_[2], obj.params_[3], obj.params_[4], obj.params_[5], forShadowTest, t, currentHit );\n    }\n\n    if( hitResult && ( t > distMin ) && ( t < distMax ) ) {\n        \/\/Convert results to world space\n        currentHit.position_ = toVec3( obj.transform_*vec4( currentHit.position_, 1.0 ) );\n        currentHit.normal_   = toVec3( obj.transform_*vec4( currentHit.normal_  , 0.0 ) );\n        currentHit.tangent_  = toVec3( obj.transform_*vec4( currentHit.tangent_ , 0.0 ) );\n\n        dist = t;\n        hit = currentHit;\n        hit.material_id_ = obj.mtl_id_;\n\n        if( dot( ray.dir, hit.normal_ ) > 0.0 )\n            hit.normal_ *= -1.0;\n        \n        return true;\n    }\n    \n    return false;\n}\n\n#define CHECK_OBJ( obj ) { SurfaceHitInfo currentHit; float currDist; if( rayObjectIntersect( ray, obj, distMin, nearestDist, forShadowTest, currentHit, currDist ) && ( currDist < nearestDist ) ) { nearestDist = currDist; hit = currentHit; } }\nbool raySceneIntersection( in Ray ray, in float distMin, in bool forShadowTest, out SurfaceHitInfo hit, out float nearestDist ) {\n    nearestDist = 10000.0;\n    CHECK_OBJ( objects[0] );\n    CHECK_OBJ( objects[1] );\n    CHECK_OBJ( objects[2] );\n    CHECK_OBJ( objects[3] );\n    CHECK_OBJ( objects[4] );\n    CHECK_OBJ( objects[5] );\n    return ( nearestDist < 1000.0 );\n}\n\/\/ ***************************************************************************\n\n \n\/\/ Geometry functions ***********************************************************\nvec2 uniformPointWithinCircle( in float radius, in float Xi1, in float Xi2 ) {\n    float r = radius*sqrt(Xi1);\n    float theta = Xi2;\n\treturn vec2( r*cos(theta), r*sin(theta) );\n}\n\nvec3 uniformDirectionWithinCone( in vec3 d, in float phi, in float sina, in float cosa ) {    \n\tvec3 w = normalize(d);\n    vec3 u = normalize(cross(w.yzx, w));\n    vec3 v = cross(w, u);\n\treturn (u*cos(phi) + v*sin(phi)) * sina + w * cosa;\n}\n\nvec3 localToWorld( in vec3 localDir, in vec3 normal )\n{\n    vec3 binormal = normalize( ( abs(normal.x) > abs(normal.z) )?vec3( -normal.y, normal.x, 0.0 ):vec3( 0.0, -normal.z, normal.y ) );\n\tvec3 tangent = cross( binormal, normal );\n    \n\treturn localDir.x*tangent + localDir.y*binormal + localDir.z*normal;\n}\n\nvec3 sampleHemisphereCosWeighted( in vec3 n, in float Xi1, in float Xi2 ) {\n    float theta = acos(sqrt(1.0-Xi1));\n    float phi = TWO_PI * Xi2;\n\n    return localToWorld( sphericalToCartesian( 1.0, phi, theta ), n );\n}\n\nvec3 randomHemisphereDirection( const vec3 n, in float Xi1, in float Xi2 ) {\n    vec2 r = vec2(Xi1,Xi2)*TWO_PI;\n\tvec3 dr=vec3(sin(r.x)*vec2(sin(r.y),cos(r.y)),cos(r.x));\n\treturn dot(dr,n) * dr;\n}\n\nvec3 randomDirection( in float Xi1, in float Xi2 ) {\n    float theta = acos(1.0 - 2.0*Xi1);\n    float phi = TWO_PI * Xi2;\n    \n    return sphericalToCartesian( 1.0, phi, theta );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\nvoid initCamera( \tin vec3 pos,\n                \tin vec3 target,\n                \tin vec3 upDir,\n                \tin float fovV\n#ifdef DOF\n                \t, in float lensSize,\n                \tin float focusDist\n#endif\n               ) {\n\tvec3 back = normalize( pos-target );\n\tvec3 right = normalize( cross( upDir, back ) );\n\tvec3 up = cross( back, right );\n    camera.rotate[0] = right;\n    camera.rotate[1] = up;\n    camera.rotate[2] = back;\n    camera.fovV = fovV;\n    camera.pos = pos;\n#ifdef DOF\n    camera.lensSize = lensSize;\n    camera.focusDist = focusDist;\n#endif\n}\n\nRay genRay( in vec2 pixel, in float Xi1, in float Xi2 )\n{\n    Ray ray;\n    \n#ifdef OCULUS_VERSION\n    vec2 displaySize = vec2( iResolution.x*0.5, iResolution.y );\n    vec2 uv;\n    \n    if( pixel.x < displaySize.x ) {\n    \tray.origin = camera.pos - camera.rotate[0]*0.2;\n        uv = pixel\/displaySize;\n    } else {\n        ray.origin = camera.pos + camera.rotate[0]*0.2;\n        uv = vec2(pixel.x-displaySize.x,pixel.y)\/displaySize;\n    }\n    \n    uv = (uv*2.0 - 1.0)*vec2(displaySize.x\/displaySize.y,1.);\n    \n    float fov = camera.fovV;\n    float angle = fov\/4.0;\n    float a = sin(angle);\n    \n    uv *= a;\n    \n    if( length(uv) > 1.0 ) {\n        Ray ray;\n        ray.origin = vec3( 0.0, 0.0, 0.0 );\n        ray.dir = vec3( 0.0, 0.0, 0.0 );\n        return ray;\n    }\n    \n    vec3 cameraDirInv = vec3( 0.0, 0.0, 1.0 );\n    vec3 normal;\n    normal.x = -uv.x;\n    normal.y = -uv.y;\n    normal.z = sqrt( 1.0 - (uv.x*uv.x + uv.y*uv.y) );\n    \n\tray.dir = camera.rotate*reflect( cameraDirInv, normal );\n\n\treturn ray; \n#else\n\tvec2 iPlaneSize=2.*tan(0.5*camera.fovV)*vec2(iResolution.x\/iResolution.y,1.);\n\tvec2 ixy=(pixel\/iResolution.xy - 0.5)*iPlaneSize;\n\n#ifdef DOF\n    vec2 uv = uniformPointWithinCircle( camera.lensSize, rnd(), rnd() );\n    vec3 newPos = camera.pos + camera.rotate[0]*uv.x*camera.lensSize + camera.rotate[1]*uv.y*camera.lensSize;\n    vec3 focusPoint = camera.pos - camera.focusDist*camera.rotate[2];\n    vec3 newBack = normalize(newPos - focusPoint);\n    vec3 newRight = normalize( cross( camera.rotate[1], newBack ) );\n    vec3 newUp = cross( newBack, newRight );\n    mat3 newRotate;\n    newRotate[0] = newRight;\n    newRotate[1] = newUp;\n    newRotate[2] = newBack;\n\n\n    ray.origin = newPos;\n    ray.dir = newRotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n#else\n    ray.origin = camera.pos;\n    ray.dir = camera.rotate*normalize(vec3(ixy.x,ixy.y,-1.0));\n#endif\n\n\treturn ray;\n#endif\n}\n\n#ifdef DIST_GGX\n\/\/ GGX *****************************************************************************************\nfloat eval_GGX( in float dotNH, float alpha ) {\n    float cosThetaM = dotNH;\n    \n    if( cosThetaM < EPSILON )\n        return 0.0;\n    \n    float alpha2 = alpha * alpha;\n    float cosThetaM2 = cosThetaM * cosThetaM;\n    float tanThetaM2 = (1.0 - cosThetaM2) \/ cosThetaM2;\n    float cosThetaM4 = cosThetaM2 * cosThetaM2;\n    float D = alpha2 \/ ( PI * cosThetaM4 * pow( alpha2 + tanThetaM2, 2.0 ) );\n    \n    return D;\n}\n\nvec3 sample_GGX( vec3 N, float alpha, float Xi1, float Xi2 ) {\n    vec3 Z = N;\n    vec3 X = randomHemisphereDirection( N, Xi1, Xi2 );\n    vec3 Y = cross( X, Z );\n    X = cross( Z, Y );\n    \n    float alpha2 = alpha * alpha;\n    float tanThetaM2 = alpha2 * Xi1 \/ (1.0 - Xi1);\n    float cosThetaM  = 1.0 \/ sqrt(1.0 + tanThetaM2);\n    float sinThetaM  = cosThetaM * sqrt(tanThetaM2);\n    float phiM = TWO_PI * Xi2;\n    \n    return X*( cos(phiM) * sinThetaM ) + Y*( sin(phiM) * sinThetaM ) + Z*cosThetaM;\n}\n\nfloat G1_smith_GGX( in float dotNV,\n                   \tin float dotHV,\n                   \tfloat alpha ) {\n    \n    if( (dotHV\/dotNV) < EPSILON )\n        return 0.0;\n    \n\tfloat cosThetaV_2 = dotNV*dotNV;\n    float tanThetaV_2 = 1.0 - cosThetaV_2;\n    float alpha2 = alpha*alpha;\n    return 2.0 \/ ( 1.0 + sqrt( 1.0 + alpha2 * tanThetaV_2 \/ cosThetaV_2 ) );\n}\n\/\/ GGX *****************************************************************************************\n#else\n\n\/\/ Beckmann ************************************************************************************\nfloat eval_Beckmann( in float dotNH, float roughness ) {\n    float roughness_2 = roughness*roughness;\n\/\/    float dotNH = dot( N, H );\n    float dotNH_2 = dotNH * dotNH;\n    float dotNH_4 = dotNH_2 * dotNH_2;\n    return exp( ( dotNH_2 - 1.0 ) \/ ( roughness_2*dotNH_2 ) ) \/ ( PI*roughness_2*dotNH_4 );\n}\n\nvec3 sample_Beckmann( vec3 N, float roughness, float Xi1, float Xi2 ) {\n    vec3 Z = N;\n    vec3 X = randomHemisphereDirection( N, Xi1, Xi2 );\n    vec3 Y = cross( X, Z );\n    X = cross( Z, Y );\n    \n    float roughness_2 = roughness*roughness;\n    float tanThetaM = sqrt(-roughness_2 * log(1.0 - Xi1));\n    float cosThetaM = 1.0 \/ sqrt( 1.0 + tanThetaM * tanThetaM );\n    float sinThetaM = cosThetaM * tanThetaM;\n    float phiM = TWO_PI * Xi2;\n    return (cos(phiM) * sinThetaM) * X + (sin(phiM) * sinThetaM) * Y + cosThetaM  * Z;\n}\n\nfloat G1_smith_Beckmann( in float dotNV, float alpha ) {    \n    float k = alpha*0.8;\/\/sqrt(2.0\/PI);\n\treturn dotNV\/(dotNV*(1.0-k)+k);\n}\n\/\/ Beckmann ************************************************************************************\n#endif\n\n#ifdef DIST_GGX\n#define DISTRIBUTION_EVALUATE( dotNH, roughness ) eval_GGX( dotNH, roughness )\n#define DISTRIBUTION_SAMPLE( N, roughness, Xi1, Xi2 ) sample_GGX( N, roughness, Xi1, Xi2 )\n#else\n#define DISTRIBUTION_EVALUATE( dotNH, roughness ) eval_Beckmann( dotNH, roughness )\n#define DISTRIBUTION_SAMPLE( N, roughness, Xi1, Xi2 ) sample_Beckmann( N, roughness, Xi1, Xi2 )\n#endif\n\nfloat geometryTerm( in float dotNWi,\n                   \tin float dotNWo,\n                   \tin float dotHWi,\n                    in float dotHWo,\n                   \tin float roughness ) {\n#ifdef DIST_GGX\n    return G1_smith_GGX( dotNWo, dotHWo, roughness )*G1_smith_GGX( dotNWi, dotHWi, roughness );\n#else\n    return G1_smith_Beckmann( dotNWo, roughness )*G1_smith_Beckmann( dotNWi, roughness );\n#endif\n}\n\n\/* The following functions calculate the reflected and refracted \n\tdirections in addition to the fresnel coefficients. Based on \n\tPBRT and the paper \"Derivation of Refraction Formulas\" \n\tby Paul S. Heckbert. *\/\nfloat fresnelDielectric( float cosTheta1, float cosTheta2, float etaI, float etaT) {\n\tfloat Rs = (etaI * cosTheta1 - etaT * cosTheta2) \/ (etaI * cosTheta1 + etaT * cosTheta2);\n\tfloat Rp = (etaT * cosTheta1 - etaI * cosTheta2) \/ (etaT * cosTheta1 + etaI * cosTheta2);\n\n\treturn (Rs * Rs + Rp * Rp) \/ 2.0;\n}\n\nvec3 fresnelConductor( float cosTheta, vec3 eta, vec3 k ) {\n\tvec3 tmp = (eta*eta + k*k) * (cosTheta * cosTheta);\n\n\tvec3 rParl2 = \t(tmp - (eta * (2.0 * cosTheta)) + vec3(1.0)) \/\n        \t\t\t(tmp + (eta * (2.0 * cosTheta)) + vec3(1.0));\n\n\tvec3 tmpF = eta*eta + k*k;\n\n\tvec3 rPerp2 = \t(tmpF - (eta * (2.0 * cosTheta)) + vec3(cosTheta*cosTheta)) \/\n\t\t\t\t\t(tmpF + (eta * (2.0 * cosTheta)) + vec3(cosTheta*cosTheta));\n\n\treturn (rParl2 + rPerp2) \/ 2.0;\n}\n\nfloat fresnel( float cosThetaI, float etaExt, float etaInt ) {\n\tfloat etaI = etaExt;\n    float etaT = etaInt;\n\n\t\/* Swap the indices of refraction if the interaction starts\n\t   at the inside of the object *\/\n    if ( cosThetaI < 0.0 ) {\n        float tmp = etaI;\n        etaI = etaT;\n        etaT = tmp;\n    }\n\n\t\/* Using Snell's law, calculate the sine of the angle\n\t   between the transmitted ray and the surface normal *\/\n\tfloat sinThetaT = etaI \/ etaT * sqrt( max( 0.0, 1.0 - cosThetaI*cosThetaI ) );\n\n\tif ( sinThetaT > 1.0 )\n\t\treturn 1.0;  \/* Total internal reflection! *\/\n\n\tfloat cosThetaT = sqrt( 1.0 - sinThetaT*sinThetaT );\n\n\t\/* Finally compute the reflection coefficient *\/\n\treturn fresnelDielectric( abs(cosThetaI), cosThetaT, etaI, etaT);\n}\n\nvec3 BSDFLayerEvaluate( in BSDFLayer bsdfLayer,\n                       \tin float dotNWi,\n                       \tin float dotNWo,\n                       \tin float dotHWi,\n                       \tin float dotHWo,\n                       \tin float dotNH,\n                       \tin float extIOR ) {\n    float D = DISTRIBUTION_EVALUATE( dotNH, bsdfLayer.roughness_ );\n\tfloat G = geometryTerm( dotNWi, dotNWo, dotHWi, dotHWo, bsdfLayer.roughness_ );\n    vec3  F;\n    \n    if( bsdfLayer.type_ == BSDF_CONDUCTOR ) {\n        vec3 eta = vec3( extIOR \/ bsdfLayer.IOR_ );\n        vec3 k = bsdfLayer.color_;\n        F = fresnelConductor( dotHWi, eta, k );\n    } else if( bsdfLayer.type_ == BSDF_DIELECTRIC ) {\n        F = fresnel( dotHWi, bsdfLayer.IOR_, extIOR )*vec3(1.0);\n    }\n    \n\treturn (F * D * G) \/ (4.0 * dotNWi * dotNWo);\n}\n\n\/\/Generates BRDF direction \nvec3 sampleConductorBSDF (\tin BSDFLayer bsdfLayer,\n                       \tin float dotNWo,\n\t\t\t\t\t\tin vec3 N,\t\t\t\t\/\/Geometry Normal\n    \t\t\t\t\tin vec3 Wo,\t\t\t\t\/\/Eye Direction\n                      \tin float extIOR,\n    \t\t\t\t\tout vec3 Wi,\n\t\t\t\t\t\tout float pdf ) {\n    \n    \n    vec3 H = DISTRIBUTION_SAMPLE( N, bsdfLayer.roughness_, rnd(), rnd() );\n    Wi = reflect( -Wo, H );\n    float dotNWi = dot( N, Wi );\n    \n    if ( (dotNWi < 0.0) ) {\n        pdf = 0.0;\n        return vec3(0.0);\n    }\n    \n    float dotNH = dot( H, N );\n    float dotHWi = dot( H, Wi );\n    float dotHWo = dot( H, Wo );\n\n    float D = DISTRIBUTION_EVALUATE( dotNH, bsdfLayer.roughness_ );\n\tfloat G = geometryTerm( dotNWi, dotNWo, dotHWi, dotHWo, bsdfLayer.roughness_ );\n\tvec3  F = fresnelConductor( dot( Wi, H ), vec3(extIOR\/bsdfLayer.IOR_), bsdfLayer.color_ );\n    \n\tvec3 eval = (F * D * G) \/ (4.0 * dotNWi * dotNWo);\n    \n\tpdf = D * dotNH \/ (4.0 * abs(dotHWo));\n    \n    return bsdfLayer.color_*eval;\n}\n\n\n\nbool sampleDielectricBSDF( \tBSDFLayer bsdf,\n                          \tin vec3 N,\n                         \tin vec3 Wo,\n                          \tin float currentIOR,\n                         \tout vec3 WiR,\n                         \tout vec3 WiT,\n                         \tout float pdfWiR,\n                         \tout float pdfWiT ) {\n    vec3 H = DISTRIBUTION_SAMPLE( N, bsdf.roughness_, rnd(), rnd() );\n    \n    if( dot(Wo,H) < 0.0 ) {\n        pdfWiR = 0.0;\n        pdfWiT = 0.0;\n    \treturn false;\n    }\n\n    \/\/generate reflected and refrected directions\n    float eta = (currentIOR \/ bsdf.IOR_);\n    WiR = reflect ( -Wo, H );\n    WiT = refract ( -Wo, H, eta );\n    \n    float cosThetaI = dot( Wo, H );\n    \/\/ Using Snell's law, calculate the sine of the angle between the transmitted ray and the surface normal\n\tfloat sinThetaT = eta * sqrt( max( 0.0, 1.0 - cosThetaI*cosThetaI ) );\n\n    if ( sinThetaT > 1.0 ) {\n        pdfWiR = 1.0;\n    } else {\n\t\tfloat cosThetaT = sqrt( 1.0 - sinThetaT*sinThetaT );\n        pdfWiR = fresnelDielectric( abs(cosThetaI), cosThetaT, currentIOR, bsdf.IOR_ );\n\t}\n    \n    pdfWiT = 1.0 - pdfWiR;\n    \n    return true;\n}\n\n\nbool sampleDielectricBSDF1( in vec3 H,\n                         \tin vec3 Wo,\n                          \tin float extIOR,\n                           \tin float intIOR,\n                         \tout vec3 WiR,\n                         \tout vec3 WiT,\n                         \tout float pdfWiR,\n                         \tout float pdfWiT ) {\n    float eta = extIOR\/intIOR;\n    WiR = reflect ( -Wo, H );\n    WiT = refract ( -Wo, H, eta );\n    \n    float cosThetaI = dot( Wo, H );\n    \/\/ Using Snell's law, calculate the sine of the angle between the transmitted ray and the surface normal\n\tfloat sinThetaT = eta * sqrt( max( 0.0, 1.0 - cosThetaI*cosThetaI ) );\n\n    if ( sinThetaT > 1.0 ) {\n        pdfWiR = 1.0;\n    } else {\n\t\tfloat cosThetaT = sqrt( 1.0 - sinThetaT*sinThetaT );\n        pdfWiR = fresnelDielectric( abs(cosThetaI), cosThetaT, extIOR, intIOR );\n\t}\n    \n    pdfWiT = 1.0 - pdfWiR;\n    \n    return true;\n}\n\nvec4 getColorFromTexture( int tex, vec2 uv ) {\n    if( tex == 0 ) return texture2D(iChannel0, uv);\n    if( tex == 1 ) return texture2D(iChannel1, uv);\n    if( tex == 2 ) return texture2D(iChannel2, uv);\n    \n    return texture2D(iChannel3, uv);\n}\n\nvec3 normalFromTexture(vec2 uv, int tex ) {\n    uv *= 8.0;\n    vec2 du = vec2(1.0 \/ 256.0, 0.0);\n    vec2 dv = vec2(0.0, 1.0 \/ 256.0);\n    \n    float heightScale = 0.0125;\n    \n    \n    float h0 = heightScale * dot(getColorFromTexture(tex, uv), vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0));\n    float hpx = heightScale * dot(getColorFromTexture(tex, uv + du), vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0));\n    float hmx = heightScale * dot(getColorFromTexture(tex, uv - du), vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0));\n    float hpy = heightScale * dot(getColorFromTexture(tex, uv + dv), vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0));\n    float hmy = heightScale * dot(getColorFromTexture(tex, uv - dv), vec4(1.0\/3.0, 1.0\/3.0, 1.0\/3.0, 0.0));\n    \n    float dHdU = (hmx - hpx) \/ (2.0 * du.x);\n    float dHdV = (hmy - hpy) \/ (2.0 * dv.y);\n    \n    return normalize(vec3(dHdU, dHdV, 1.0));\n}\n\n#define GET_MTL_LAYER(mtl,i) ((i==0)?mtl.layers_[0]:(i==1)?mtl.layers_[1]:mtl.layers_[2])\n\nvec3 chessboard_tex( vec2 uv ) {\n    return (int( mod((uv.x+uv.y)*10.0,2.0)) == 1)? vec3(0.05) : vec3(1.0);\n}\n\nvec3 Material_Evaluate( in SurfaceHitInfo hit, in vec3 Wo, in vec3 Wi ) {\n    LayererdMaterial mtl;\n    ReadMtl( hit.material_id_, mtl );\n    vec3 result = vec3( 0.0 );\n    \n    float currentIOR = 1.0;\n    vec3 currentWi = Wi;\n    vec3 currentWo = Wo;\n    vec3 N = hit.normal_;\n    \n    vec3 currentPdf = vec3(1.0);\n    vec3 coeffTransmitWi = vec3(1.0);\n    vec3 coeffTransmitWo = vec3(1.0);\n    float dotNWi, dotNWo, dotHWi, dotHWo, dotNH;\n    \n    for( int i=0; i<LAYER_COUNT_MAX; i++ ) {\n        BSDFLayer layer = mtl.layers_[i];\n        \n        vec3 H = normalize( currentWi + currentWo );\n        dotHWi = dot( H, currentWi );\n        dotHWo = dot( H, currentWo );\n      \n#ifdef NORMAL_MAP\n        if( layer.normal_map_ != -1 ) {\n            vec3 X = hit.tangent_;\n            vec3 Y = cross( hit.normal_, hit.tangent_ );\n            vec3 Z = N;\n            \n            vec3 N1 = normalFromTexture(hit.uv_, layer.normal_map_);\n            N1 = normalize( N1.x*X + N1.y*Y + N1.z*Z );\n            \n            dotNWi = dot( N1, currentWi );\n        \tdotNWo = dot( N1, currentWo );\n        \tdotNH = dot( N1, H );\n        } else \n#endif\n        {\n            dotNWi = dot( N, currentWi );\n        \tdotNWo = dot( N, currentWo );\n        \tdotNH = dot( N, H );\n        }\n        \n        \n        if( layer.type_ == BSDF_DIFFUSE ) {\n            vec3 layerColor = chessboard_tex(hit.uv_);\/\/;texture2D(iChannel1, hit.uv_*vec2(6.0, 2.0)).rgb;\/\/layer.color_\n            vec3 brdf = layerColor*clamp( dotNWi, 0.0, 1.0 )\/PI;\n            result += currentPdf*brdf;\n            break;\n        } else if( layer.type_ == BSDF_CONDUCTOR ) {\n            vec3 brdf = BSDFLayerEvaluate( \tlayer, dotNWi, dotNWo, dotHWi, dotHWo, dotNH, currentIOR );\n            result += currentPdf*brdf;\n            break;\n        } else if( layer.type_ == BSDF_DIELECTRIC ) {\n            vec3 brdf = BSDFLayerEvaluate( \tlayer, dotNWi, dotNWo, dotHWi, dotHWo, dotNH, currentIOR );\n\n            \/\/generate transmited direction\n            vec3 WoR, WoT, WiR, WiT;\n            float coeffWoR, coeffWoT, coeffWiR, coeffWiT;\n            sampleDielectricBSDF1( H, currentWo, currentIOR, layer.IOR_, WoR, WoT, coeffWoR, coeffWoT );\n            currentWo = -WoT;\n            sampleDielectricBSDF1( H, currentWi, currentIOR, layer.IOR_, WiR, WiT, coeffWiR, coeffWiT );\n            currentWi = -WiT;\n            \n            if( (coeffWiT < EPSILON) && (coeffWoT < EPSILON) ) {\n                result += currentPdf*brdf;\n                break;\n            }\n            \n            float coeffReflect = coeffWiR+coeffWoR;\n            float coeffRefrect = coeffWoT+coeffWiT;\n            \/\/coeffReflect \/= (coeffReflect + coeffRefrect);\n            \/\/coeffRefrect \/= (coeffReflect + coeffRefrect);\n            \n            result += currentPdf*layer.color_*brdf*coeffReflect;\n            \n            currentPdf *= coeffRefrect*layer.color_*layer.thickness_;\n            currentIOR = layer.IOR_;\n        }\n    }\n    \n    return result;\n}\n\nvec3 Material_Sample( \tin SurfaceHitInfo hit,\n                     \tin vec3 Wo,                     \t\n                     \tout vec3 Wi,\n                    \tout float pdf ) {\n    pdf = 1.0;\n    LayererdMaterial mtl;\n    ReadMtl( hit.material_id_, mtl );\n    float currentIOR_ = 1.0;\n    vec3 result = vec3( 0.0 );\n    bool notDone = true;\n    vec3 currentWo = Wo;\n    vec3 currentPdf = vec3(1.0);\n    vec3 N = hit.normal_;\n    \n    int depth = 0;\n    \/\/move down\n    for( int i=0; i<LAYER_COUNT_MAX; i++ ) {\n        BSDFLayer layer = mtl.layers_[i];\n        \n        vec3 layerN;\n#ifdef NORMAL_MAP\n        if( layer.normal_map_ != -1 ) {\n            vec3 X = hit.tangent_;\n            vec3 Y = cross( hit.normal_, hit.tangent_ );\n            vec3 Z = N;\n            \n            layerN = normalFromTexture(hit.uv_, layer.normal_map_);\n            layerN = normalize( layerN.x*X + layerN.y*Y + layerN.z*Z );\n        } else\n#endif\n        {\n            layerN = N;\n        }\n        \n        if( layer.type_ == BSDF_DIFFUSE ) {\n            currentWo = sampleHemisphereCosWeighted( layerN, rnd(), rnd() );\n            \n            vec3 layerColor = chessboard_tex(hit.uv_);\/\/texture2D(iChannel1, hit.uv_*vec2(6.0, 2.0)).rgb;\/\/layer.color_\n            currentPdf *= INV_PI*layerColor;\n            currentIOR_ = layer.IOR_;\n            break;\n        } else if( layer.type_ == BSDF_DIELECTRIC ) {\n            vec3 WiR, WiT;\n            float coeffWiR, coeffWiT;\n            \n            if( !sampleDielectricBSDF( layer, layerN, currentWo, currentIOR_, WiR, WiT, coeffWiR, coeffWiT ) ) {\n                pdf = 0.0;\n                return WiR;\n            }\n            \n            \/\/imortance sample using fresnel coefficient\n            if( rnd() < coeffWiR ) {\n                currentPdf *= layer.color_;\n                currentWo = WiR;\n                currentIOR_ = layer.IOR_;\n                break;\n            }\n\n            currentPdf *= layer.color_*layer.thickness_;\n            currentWo = -WiT;\n            currentIOR_ = layer.IOR_;\n            depth++;\n\n            \/\/currentPdf = currentPdf*layer.color_*layer.thickness_;\n        } else if( layer.type_ == BSDF_CONDUCTOR ) {\n            float layerPdf;\n            vec3 WiR;\n            \n            float dotNWo = dot( layerN, currentWo );\n            vec3 eval = sampleConductorBSDF ( layer, dotNWo, layerN, currentWo, currentIOR_, WiR, layerPdf );\n            \n            currentPdf *= layerPdf*eval;\n            \n            currentWo = WiR;\n            currentIOR_ = layer.IOR_;\n            break;\n        }\n    }\n    \n\n    \/\/move up\n    for( int i=LAYER_COUNT_MAX; i>=0; i-- ) {\n        if( i >= depth  ) {\n            continue;\n        }\n\n        BSDFLayer layer = mtl.layers_[i];\n\n        \/\/Here we have only dielectric layers\n        vec3 WiR, WiT;\n        float coeffWiR, coeffWiT;\n\n        if( !sampleDielectricBSDF( layer, -N, -currentWo, currentIOR_, WiR, WiT, coeffWiR, coeffWiT ) ) {\n            currentPdf = vec3(0.0);\n            return WiR;\n        }\n\n        currentPdf *= coeffWiT*layer.color_*layer.thickness_;\n        \/\/result += eval;\n        currentWo = normalize(WiT);\n        currentIOR_ = layer.IOR_;\n    }\n    \n    Wi = currentWo;\n    pdf = 1.0;\/\/currentPdf;\n    \n    return currentPdf;\n}\n\nvoid sampleDirectLight( vec3 pos, out vec3 dir, out float pdf ) {\n    vec3 lightPos = objects[0].transform_[3].xyz;\n    float lightR2 = objects[0].params_[1];\n   \tvec3 dirToLightCenter = lightPos - pos;\n    float distToLightCenter2 = dot(dirToLightCenter, dirToLightCenter);\n    float cos_a_max = sqrt( 1.0 - clamp( lightR2 \/ distToLightCenter2, 0.0, 1.0 ) );\n    float omega = TWO_PI * (1.0 - cos_a_max);\t\/\/solid angle\n    float cosa = mix(cos_a_max, 1.0, rnd());\n    float sina = sqrt(1.0 - cosa*cosa);\n\n    dir = uniformDirectionWithinCone( dirToLightCenter, TWO_PI*rnd(), sina, cosa );\n    pdf = 1.0\/omega;\n}\n\nbool isLightVisible( Ray shadowRay ) {\n    float distToHit;\n    SurfaceHitInfo tmpHit;\n    \n    raySceneIntersection( shadowRay, EPSILON, true, tmpHit, distToHit );\n    \n    return ( tmpHit.material_id_ == MTL_LIGHT );\n}\n\n\n\nvec3 Radiance( in Ray ray, float Xi ) {\n    vec3 Li = mtlLibrary[MTL_LIGHT].layers_[0].color_;\n    vec3 color = vec3( 0.0 );\n    Ray currentRay = ray;\n    vec3 weight = vec3( 1.0 );\n    \n    \n    for( int i=0; i<EYE_PATH_LENGTH; i++ ) {\n        vec3 Wo = currentRay.dir*(-1.0);\n        SurfaceHitInfo hit;\n        float dist = 1000.0;\n        \n        if( raySceneIntersection( currentRay, 0.0, false, hit, dist ) ) {\n            LayererdMaterial surfMtl;\n            ReadMtl( hit.material_id_, surfMtl );\n            \n            if( hit.material_id_ == MTL_LIGHT ) {\n                color += (i==0)?Li:vec3(0.0);\n                break;\n            } else {\n    \t\t\tvec3 Lo = vec3( 0.0 );\n    \t\t\tvec3 Wi;\n    \t\t\tfloat pdfWi;\n    \t\t\tsampleDirectLight( hit.position_, Wi, pdfWi );\n                float dotNWi = dot( Wi, hit.normal_ );\n    \n    \t\t\tif ( (pdfWi > EPSILON) && (dotNWi > 0.0) ) {\n        \t\t\tif ( isLightVisible( Ray( hit.position_ + hit.normal_*EPSILON, Wi ) ) ) {\n            \t\t\tfloat brdf_pdf;\n            \n           \t\t\t\tvec3 brdf = Material_Evaluate( hit, Wo, Wi );\n            \n    \t\t\t\t\tcolor += weight*(Li*brdf*abs(dotNWi))\/pdfWi;\n        \t\t\t}\n    \t\t\t}\n            }\n            \n            vec3 eval;\n            float pdfWi = 1.0;\n            vec3 Wi;\n            eval = Material_Sample( hit, Wo, Wi, pdfWi );\n            \n            if( pdfWi < EPSILON ) {\n                break;\n            }\n            \n            \/\/Calculate weight for indirect subpath\n            weight *= (eval\/pdfWi);\n\n            \/\/move to next segment\n            currentRay.origin = hit.position_ + hit.normal_*EPSILON;\n            currentRay.dir = Wi;\n        } else {\n            \/\/color += weight*textureCube( iChannel3, currentRay.dir ).rgb;\n            break;\n        }\n    }\n        \n    return color;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    seed = iGlobalTime + iResolution.y * fragCoord.x \/ iResolution.x + fragCoord.y \/ iResolution.y;\n \n#ifdef OCULUS_VERSION\n\tfloat fov = radians(110.0);\n#else\n    float fov = radians(45.0);\n#endif\n    float cameraPhi = ((iMouse.x==0.0)? 0.5 :(iMouse.x \/ iResolution.x)) * PI;\n    float cameraTheta = ((iMouse.y==0.0)? 0.5 :(iMouse.y \/ iResolution.y)) * PI;\n    vec3 camDir = sphericalToCartesian(\t1.0, cameraPhi, cameraTheta );\n    float cameraDist = 6.0;\n    vec3 cameraTarget = vec3( 0.7, 0.0, -3.0 );\n    \n    initCamera( cameraTarget + camDir.xzy*cameraDist,\n               \tcameraTarget,\n               \tvec3( 0.0, 1.0, 0.0 ),\n               \tfov\n#ifdef DOF\n               \t, CAMERA_LENS_RADIUS, cameraDist\n#endif\n              \t);\n    initMtlLibrary();\n    initScene();\n    \n\tvec3 accumulatedColor = vec3( 0.0 );\n    float oneOverSPP = 1.0\/float(PIXEL_SAMPLES);\n    float strataSize = oneOverSPP;\n    Ray ray;\n    \n\tfor( int si=0; si<PIXEL_SAMPLES; ++si ){\n        vec2 screenCoord = fragCoord.xy + vec2( strataSize*( float(si) + rnd() ), rnd() );\n        ray = genRay( screenCoord, rnd(), rnd() );\n        \n        if( length( ray.dir ) < 0.2 ) {\n            accumulatedColor = vec3( 0.0 );\n        } else {\n        \taccumulatedColor += Radiance( ray, strataSize*( float(si) + rnd() ) );\n        }\n\t}\n\t\n\t\/\/devide to sample count\n\taccumulatedColor = accumulatedColor*oneOverSPP;\n    \n\t\n\tvec3 col = texture2D( iChannel0, fragCoord\/iResolution.xy ).xyz;\n    if( iFrame==0 ) col = vec3(0.0);\n    if( iMouse.z > 0.0 ) col = accumulatedColor;\n    col += accumulatedColor;\n\n    fragColor = vec4( col, 1.0 );\n}","name":"Buf A","description":"","type":"buffer"}]}}