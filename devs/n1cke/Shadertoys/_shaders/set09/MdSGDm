{"Shader":{"ver":"0.1","info":{"id":"MdSGDm","date":"1389235247","viewed":3983,"name":"Analytical Motionblur 2D","username":"iq","description":"Analytic motion blur. A disk is checked for intersection while moving linearly. The resulting equation is a quadratic that can be solved to compute the time coverage of the swept disk over the pixel over the aperture of the camera (a full frame at 24 hz)","likes":100,"published":3,"flags":0,"tags":["2d","blur","motionblur","motion","analytic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Created by inigo quilez - iq\/2014\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/ Analytic motion blur, for 2D spheres (disks).\n\/\/\n\/\/ (Linearly) Moving Disk - pixel\/ray overlap test. The resulting equation is a quadratic \n\/\/ that can be solved to compute time coverage of the swept disk behind the pixel over the\n\/\/ aperture of the camera (a full frame at 24 hz in this test).\n\n\n\n\/\/ draw a disk with motion blur\nvec3 diskWithMotionBlur( vec3 col, in vec2 uv, in vec3 sph, in vec2 cd, in vec3 sphcol )\n{\n\tvec2 xc = uv - sph.xy;\n\tfloat a = dot(cd,cd);\n\tfloat b = dot(cd,xc);\n\tfloat c = dot(xc,xc) - sph.z*sph.z;\n\tfloat h = b*b - a*c;\n\tif( h>0.0 )\n\t{\n\t\th = sqrt( h );\n\t\t\n\t\tfloat ta = max( 0.0, (-b - h)\/a );\n\t\tfloat tb = min( 1.0, (-b + h)\/a );\n\t\t\n\t\tif( ta < tb ) \/\/ we can comment this conditional, in fact\n\t\t    col = mix( col, sphcol, clamp(2.0*(tb-ta),0.0,1.0) );\n\t}\n\n\treturn col;\n}\n\n\nvec3 hash3( float n ) { return fract(sin(vec3(n,n+1.0,n+2.0))*43758.5453123); }\nvec4 hash4( float n ) { return fract(sin(vec4(n,n+1.0,n+2.0,n+3.0))*43758.5453123); }\n\nconst float speed = 8.0;\nvec2 getPosition( float time, vec4 id ) { return vec2(       0.9*sin((speed*(0.75+0.5*id.z))*time+20.0*id.x),        0.75*cos(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\nvec2 getVelocity( float time, vec4 id ) { return vec2( speed*0.9*cos((speed*(0.75+0.5*id.z))*time+20.0*id.x), -speed*0.75*sin(speed*(0.75+0.5*id.w)*time+20.0*id.y) ); }\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0*fragCoord.xy-iResolution.xy) \/ iResolution.y;\n\t\n\tvec3 col = vec3(0.2) + 0.05*p.y;\n\t\n\tfor( int i=0; i<16; i++ )\n\t{\t\t\n\t\tvec4 off = hash4( float(i)*13.13 );\n        vec3 sph = vec3( getPosition( iGlobalTime, off ), 0.02+0.1*off.x );\n        vec2 cd = getVelocity( iGlobalTime, off ) \/24.0 ;\n\t\tvec3 sphcol = 0.7 + 0.3*sin( 3.0*off.z + vec3(4.0,0.0,2.0) );\n\t\t\n        col = diskWithMotionBlur( col, p, sph, cd, sphcol );\n\t}\t\t\n\n    col += (1.0\/255.0)*hash3(p.x+13.0*p.y);\n\n\tfragColor = vec4(col,1.0);\n}","name":"","description":"","type":"image"}]}}