{"Shader":{"ver":"0.1","info":{"id":"MdcSzj","date":"1460215832","viewed":352,"name":"Blockscape","username":"finalman","description":"Cubey!","likes":11,"published":3,"flags":0,"tags":["distancefield"],"hasliked":0},"renderpass":[{"inputs":[{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"const int MAX_STEPS = 200;\n\nvec2 getHex(vec2 pos)\n{\n    return floor(pos + 0.5);\n}\n\nfloat getHexHeight(vec2 hex)\n{\n    return (mix(texture2D(iChannel0, hex \/ 256.0, -100.0).x * 10.0, 4.5, \n                1.5 * pow(sin(hex.x * 0.133 + hex.y * 0.7 - iGlobalTime * 0.1), 2.0)) - 9.0) * 0.35;\n}\n\nfloat getPlaneDist(vec3 point, vec3 normal, vec3 sample)\n{\n    return dot(sample - point, normal);\n}\n\nfloat getHexDist(vec2 hex, vec3 sample)\n{\n    float result = sample.y - getHexHeight(hex);\n    \n    result = max(result, getPlaneDist(vec3(hex.x + 0.48, 0.0, hex.y), vec3( 1.0, 0.0,  0.0), sample));\n    result = max(result, getPlaneDist(vec3(hex.x - 0.48, 0.0, hex.y), vec3(-1.0, 0.0,  0.0), sample));\n    result = max(result, getPlaneDist(vec3(hex.x, 0.0, hex.y + 0.48), vec3( 0.0, 0.0,  1.0), sample));\n    result = max(result, getPlaneDist(vec3(hex.x, 0.0, hex.y - 0.48), vec3( 0.0, 0.0, -1.0), sample));\n    \n    return result;\n}\n\nfloat dfDist(vec3 sample)\n{\n    sample.xz *= mat2(sin(1.), cos(1.), -sin(1.), cos(1.));\n    \n    float result = 1000.0;\n    \n    vec2 centerHex = getHex(sample.xz);\n    \n    for (int x = -1; x <= 1; x++)\n    {\n        for (int y = -1; y <= 1; y++)\n        {\n            vec2 hex = centerHex + vec2(x, y);\n            result = min(result, getHexDist(hex, sample));\n            result = min(result, getHexDist(hex, sample * vec3(1.0, -1.0, 1.0)));\n        }\n    }\n    \n    \n    return result;\n}\n\nvec3 dfNormal(vec3 sample)\n{\n    const float E = 0.02;\n    \n    float d0 = dfDist(sample);\n    float dX = dfDist(sample + vec3(E, 0, 0));\n    float dY = dfDist(sample + vec3(0, E, 0));\n    float dZ = dfDist(sample + vec3(0, 0, E));\n    \n    return normalize(vec3(dX - d0, dY - d0, dZ - d0));\n}\n\nfloat dfOcclusion(vec3 sample, vec3 normal)\n{\n    float N = 0.3;\n    return clamp(dfDist(sample + normal * N) \/ N, 0.0, 1.0);\n}\n\nfloat trace(inout vec3 pos, vec3 dir, out vec3 normal)\n{\n    int steps = 0;\n    for (int i = 0; i < MAX_STEPS; i++)\n    {\n        steps++;\n        float d = dfDist(pos);\n        pos += d * dir * 0.75;\n        \n        if (d < 0.001)\n        {\n            break;\n        }\n    }\n    \n    normal = dfNormal(pos);\n    return float(steps) \/ float(MAX_STEPS);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec3 origin = vec3(0.2, 0.0, iGlobalTime);\n    vec3 pos = origin;\n    vec3 dir = normalize(vec3((fragCoord.x - iResolution.x * 0.5) \/ iResolution.y,\n                              fragCoord.y \/ iResolution.y - 0.7,\n                              1.0));\n\tvec3 normal;\n    \n    float steps = trace(pos, dir, normal);\n    float occ = dfOcclusion(pos, normal);\n    float fogAmt = 1.0 - exp(-distance(origin, pos) * 0.01);\n    vec3 fogCol = vec3(0.2, 0.14, 0.18);\n    \n    vec3 diffuse = vec3(0.4, 0.5, 0.6) * clamp(dot(normal, normalize(vec3(1.0, 1.3, -1.0))), 0.0, 1.0);\n    vec3 ambient = vec3(0.4, 0.2, 0.1);\n    vec3 color = (ambient * occ + diffuse) * 4.0 \/ abs(pos.y * pos.y * pos.y);\n    \n    color = mix(color, fogCol, fogAmt);\n    color = (1.0 - exp(-color));\n\tfragColor = vec4(color, 1.0);}\n","name":"Image","description":"","type":"image"}]}}