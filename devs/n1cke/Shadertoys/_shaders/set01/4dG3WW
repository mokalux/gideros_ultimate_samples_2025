{"Shader":{"ver":"0.1","info":{"id":"4dG3WW","date":"1454382999","viewed":415,"name":"Parametric Surface Plotter","username":"elias","description":"Couldn't find one through the search so I thought I'd give it a go.\nYou can input your own equation in Buf A and tweak some parameters.","likes":11,"published":3,"flags":48,"tags":["surface","plotter","parametric"],"hasliked":0},"renderpass":[{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\n    BufA = Rendering & Equation definition\n    BufB = Evaluation Cache\n    BufC = Font Display\n\n*\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame < 2 || texture2D(iChannel3,vec2(32.5\/256.,0.)).x > 0.0)\n    {\n\t\tfragColor = texture2D(iChannel1, fragCoord.xy\/iResolution.xy);\n    }\n    else\n    {\n        float res = texture2D(iChannel0, vec2(0.5)\/iResolution.xy).x;\n        fragColor = texture2D(iChannel0, fragCoord.xy\/iResolution.xy*res);\n\t}\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"#define RESOLUTION 0.5\n#define STEPS 10.\n\n\/\/#define CROSSEYE 0.2\n#define ORTHOGONAL\n#define SURFACE\n#define MESH vec4(vec3(0),0.01)\n\n#define U_MIN 0.0\n#define U_MAX TAU\n\n#define V_MIN 0.0\n#define V_MAX TAU\n\n#define PI  3.14159\n#define TAU 6.28318\n#define T iGlobalTime\n\n\/\/ Your equation here\n\/\/ Compile:  Alt + \u00e2\u2020\u00b5\n\/\/ Evaluate: Alt + \u00e2\u2020\u201c (time reset) or spacebar when shader has focus\n\nvec3 fn(float u, float v)\n{\n    \/\/ Torus:  return vec3(cos(u)*(1.-cos(v)*0.5),sin(v)*0.5,sin(u)*(1.-cos(v)*0.5));\n    \/\/ Sphere: return vec3(sin(u)*cos(v),sin(v),cos(u)*cos(v) );\n    \/\/ Cone:   return vec3(sin(u),1,cos(u))*sin(v);\n\t\/\/ Plane:  return vec3(u-PI,1,v-PI)*0.5;\n    \/\/ Vase:   return vec3(cos(u),(v-PI)\/TAU*3.,sin(u))*vec2((1.-cos(v-PI*1.5)*0.5)*step(0.01,v),1).xyx*0.7;\n    \n    \/\/ Klein Bottle Equation (from https:\/\/de.wikipedia.org\/wiki\/Kleinsche_Flasche#Beschreibung_im_3-dimensionalen_Raum)\n    \n    float r = 2.0-cos(u);\n\n    return vec3(\n        2.0*(1.0-sin(u))*cos(u)+r*cos(v)*(2.0*exp(-pow(u\/2.0-PI,2.0))-1.0),\n        r*sin(v),\n        6.0*sin(u) + 0.5*r*sin(u)*cos(v)*exp(-pow(u-3.0*PI\/2.0,2.0))\n    ).xzy*0.2;\n}\n\n\/* -------------------------------------------------------------------------------------------------------- *\/\n\n\nstruct Ray { vec3 o, d; };\nstruct Hit { vec3 p, n; float t; int id; };\nstruct Camera { vec3 p, t; };\n    \nCamera _cam;\nHit _miss;\n\nconst float _s = 1.\/STEPS;\n\nmat2 rot(float a)\n{\n    float c=cos(a),s=sin(a);\n    return mat2(c,-s,s,c);\n}\n\nbool isNan(float val)\n{\n    return (val <= 0.0 || 0.0 <= val) ? false : true;\n}\n\n\/\/ Can probably be simpilfied a lot\nHit line(Ray r, vec3 pa, vec3 pb, float sr, int id)\n{\n    vec3 ab = pb-pa;\n    vec3 oa = pa-r.o;\n    \n    float dabrd = dot(ab,r.d);\n    float drdrd = dot(r.d,r.d);\n    \n    float det = dot(ab,ab)*drdrd-dot(ab,r.d)*dabrd;\n    if (det == 0.) { return _miss; }\n\n\tvec3 sp = pa+ab*clamp((dot(oa,r.d)*dabrd-dot(oa,ab)*drdrd)\/det,0.,1.);\n\n    r.o -= sp;\n\n    float a = drdrd;\n    float b = 2.0*dot(r.o,r.d);\n    float c = dot(r.o,r.o)-sr*sr;\n    float d = pow(b,2.0)-4.0*a*c;\n\n    if (d < 0.0) { return _miss; }\n    \n    float s = sqrt(d);\n    float t = min(-b+s,-b-s)\/(2.*a);\n\n    vec3 p = vec3(0);\/\/r.o+sp+r.d*t;\n\tvec3 n = vec3(0);\/\/normalize(p-sp);\n    \n    return Hit(vec3(0), vec3(0), t, id);\n}\n\nHit triangle(Ray r, vec3 a, vec3 b, vec3 c, int id)\n{\n\tvec3 ab = b-a, bc = c-b, ac = c-a;\n\tvec3 n = cross(ab,ac);\n\n\tfloat nrd = dot(n,r.d);\n    if (abs(nrd) < 0.001 || isNan(nrd) == true) { return _miss; }\n\n\tfloat t = -dot(n,r.o-a)\/nrd;\n    if (t < 0.0) { return _miss; }\n\n\tvec3 p = r.o+r.d*t;\n\n    if (dot(n,cross( ab,p-a)) < 0.0) { return _miss; }\n    if (dot(n,cross( bc,p-b)) < 0.0) { return _miss; }\n    if (dot(n,cross(-ac,p-c)) < 0.0) { return _miss; }\n\n\treturn Hit(b+bc\/2.,vec3(sign(nrd)),t,id);\n}\n\nfloat compare(inout Hit a, Hit b)\n{\n    if (a.t < 0.0 || b.t > 0.0 && b.t < a.t)\n    {\n        a = b;\n        return 1.0;\n    }\n\treturn 0.0;\n}\n\nHit trace(Ray r)\n{\n    Hit h = _miss;\n\n    for(float u = 0.; u < 1.0; u += _s)\n    {          \n        for(float v = 0.; v < 1.0; v += _s)\n        {\n            vec3 a = texture2D(iChannel0, vec2(u   ,v   )).xyz;\n            vec3 b = texture2D(iChannel0, vec2(u   ,v+_s)).xyz;\n            vec3 c = texture2D(iChannel0, vec2(u+_s,v   )).xyz;\n\n            #ifdef MESH\n            \n            \tcompare(h,line(r,a,b,MESH.w,0));\n            \tcompare(h,line(r,a,c,MESH.w,0));\n            \n            #endif\n\n            #ifdef SURFACE\n                \n                vec3 d = texture2D(iChannel0, vec2(u+_s,v+_s)).xyz;\n            \n                float comp = max(\n                    compare(h,triangle(r,a,b,c,1)),\n                    compare(h,triangle(r,d,c,b,1))\n                );\n\n                if (comp > 0.0)\n                {\n                    h.n = normalize(cross(a-b,d-b))*h.n.x;\n                }\n\n            #endif\n        }\n    }\n\n    return h;\n}\n\nRay lookAt(Camera cam, vec2 uv)\n{\n    vec3 d = normalize(cam.t-cam.p);\n    vec3 r = normalize(cross(d,vec3(0,1,0)));\n    vec3 u = cross(r,d);\n\t\n    #ifndef ORTHOGONAL\n    return Ray(cam.p,normalize(r*uv.x + u*uv.y + d));\n    #else\n    return Ray(cam.p+(r*uv.x + u*uv.y)*2.0, d);\n    #endif\n}\n\nvec3 getColor(Hit h)\n{\n    if(h.t <= 0.0) { return vec3(0.3); }\n    #ifdef MESH\n    if(h.id == 0) { return MESH.rgb; }\n    #endif\n    \n    \/\/float diff = max(dot(normalize(_cam.p-h.p),h.n),0.5);\n    \/\/float spec = pow(max(dot(reflect(normalize(h.p-_cam.p),h.n),normalize(_cam.p-h.p)),0.0),100.);\n    \n    return normalize(h.n+1.0);\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord.xy\/iResolution.xy;\n    \n    if (iFrame < 2 || texture2D(iChannel3,vec2(32.5\/256.,0.)).x > 0.0)\n    {\n         uv = vec2(U_MIN,V_MIN)+uv*vec2(U_MAX-U_MIN,V_MAX-V_MIN);\n         fragColor = vec4(fn(uv.x,uv.y),1);\n         return;\n    }\n    \n    if (fragCoord.x < 1.0 && fragCoord.y < 1.0)\n    {\n        fragColor.x = RESOLUTION;\n        return;\n    }\n    \n    if (uv.x > RESOLUTION || uv.y > RESOLUTION) { discard; }\n    \n\t_cam = Camera(vec3(0,0,-2.5), vec3(0));\n\t_miss = Hit(vec3(0),vec3(0),-1e10, 0);\n    \n    uv = (2.0*fragCoord.xy\/RESOLUTION-iResolution.xy)\/iResolution.yy;\n    vec2 uvm = (2.0*iMouse.xy-iResolution.xy)\/iResolution.xy;\n    \n    if (iMouse.y < 10. && iMouse.x < 10.)\n    {\n        uvm.x = T*0.1+PI\/2.1;\n        uvm.y = 0.4;\n    }\n    \n    float f = 1.-length((2.0*fragCoord.xy\/RESOLUTION-iResolution.xy)\/iResolution.xy)*0.25;\n\n\t#ifdef CROSSEYE\n    _cam.p.x += sign(uv.x)*CROSSEYE;\n    uv.x = mod(uv.x,1.5)-1.5\/2.;\n    f *= max(sign(length(uv-vec2(0,0.8))-0.04),0.0);\n    #endif\n    \n    _cam.p.yz *= rot(uvm.y*PI\/2.);\n    _cam.p.xz *= rot(uvm.x*TAU);\n    \n    fragColor = vec4(getColor(trace(lookAt(_cam,uv))),1)*f;\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"void mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    if (iFrame < 2 || texture2D(iChannel3,vec2(32.5\/256.,0.)).x > 0.0)\n    {\n\t\tfragColor = texture2D(iChannel0,fragCoord.xy\/iResolution.xy);\n    }\n    else\n    {\n\t\tdiscard;\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":259,"channel":0}],"code":"\/* ======================= *\/\n\/* ====== Font Code ====== *\/\n\/* ======================= *\/\n\n\/\/ Bit Packed Sprites by Flyguy\n\/\/ https:\/\/www.shadertoy.com\/view\/XtsGRl\n\n#define CHAR_SIZE vec2(3, 7)\n#define CHAR_SPACING vec2(4, 8)\n\n#define STRWIDTH(c) (c * CHAR_SPACING.x)\n#define STRHEIGHT(c) (c * CHAR_SPACING.y)\n\n\/*\nTop left pixel is the most significant bit.\nBottom right pixel is the least significant bit.\n\n \u00e2\u2013\u02c6     010    \n\u00e2\u2013\u02c6 \u00e2\u2013\u02c6    101    \n\u00e2\u2013\u02c6 \u00e2\u2013\u02c6    101    \n\u00e2\u2013\u02c6\u00e2\u2013\u02c6\u00e2\u2013\u02c6 -> 111 -> 010 101 101 111 101 101 101 -> 712557\n\u00e2\u2013\u02c6 \u00e2\u2013\u02c6    101    \n\u00e2\u2013\u02c6 \u00e2\u2013\u02c6    101    \n\u00e2\u2013\u02c6 \u00e2\u2013\u02c6    101    \n*\/\n\n\/\/Automatically generated from a sprite sheet.\nfloat ch_sp = 0.0;\nfloat ch_a = 712557.0;\nfloat ch_b = 1760622.0;\nfloat ch_c = 706858.0;\nfloat ch_d = 1760110.0;\nfloat ch_e = 2018607.0;\nfloat ch_f = 2018596.0;\nfloat ch_g = 707050.0;\/\/706922.0;\nfloat ch_h = 1498989.0;\nfloat ch_i = 1909911.0;\nfloat ch_j = 1872746.0;\nfloat ch_k = 1498477.0;\nfloat ch_l = 1198375.0;\nfloat ch_m = 1571693.0;\nfloat ch_n = 1760109.0;\nfloat ch_o = 711530.0;\nfloat ch_p = 711972.0;\nfloat ch_q = 711675.0;\nfloat ch_r = 1760621.0;\nfloat ch_s = 2018927.0;\nfloat ch_t = 1909906.0;\nfloat ch_u = 1497963.0;\nfloat ch_v = 1497938.0;\nfloat ch_w = 1498109.0;\nfloat ch_x = 1496429.0;\nfloat ch_y = 1496210.0;\nfloat ch_z = 2004271.0;\nfloat ch_1 = 730263.0;\nfloat ch_2 = 693543.0;\nfloat ch_3 = 693354.0;\nfloat ch_4 = 1496649.0;\nfloat ch_5 = 1985614.0;\nfloat ch_6 = 707946.0;\nfloat ch_7 = 1873042.0;\nfloat ch_8 = 709994.0;\nfloat ch_9 = 710250.0;\nfloat ch_0 = 711530.0;\nfloat ch_per = 2.0;\nfloat ch_que = 693378.0;\nfloat ch_exc = 599170.0;\nfloat ch_com = 10.0;\nfloat ch_scl = 65556.0;\nfloat ch_col = 65552.0;\nfloat ch_usc = 7.0;\nfloat ch_crs = 11904.0;\nfloat ch_dsh = 3584.0;\nfloat ch_ast = 21824.0;\nfloat ch_fsl = 304292.0;\nfloat ch_bsl = 1189001.0;\nfloat ch_lpr = 346385.0;\nfloat ch_rpr = 1118804.0;\nfloat ch_lba = 862355.0;\nfloat ch_rpa = 1647254.0;\n\nvec2 res = iResolution.xy \/ 4.0;\nvec2 print_pos = vec2(2,2);\n\n\/\/Extracts bit b from the given number.\nfloat extract_bit(float n, float b)\n{\n\treturn floor(mod(floor(n \/ pow(2.0,floor(b))),2.0));   \n}\n\n\/\/Returns the pixel at uv in the given bit-packed sprite.\nfloat sprite(float spr, vec2 size, vec2 uv)\n{\n    uv = floor(uv);\n    \/\/Calculate the bit to extract (x + y * width) (flipped on x-axis)\n    float bit = (size.x-uv.x-1.0) + uv.y * size.x;\n    \n    \/\/Clipping bound to remove garbage outside the sprite's boundaries.\n    bool bounds = all(greaterThanEqual(uv,vec2(0)));\n    bounds = bounds && all(lessThan(uv,size));\n    \n    return bounds ? extract_bit(spr, bit) : 0.0;\n\n}\n\n\/\/Prints a character and moves the print position forward by 1 character width.\nfloat char(float ch, vec2 uv)\n{\n    float px = sprite(ch, CHAR_SIZE, uv - print_pos);\n    print_pos.x += CHAR_SPACING.x;\n    return px;\n}\n\n\/\/Returns the digit sprite for the given number.\nfloat get_digit(float d)\n{\n    d = floor(d);\n    \n    if(d == 0.0) return ch_0;\n    if(d == 1.0) return ch_1;\n    if(d == 2.0) return ch_2;\n    if(d == 3.0) return ch_3;\n    if(d == 4.0) return ch_4;\n    if(d == 5.0) return ch_5;\n    if(d == 6.0) return ch_6;\n    if(d == 7.0) return ch_7;\n    if(d == 8.0) return ch_8;\n    if(d == 9.0) return ch_9;\n    return 0.0;\n}\n\n\/\/Prints out the given number starting at pos.\nfloat print_number(float number,vec2 pos, vec2 uv)\n{\n\tvec2 dec_pos = pos;\n    float result = 0.0;\n    \n\tfor(int i = 3;i >= 0;i--)\n    {\n        float clip = float(abs(number) > pow(10.0, float(i)) || i == 0); \/\/Clip off leading zeros.\n        \n        float digit = mod(number \/ pow(10.0, float(i)),10.0);\n        \n        result += sprite(get_digit(digit),CHAR_SIZE, uv - dec_pos) * clip;\n        \n        dec_pos.x += CHAR_SPACING.x * clip;\n    }\n    \n    return result;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    if (iFrame > 2) { discard; }\n        \n\tvec2 uv = fragCoord.xy \/ 4.0;\n    uv =  floor(uv);\n    \n    float d = 0.0;\n    \n    print_pos = vec2(res.x\/2.0 - STRWIDTH(13.0)\/2.0,res.y\/2.0 - STRHEIGHT(1.0)\/2.0);\n    print_pos = floor(print_pos);\n       \n    d += char(ch_e,uv);\n    d += char(ch_v,uv);\n    d += char(ch_a,uv);\n    d += char(ch_l,uv);\n    d += char(ch_u,uv);\n    d += char(ch_l,uv);\n    d += char(ch_a,uv);\n    d += char(ch_t,uv);\n    d += char(ch_i,uv);\n    d += char(ch_n,uv);\n    d += char(ch_g,uv);\n    d += char(ch_per,uv);\n    d += char(ch_per,uv);\n    \n\tfragColor = vec4(vec3(d), 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}}