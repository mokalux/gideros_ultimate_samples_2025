{"Shader":{"ver":"0.1","info":{"id":"4dGGz1","date":"1453196090","viewed":398,"name":"Fourier Gabor noise","username":"FabriceNeyret2","description":"Draw your spectrum profile in BufA.   Space to tune display mode (click left or right window)\n\napplication of https:\/\/www.shadertoy.com\/view\/4s3GDs","likes":6,"published":3,"flags":48,"tags":["fft","fourier","gabor"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ application of https:\/\/www.shadertoy.com\/view\/4s3GDs\n\n\/\/ set you module and phase in Buf A\n\n#define SIZE (iResolution.x\/2.-30.) \/\/Size must be changed in each tab.\n\n\/\/Display modes.     Tuned by pressing SPACE after clicking left or right window\n#define MAGNITUDE 0.\n#define PHASE     1.\n#define COMPONENT 2.\n#define REAL      3.\n#define IMAG      4.\n\n\/\/Scaling\n#define LOG 0\n#define LINEAR 1\n\n#define MAG_SCALE LINEAR\n\nvec2 R = iResolution.xy;\n\nvec4 rainbow(float x)  { return .5 + .5 * cos(6.2832*(x - vec4(0,1,2,0)\/3.)); }\nvec4 rainbow(vec2 C)   { return rainbow(atan(C.y,C.x)\/3.1416 + .5); }\n\nvec4 paintDFT(vec2 F, float mode) {\n    \/\/ F \/= SIZE;\n    return \n         mode == MAGNITUDE \n     #if   MAG_SCALE == LOG\n                           ?  vec4(log(length(F)))\n     #elif MAG_SCALE == LINEAR\n                           ?  vec4(length(F))\n     #endif\n       : mode == PHASE     ?  rainbow(F)        \n       : mode == COMPONENT ?  .5+.5*vec4(F, 0,0)\n       : mode == REAL      ?  .5+.5*vec4(F.x)\n       : mode == IMAG      ?  .5+.5*vec4(F.y)\n       : vec4(-1); \/\/ error\n}\n\n\/*\nfloat message(vec2 p) {  \/\/ the alert function to add to your shader : \"click to see\"\n    int x = int(p.x+1.)-1, y=int(p.y)-10,  i;\n    if (x<1||x>32||y<0||y>2) return -1.; \n    i = ( y==2? i=  757737252: y==1? i= 1869043565: y==0? 623593060: 0 )\/ int(exp2(float(32-x)));\n \treturn i==2*(i\/2) ? 1. : 0.;\n}\n*\/\n\nvoid mainImage( out vec4 O,  vec2 uv )\n{\n    \/\/if (iResolution.y<200.) \/\/ alert for the icon: \"click to see\"\n    \/\/    {   float c=message(uv\/8.); if(c>=0.){ O=vec4(c,0,0,0);return; } }\n    \n        \n    vec2 pixel = ( uv - R\/2.) \/ SIZE  + vec2(2,1)\/2.,\n         tile  = floor(pixel),\n         stile = floor(mod(2.*pixel,2.));    \n\t     uv = fract(pixel) * SIZE \/ R;\n    O-=O;\n\n    vec2 DISPLAY_MODE = floor(texture2D(iChannel3, .5\/R).zw); \/\/ persistant key flag.\n    if (tile.y==-1. && abs(tile.x-.5)<1.) {   \/\/ buttons displaying current flags value\n        for (float i=0.; i<5.; i++) \n            O += smoothstep(.005,.0,abs(length(uv*R\/SIZE-vec2(.2+i\/7.,.97))-.025));\n        float v = tile.x==0. ? DISPLAY_MODE[0] : DISPLAY_MODE[1];\n        O.b += smoothstep(.03,.02,length(uv*R\/SIZE-vec2(.2+v\/7.,.97)));\n    }\n      \n    if(tile == vec2(0,0))  \/\/ Input spectrum (Left)\n        O += paintDFT(texture2D(iChannel3, uv).xy, DISPLAY_MODE[0]);\n\n    if(tile == vec2(1,0))  \/\/ Output DFT (Right)\n        O += paintDFT(texture2D(iChannel2, uv).xy, DISPLAY_MODE[1]);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/\/ do your operation in spectral domain here\n\n#define SIZE (iResolution.x\/2.-30.) \/\/Size must be changed in each tab.\n\nbool keyPress(int ascii) { return (texture2D(iChannel2,vec2((.5+float(ascii))\/256.,0.25)).x > 0.); }\nfloat rand(vec2 uv) { return fract(1e5*sin(dot(uv,vec2(17.4,123.7)))); }     \/\/ point -> rnd [0,1[\nfloat gauss(float x) { return exp(-.5*x*x); }\n#define ang(a)  vec2(cos(a), sin(a))                         \/\/ used to set the complex exp(i.a)\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x) * vec2(cos(b),sin(b)); } \/\/ complex a*exp(i.b)\nvec2 R = iResolution.xy;\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    if ( U==vec2(.5)) {\n        if (iFrame==0) O.zw = vec2(0,0);\n        else           O.zw = texture2D(iChannel1, U\/R).zw;  \n        if ( keyPress(32) ) \n            if (iMouse.x\/R.x<.5) O.z = mod(O.z+.1, 5.) ; \/\/ persistant key flag for left window\n            else                 O.w = mod(O.w+.1, 5.) ; \/\/ persistant key flag for right window\n        return;\n    }\n    \n    U -= .5;  \/\/ freq 0 must exist\n    \n    U = 2.*U-SIZE;\n    vec2 X = U\/SIZE, T,\n         M = 2.*iMouse.xy\/R-1.;\n    float I=1., l = length(X), F, s = sign(-X.x); \/\/ s to help making a symmetric spectrum (phases included !)\n    \n    \n    \/\/ --- your custom Fourier-space function here ------------\n#define PROF  32 \/\/ spectrum profile ( = Fourier modulus)\n#define PHASE 3  \/\/ spectrum phases\n    \n#if 0 \/\/ 0:  scale shape at zoom    1: scale fourier at zoom\n    X *= SIZE\/256.;  l *= SIZE\/256., I *= SIZE\/256.; \n#endif    \n    \n                                     \/\/ --- modulus profile here\n#if PROF==0\n    F = 1.;                                     \/\/ flat\n#elif PROF==1\n    F = gauss(l\/.05)*10.;                       \/\/ gauss\n#elif PROF==101\n    F = gauss(l\/.01*M.x)*10.;                   \/\/ tunable gauss\n#elif PROF==11\n    F = exp(-l\/.05)*10.;                        \/\/ exp\n#elif PROF==111\n    F = exp(-l\/.02*(1.+M.x))*10.;               \/\/ tunable exp\n#elif PROF==2\n    float l1 = length(X-vec2(.07,0)),\n          l2 = length(X+vec2(.07,0));  \n    F = ( gauss(l1\/.02)+gauss(l2\/.02) )*10.;    \/\/ bi-lobe\n  \/\/l1 = length(X-vec2(.1,.05)),\n  \/\/l2 = length(X+vec2(.1,.05)); \n  \/\/F += ( gauss(l1\/.015)+gauss(l2\/.015) )*5.;  \/\/ additionnal bi-lobe\n#elif PROF==3\n    F = gauss(abs(l-.12)\/.005)*10.;             \/\/ ring (blue noise)\n#elif PROF==31\n    F = gauss(abs(l-.22)\/.002)*10.;             \/\/ variant\n#elif PROF==32\n    F = gauss(abs(l-.32-.1*cos(.1*iGlobalTime))\/.002)*10.;             \/\/ variant\n#elif PROF==4\n    F = gauss(abs(l-.12)\/.007)*10.*gauss(length(X*vec2(.1,1))\/.03)*3.;  \n#elif PROF==5\n    F = fract(sin(dot(U, vec2(12.9898, 78.233)))* 43758.5453) *2.-1.; \/\/ random\n  \/\/F = fract(sin(dot(U, vec2(13, 79)))* 4e5) *2.-1.; \n#endif\n \n                                     \/\/ --- phases here ( 0 for direct Fourier transform)\n  \/\/vec2 P = ang(6.2832*rand(U));               \/\/ default: random phases\n    vec2 P = ang(6.2832*rand(X*s)*s);           \/\/ with phase symmetry\n#if PHASE==0\n    T = vec2(1,0);                              \/\/ no phases ( all 0 )\n#elif PHASE==1\n    T = P;                                      \/\/ random phases\n#elif PHASE==20\n    T = ang(6.2832*length(30.*X));              \/\/ correlated phase: linear \n#elif PHASE==21\n    T = ang(6.2832*length(sin(30.*X)));         \/\/ correlated phase\n#elif PHASE==212\n    T = ang(6.2832*length(sin(100.*M*X)));          \/\/ variant with mouse gain\n#elif PHASE==3\n    T = cmul(P,2.*iGlobalTime*s);               \/\/ phase shift with time   \n#elif PHASE==31\n    T = cmul(P,2.*iGlobalTime*s*sqrt(30.*abs(X.x))); \/\/ dispersive phase shift \n  \/\/T = cmul(P,2.*iGlobalTime*s*sqrt(1.\/(1e-5+abs(X.x)))); \n#endif\n    \n    \n    O = vec4(T*F,0,0)*sqrt(I); \/\/  *SIZE;  \n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ invFourier transform \n\n\/\/ Horizontal + Vertical Discrete Fourier Transform of the input \n\/\/ 2 passes pipelined : in -> buf.zw -> buf.xy -> out\n\/\/ ( adapted from  Flyguy's https:\/\/www.shadertoy.com\/view\/MscGWS# )\n\n\n#define SIZE (iResolution.x\/2.-30.) \/\/Size must be changed in each tab.\n\nvec2 cmul (vec2 a,float b) { return mat2(a,-a.y,a.x)*vec2(cos(b), sin(b)); } \/\/ complex a*exp(i.b)\n#define W(uv)   mod(uv+SIZE\/2.,SIZE)                    \/\/ wrap [-1\/2,1\/2] to [0,1]\n\n\nvoid mainImage( out vec4 O, vec2 U )\n{\n    O-=O; \n    \n    if(U.x > SIZE || U.y > SIZE) return;\n\n    for(float n = 0.; n < 1000.; n++)  {\n        if (n>=SIZE) break;\n        float m = W(n);       \/\/ W to warp 0,0 to mid-window.\n        vec2 xn = texture2D(iChannel0, vec2(m+.5, U.y) \/ iResolution.xy).xy,\n             yn = texture2D(iChannel1, vec2(U.x, m+.5) \/ iResolution.xy).zw,\n             a =  6.2831853 *  W(U-.5) * n\/SIZE;\n        \n        O.zw += cmul(xn, a.x);\n        O.xy += cmul(yn, a.y);\n    }\n    \n    O.zw \/= SIZE;\n}","name":"Buf B","description":"","type":"buffer"}]}}