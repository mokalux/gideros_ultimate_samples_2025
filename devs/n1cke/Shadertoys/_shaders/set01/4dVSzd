{"Shader":{"ver":"0.1","info":{"id":"4dVSzd","date":"1466085498","viewed":79,"name":"Cherry","username":"emdeka87","description":"Work in progress. Currently trying to figure out correct reflection. Any suggestions? ","likes":0,"published":3,"flags":0,"tags":["animation","reflections","cherry"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"#define rot(x) mat2(cos(x), -sin(x), sin(x), cos(x))\n#define PI 3.14159265359\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdPlane( vec3 p, vec4 n )\n{\n  return dot(p,n.xyz) + n.w;\n}\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\nfloat sdCappedCylinder( vec3 p, vec2 h )\n{\n  vec2 d = abs(vec2(length(p.xz),p.y)) - h;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\nfloat smin( float a, float b, float k )\n{\n    float res = exp( -k*a ) + exp( -k*b );\n    return -log( res )\/k;\n}\n\nfloat cherry(vec3 p, float r, float rx) {\n    vec3 q = p;\n    q.y-=r;\n    q.x-= sin(q.y)*rx;\n\n    float st = sdCappedCylinder(q, vec2(0.05,1.4));\n    \n    q = p;\n  \tq.y *= 0.95;\n\tq.xz *= 1.2;\n\n\tfloat k = 0.84 + 0.16 * smoothstep(-r, r, q.y);\n\tq.xz \/= k;\n    \n\tfloat bc = sdTorus(q, vec2((0.9 \/ 1.25) * r, r));\n  \n    return min(bc,st);\n}\n\nfloat map(vec3 p) {\n    \n    float t = sin(iGlobalTime);\n    float d = 1.+t*0.2;\n    float rx =-0.6;\n\n    float c1 = cherry(p+vec3(d,0.3,0),0.6,-rx);\n    float c2 = cherry(p-vec3(d,-0.3,0),0.6,rx);\n\n    float k;\n    k = sdPlane(p,vec4(0,0,-1,3));\n    k = min(k,c1);\n    k = min(k,c2);\n    \n    return k;\n}\n\nstruct RayHit {\n \tfloat f;\n    vec3 p;\n    vec3 n;\n};\n\nRayHit trace(vec3 o, vec3 r) {\n    float t = 0.;\n  \n    for (int i = 0; i < 100; ++i) { \n        float d = map(o + r * t);\n        t += d * .9;\n    }\n    \n    RayHit rh;\n    rh.f = t;\n    rh.p = o + rh.f * r;\n    \n    vec2 eps = vec2(0, .0001);\n    rh.n = normalize(vec3(\n    \tmap(rh.p + eps.yxx) - map(rh.p - eps.yxx),\n    \tmap(rh.p + eps.xyx) - map(rh.p - eps.xyx),\n    \tmap(rh.p + eps.xxy) - map(rh.p - eps.xxy)\n\t));\n    \n    return rh;\n}\n\n\nvec3 material(vec3 p) {\n   vec3 c = vec3(0);\n   \n   c += step(p.z,2.)*step(0.35,p.y)*vec3(0, 0.6, 0); \/\/straw\n   c += step(p.z,2.)*step(p.y,0.35)*vec3(0.73, 0, 0); \/\/cherry\n   c += step(2.,p.z)*vec3(0,0,0); \/\/bg\n \n   return c;\n}\n   \nvec3 shade(vec3 p, vec3 n, vec3 e) {\n    vec3 tx = material(p);\n\n    vec3 spec = tx*1.3;\n   \tvec3 ambient = 2.5*tx;\n    float lightAttenuation = .8;\n    \n    vec3 eye = normalize(e-p);\n    vec3 light = normalize(vec3(0,1,-0.6)-p);\n    \n    vec3 diffuse = tx*max(0.0,dot(light,n));\n    vec3 specular = spec*max(0.0,pow(dot(reflect(-light,n),eye),2.));\n    \n    float ldist = length(light - p);\n    float att = 1.0 \/ (1.0 + lightAttenuation * pow(ldist, 2.));\n    \n    return ambient+att*(diffuse+specular);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy * 2. - 1.;\n    uv.x *= iResolution.x \/ iResolution.y;\n\t\n    vec3 o = vec3(0, 0,-3.5); \n    vec3 r = normalize(vec3(uv, 2.));\n    vec3 cam = o;\n    \n    float a = 0.6;\n    o.yz *= rot(a);\n    r.yz *= rot(a);\n    cam.yz *= rot(a);\n    \n    RayHit rh = trace(o,r);\n    vec3 c = shade(rh.p,rh.n,cam);\n    \n    RayHit ref = trace(o,reflect(r,rh.n));\n    c+= shade(rh.p,rh.n,cam)*.3;\n \n    fragColor = vec4(c,1.0)\/ref.f;\n}","name":"Image","description":"","type":"image"}]}}