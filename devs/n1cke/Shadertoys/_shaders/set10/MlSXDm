{"Shader":{"ver":"0.1","info":{"id":"MlSXDm","date":"1469477304","viewed":428,"name":"Learning to Dig","username":"Dave_Hoskins","description":"Energy problems? You live on a thin crust...Just learn to dig, stupid humans! :) \nYou may need full screen to read it. It uses a sprite sheet in 'Buf A' to render the font quickly.","likes":15,"published":3,"flags":96,"tags":["2d","text","font","learningtodig"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":4375,"src":"https:\/\/soundcloud.com\/dave-h-3\/desert-moon","ctype":"musicstream","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Learning to Dig\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/8x8x1 font access...\n#define _A col += char(vec2(0,0));\n#define _B col += char(vec2(1,0));\n#define _C col += char(vec2(2,0));\n#define _D col += char(vec2(3,0));\n#define _E col += char(vec2(4,0));\n#define _F col += char(vec2(5,0));\n#define _G col += char(vec2(6,0));\n#define _H col += char(vec2(7,0));\n#define _I col += char(vec2(8,0));\n#define _J col += char(vec2(9,0));\n#define _K col += char(vec2(10,0));\n#define _L col += char(vec2(11,0));\n#define _M col += char(vec2(12,0));\n#define _N col += char(vec2(13,0));\n#define _O col += char(vec2(14,0));\n#define _P col += char(vec2(15,0));\n#define _Q col += char(vec2(16,0));\n#define _R col += char(vec2(17,0));\n#define _S col += char(vec2(18,0));\n#define _T col += char(vec2(19,0));\n#define _U col += char(vec2(20,0));\n#define _V col += char(vec2(21,0));\n#define _W col += char(vec2(22,0));\n#define _X col += char(vec2(23,0));\n#define _Y col += char(vec2(24,0));\n#define _Z col += char(vec2(25,0));\n#define _a col += char(vec2(0,1));\n#define _b col += char(vec2(1,1));\n#define _c col += char(vec2(2,1));\n#define _d col += char(vec2(3,1));\n#define _e col += char(vec2(4,1));\n#define _f col += char(vec2(5,1));\n#define _g col += char(vec2(6,1));\n#define _h col += char(vec2(7,1));\n#define _i col += char(vec2(8,1));\n#define _j col += char(vec2(9,1));\n#define _k col += char(vec2(10,1));\n#define _l col += char(vec2(11,1));\n#define _m col += char(vec2(12,1));\n#define _n col += char(vec2(13,1));\n#define _o col += char(vec2(14,1));\n#define _p col += char(vec2(15,1));\n#define _q col += char(vec2(16,1));\n#define _r col += char(vec2(17,1));\n#define _s col += char(vec2(18,1));\n#define _t col += char(vec2(19,1));\n#define _u col += char(vec2(20,1));\n#define _v col += char(vec2(21,1));\n#define _w col += char(vec2(22,1));\n#define _x col += char(vec2(23,1));\n#define _y col += char(vec2(24,1));\n#define _z col += char(vec2(25,1));\n#define _0 col += char(vec2(0,2));\n#define _1 col += char(vec2(1,2));\n#define _2 col += char(vec2(2,2));\n#define _3 col += char(vec2(3,2));\n#define _4 col += char(vec2(4,2));\n#define _5 col += char(vec2(5,2));\n#define _6 col += char(vec2(6,2));\n#define _7 col += char(vec2(7,2));\n#define _8 col += char(vec2(8,2));\n#define _9 col += char(vec2(9,2));\n#define _EXC col += char(vec2(10,2));\n#define _QTN col += char(vec2(11,2));\n#define _STP col += char(vec2(12,2));\n#define _COM col += char(vec2(13,2));\n#define _APO col += char(vec2(14,2));\n#define _SP loc.x+=add.x*.5; \n#define _NL loc.x = caret.x; loc.y-=add.y*.5; \n\n\nvec2 crd;\nvec2 add;\nvec2 loc;\nvec2 size;\nvec2 caret;\n\n\nfloat char(in vec2 b)\n{\n    float bin;\n    vec2 p = crd*size-(loc*size);\n    loc.x += add.x;\n    if (!(all(lessThan(p,vec2(8.))) &&  all(greaterThanEqual(p,vec2(0.))))) return 0.0;\n\n\treturn -texture2D(iChannel0, (p+b*9.)\/ iResolution.xy).r;\n}\n\nvoid mainImage( out vec4 fragColour, in vec2 coord )\n{\n    size = vec2(500.0, 400.0);\n    add = vec2(8.0\/size.x, 18.0\/size.y);\n \n    crd = coord \/ iResolution.xy;\n    \n\n    vec3 col = texture2D(iChannel1, crd).xyz; \n    crd.x *= iResolution.x\/iResolution.y;\n     \n\/\/    caret = loc = vec2(0.25, .5);\n\/\/    _A _B _C _D _E _F _G _H _I _J _K _L _M _N _O _P _Q _R _S _T _U _V _W _X _Y _Z _NL\n\/\/    _a _b _c _d _e _f _g _h _i _j _k _l _m _n _o _p _q _r _s _t _u _v _w _x _y _z\n    \n    float ti = iGlobalTime;\n    if (ti > 1.0)\n    {\n    \tcaret = loc = vec2(.25, .9);\n    \t_W _h _e _r _e _SP _i _n _SP _t _h _e _SP _w _o _r _l _d _NL\n    \t_c _a _n _SP _w _e _SP _f _i _n _d _SP _m _o _r _e _SP _E _n _e _r _g _y _QTN \n\t}\n       \n    if (ti > 3.0)\n    {\n\t\tcaret = loc = vec2(.16, .7);\n    \t_L _e _t _APO _s _SP _g _r _o _w _SP _B _i _o _F _u _e _l _NL\n\t\t_i _n _s _t _e _a _d _SP _o _f _SP _f _o _o _d _EXC\n\t}\n     \n\tif (ti > 5.0)\n    {\n\t\t caret = loc = vec2(.18, .5);\n\t\t_J _u _s _t _SP  _i _g _n _o _r _e _SP _i _t _COM _NL\n    \t_SP _SP _n _o _SP _p _r _o _b _l _e _m _STP\n\t}\n    if (ti > 7.0)\n    {\n\t\tcaret = loc = vec2(.25, .3);\n\t\t_S _o _l _a _r _SP _P _o _w _e _r _COM _NL\n\t\t_t _h _a _t _APO _s _SP _i _t _EXC\n\t}\n    if (ti > 9.0)        \n    {\n\t\tcaret = loc = vec2(.33, .1);\n\t\t_I _APO _m _SP _f _o _r _SP _N _u _c _l _e _a _r _EXC\n\t}\n\n    if (ti > 2.0)\n    {\n    \tcaret = loc = vec2(1.2, .9);\n    \t_I  _s _SP _t _h _e _r _e _SP _a _SP _s _u _b _t _i _t _u _t _e _NL\n    \t_SP _f _o _r _SP _o _i _l _EXC _QTN\n\t}\n        \n    if (ti > 4.0)\n    {\n\t\tcaret = loc = vec2(1.35, .7);\n    \t_W _h _a _t _SP _a _b _o _u _t _SP _w _i _n _d _SP  _p _o _w _e _r _EXC\n\t}\n      \n    if (ti > 6.0)\n    {\n\t\tcaret = loc = vec2(1.39, .5);\n\t\t_W _e _SP _c _o _u _l _d _SP _h _a _r _n _e _s _s _NL\n\t\t_t _h _e _SP _p _o _w _e _r _SP _o _f _SP _t _h _e _SP _s _e _a _EXC\n\t}\n    if (ti > 8.0)\n    {\n    \tcaret = loc = vec2(1.35, .3);\n    \t_S _h _a _l _e _SP _g _a _s _QTN _SP _T _h _a _t _APO _s _NL\n    \t_c _o _s _t _SP _e _f _f _e _c _t _i _v _e _STP _STP _STP\n\t}\n    if (ti > 9.9)\n    {\n    \tcaret = loc = vec2(1.2, .1);\n    \t_L _e _t _APO _s _SP _t _r _y _SP _a _n _d _NL\n\t\t_f _i _n _d _SP _m _o _r _e _SP _o _i _l _SP _h _e _r _e _STP\n     }\n        \n\n\tfragColour = vec4(col, 1);\n    \n    size = vec2(250.0, 200.);\n    add = vec2(8.0\/size.x, 18.0\/size.y);\n    col = vec3(0);\n    caret = loc = vec2(.67, .01);\n\t_L _e _a _r _n _i _n _g _SP _T _o _SP _D _i _g\n    fragColour.xyz -= col*vec3(1.5, .5, .4);\n\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":257,"channel":0}],"code":"\/\/ Learning to Dig\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\/\/8x8x1 font data...\n#define _A col += char(vec4(0x386C, 0xC6C6, 0xFEC6, 0xC600));loc.x+=1.;\n#define _B col += char(vec4(0xFCC6, 0xC6FC, 0xC6C6, 0xFC00));loc.x+=1.;\n#define _C col += char(vec4(0x3C66, 0xC0C0, 0xC066, 0x3C00));loc.x+=1.;\n#define _D col += char(vec4(0xF8CC, 0xC6C6, 0xC6CC, 0xF800));loc.x+=1.;\n#define _E col += char(vec4(0xFEC0, 0xC0FC, 0xC0C0, 0xFE00));loc.x+=1.;\n#define _F col += char(vec4(0xFEC0, 0xC0FC, 0xC0C0, 0xC000));loc.x+=1.;\n#define _G col += char(vec4(0x3E60, 0xC0CE, 0xC666, 0x3E00));loc.x+=1.;\n#define _H col += char(vec4(0xC6C6, 0xC6FE, 0xC6C6, 0xC600));loc.x+=1.;\n#define _I col += char(vec4(0x7E18, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _J col += char(vec4(0x606, 0x606, 0x6C6, 0x7C00));loc.x+=1.;\n#define _K col += char(vec4(0xC6CC, 0xD8F0, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _L col += char(vec4(0x6060, 0x6060, 0x6060, 0x7E00));loc.x+=1.;\n#define _M col += char(vec4(0xC6EE, 0xFEFE, 0xD6C6, 0xC600));loc.x+=1.;\n#define _N col += char(vec4(0xC6E6, 0xF6FE, 0xDECE, 0xC600));loc.x+=1.;\n#define _O col += char(vec4(0x7CC6, 0xC6C6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _P col += char(vec4(0xFCC6, 0xC6C6, 0xFCC0, 0xC000));loc.x+=1.;\n#define _Q col += char(vec4(0x7CC6, 0xC6C6, 0xDECC, 0x7A00));loc.x+=1.;\n#define _R col += char(vec4(0xFCC6, 0xC6CC, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _S col += char(vec4(0x78CC, 0xC07C, 0x6C6, 0x7C00));loc.x+=1.;\n#define _T col += char(vec4(0x7E18, 0x1818, 0x1818, 0x1800));loc.x+=1.;\n#define _U col += char(vec4(0xC6C6, 0xC6C6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _V col += char(vec4(0xC6C6, 0xC6EE, 0x7C38, 0x1000));loc.x+=1.;\n#define _W col += char(vec4(0xC6C6, 0xD6FE, 0xFEEE, 0xC600));loc.x+=1.;\n#define _X col += char(vec4(0xC6EE, 0x7C38, 0x7CEE, 0xC600));loc.x+=1.;\n#define _Y col += char(vec4(0x6666, 0x663C, 0x1818, 0x1800));loc.x+=1.;\n#define _Z col += char(vec4(0xFE0E, 0x1C38, 0x70E0, 0xFE00));loc.x+=1.;\n#define _a col += char(vec4(0x0, 0x7C06, 0x7EC6, 0x7E00));loc.x+=1.;\n#define _b col += char(vec4(0xC0C0, 0xFCC6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _c col += char(vec4(0x0, 0x7EC0, 0xC0C0, 0x7E00));loc.x+=1.;\n#define _d col += char(vec4(0x606, 0x7EC6, 0xC6C6, 0x7E00));loc.x+=1.;\n#define _e col += char(vec4(0x0, 0x7CC6, 0xFEC0, 0x7C00));loc.x+=1.;\n#define _f col += char(vec4(0xE18, 0x7E18, 0x1818, 0x1800));loc.x+=1.;\n#define _g col += char(vec4(0x0, 0x7EC6, 0xC67E, 0x67C));loc.x+=1.;\n#define _h col += char(vec4(0xC0C0, 0xFCC6, 0xC6C6, 0xC600));loc.x+=1.;\n#define _i col += char(vec4(0x1800, 0x3818, 0x1818, 0x7E00));loc.x+=1.;\n#define _j col += char(vec4(0xC00, 0x1C0C, 0xC0C, 0xC78));loc.x+=1.;\n#define _k col += char(vec4(0xC0C0, 0xCEFC, 0xF8DC, 0xCE00));loc.x+=1.;\n#define _l col += char(vec4(0x3818, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _m col += char(vec4(0x0, 0xFCB6, 0xB6B6, 0xB600));loc.x+=1.;\n#define _n col += char(vec4(0x0, 0xFCC6, 0xC6C6, 0xC600));loc.x+=1.;\n#define _o col += char(vec4(0x0, 0x7CC6, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _p col += char(vec4(0x0, 0xFCC6, 0xC6FC, 0xC0C0));loc.x+=1.;\n#define _q col += char(vec4(0x0, 0x7EC6, 0xC67E, 0x606));loc.x+=1.;\n#define _r col += char(vec4(0x0, 0x6E70, 0x6060, 0x6000));loc.x+=1.;\n#define _s col += char(vec4(0x0, 0x7CC0, 0x7C06, 0xFC00));loc.x+=1.;\n#define _t col += char(vec4(0x1818, 0x7E18, 0x1818, 0x1800));loc.x+=1.;\n#define _u col += char(vec4(0x0, 0xC6C6, 0xC6C6, 0x7E00));loc.x+=1.;\n#define _v col += char(vec4(0x0, 0x6666, 0x663C, 0x1800));loc.x+=1.;\n#define _w col += char(vec4(0x0, 0xB6B6, 0xB6B6, 0x7E00));loc.x+=1.;\n#define _x col += char(vec4(0x0, 0xC6FE, 0x38FE, 0xC600));loc.x+=1.;\n#define _y col += char(vec4(0x0, 0xC6C6, 0xC67E, 0x67C));loc.x+=1.;\n#define _z col += char(vec4(0x0, 0xFE1C, 0x3870, 0xFE00));loc.x+=1.;\n#define _0 col += char(vec4(0x384C, 0xC6C6, 0xC664, 0x3800));loc.x+=1.;\n#define _1 col += char(vec4(0x1838, 0x1818, 0x1818, 0x7E00));loc.x+=1.;\n#define _2 col += char(vec4(0x7CC6, 0xE3C, 0x78E0, 0xFE00));loc.x+=1.;\n#define _3 col += char(vec4(0x7E0C, 0x183C, 0x6C6, 0x7C00));loc.x+=1.;\n#define _4 col += char(vec4(0x1C3C, 0x6CCC, 0xFE0C, 0xC00));loc.x+=1.;\n#define _5 col += char(vec4(0xFCC0, 0xFC06, 0x6C6, 0x7C00));loc.x+=1.;\n#define _6 col += char(vec4(0x3C60, 0xC0FC, 0xC6C6, 0x7C00));loc.x+=1.;\n#define _7 col += char(vec4(0xFEC6, 0xC18, 0x3030, 0x3000));loc.x+=1.;\n#define _8 col += char(vec4(0x78C4, 0xE478, 0x9E86, 0x7C00));loc.x+=1.;\n#define _9 col += char(vec4(0x7CC6, 0xC67E, 0x60C, 0x7800));loc.x+=1.;\n#define _EXC col += char(vec4(0x3838, 0x3830, 0x3000, 0x3000));loc.x+=1.;\n#define _QTN col += char(vec4(0x7CFE, 0xC60C, 0x3800, 0x3800));loc.x+=1.;\n#define _COM col += char(vec4(0x0, 0x0, 0x30, 0x3060));loc.x+=1.;\n#define _APO col += char(vec4(0x3030, 0x3000, 0x0, 0x0));loc.x+=1.;\n#define _STP col += char(vec4(0x0, 0x0, 0x30, 0x3000));loc.x+=1.;\n#define _SP loc.x+=1.; \n\nvec2 loc;\nvec2 crd;\n\nfloat char(in vec4 b)\n{\n    float bin;\n    vec2 p = crd- (loc * 9.0);\n    if (!(all(lessThan(p,vec2(8))) &&  all(greaterThanEqual(p,vec2(0))))) return 0.0;\n    \n\tp = floor(8.0-p);    int c = int(p.y \/ 2.0);\n    if (c == 0)\n    {\n    \tbin = b.x;\n    }else\n    if (c == 1)\n    {\n    \tbin = b.y;\n    }else\n    if (c == 2)\n    {\n    \tbin = b.z;\n    }else\n    if (c == 3)\n    {\n    \tbin = b.w;\n    }\n    if (int(mod(p.y, 2.0)) == 0) p.x += 8.;\n\treturn mod(floor(float(bin) \/ pow(2.0, p.x)), 2.0);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n\t\n    crd = coord;\n    \n    float col = 0.0;\n    \n    loc = vec2(0, 0);\n    _A _B _C _D _E _F _G _H _I _J _K _L _M _N _O _P _Q _R _S _T _U _V _W _X _Y _Z\n     loc = vec2(0, 1);\n    _a _b _c _d _e _f _g _h _i _j _k _l _m _n _o _p _q _r _s _t _u _v _w _x _y _z\n    loc = vec2(0, 2);\n    _0 _1 _2 _3 _4 _5 _6 _7 _8 _9 _EXC _QTN _STP _COM _APO\n\/\/    loc = vec2(1.0, 10);\n\/\/    _L _e _a _r _n _i _n _g _SP _T _o _SP _D _i _g\n\n\tfragColor = vec4(col);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Learning to Dig\n\/\/ by David Hoskins.\n\/\/ License Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License.\n\n\n\/\/  1 out, 2 in...\n#define HASHSCALE1 .1031\nfloat hash12(vec2 p)\n{\n\tvec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n    p3 += dot(p3, p3.yzx + 19.19);\n    return fract((p3.x + p3.y) * p3.z);\n}\n\n\/\/--------------------------------------------------------------------------\nconst vec2 add = vec2(1.0,0.0);\nfloat noise( in vec2 x )\n{\n    vec2 p = floor(x);\n    vec2 f = fract(x);\n    f = f*f*(1.5-f)*2.0;\n    \n    float res = mix(mix( hash12(p), hash12(p + add.xy),f.x),\n                    mix( hash12(p + add.yx), hash12(p + add.xx),f.x),f.y);\n    return res;\n}\n\n\n\nfloat circle (vec2 p, float d)\n{\n    float f = length(p)-d;\n    return f;\n}\nfloat box( vec2 p, vec2 pos, vec2 b, float r )\n{\n    p-=pos;\n  return length(max(abs(p)-b,0.0))-r;\n}\n\n\n\/\/ signed distance to a 2D triangle\n\/\/ Thanks to rwvens for this triangle distance field...\nfloat arrow(in vec2 p,  in vec2 p0, in vec2 p1)\n{\n    vec2 p2 = normalize(vec2((p1.y-p0.y), -(p1.x -p0.x)))*.025+p0;\n    p.y -= sin((-(length(p0-p)))*10.)*.06;\n    \n\tvec2 e0 = p1 - p0;\n\tvec2 e1 = p2 - p1;\n\tvec2 e2 = p0 - p2;\n\tvec2 v0 = p - p0;\n\tvec2 v1 = p - p1;\n\tvec2 v2 = p - p2;\n\tvec2 pq0 = v0 - e0*clamp( dot(v0,e0)\/dot(e0,e0), 0.0, 1.0 );\n\tvec2 pq1 = v1 - e1*clamp( dot(v1,e1)\/dot(e1,e1), 0.0, 1.0 );\n\tvec2 pq2 = v2 - e2*clamp( dot(v2,e2)\/dot(e2,e2), 0.0, 1.0 );\n    vec2 d = min( min( vec2( dot( pq0, pq0 ), v0.x*e0.y-v0.y*e0.x ),\n                       vec2( dot( pq1, pq1 ), v1.x*e1.y-v1.y*e1.x )),\n                       vec2( dot( pq2, pq2 ), v2.x*e2.y-v2.y*e2.x ));\n\treturn -sqrt(d.x)*sign(d.y);\n}\n\n\/\/----------------------------------------------------------------------------------------\nconst mat2 m = mat2( 0.80,  0.90, -0.90,  0.80 )*2.7;\nfloat fbm4( vec2 p )\n{\n    float f = 0.0;\n    f += 0.5000*noise( p ); p = m*p;\n    f += 0.2500*noise( p ); p = m*p;\n    f += 0.1250*noise( p ); p = m*p;\n    f += 0.0625*noise( p );\n    return f\/0.9375;\n}\n\nfloat fbm6( vec2 p )\n{\n    float f = 0.0;\n    f += 0.500000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.250000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.125000*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.062500*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.031250*(0.5+0.5*noise( p )); p = m*p;\n    f += 0.015625*(0.5+0.5*noise( p ));\n    return f\/0.96875;\n}\n\n\/\/ Thanks to iq for writing this warp function, altering this saved me loads of time and experimentation...\n\/\/ https:\/\/www.shadertoy.com\/view\/lsl3RH\nvec3 lava(in vec2 q, in float d)\n{\n    q*=2.0;\n    float ql = length( q );\n    q.x += 0.05*sin(0.37*iGlobalTime+ql*4.7);\n    q.y += 0.05*sin(0.33*iGlobalTime+ql*4.7);\n    q *= 0.7;\n\n\tvec2 o = vec2(0.0);\n    o.x = 0.5 + 0.5*fbm6( vec2(2.0*q          )  );\n    o.y = 0.5 + 0.5*fbm6( vec2(2.0*q)  );\n\n\tfloat ol = length( o );\n    o.x += 0.02*sin(0.12*iGlobalTime*4.+ol)\/ol;\n    o.y += 0.02*sin(0.14*iGlobalTime*4.+ol)\/ol;\n\n    vec2 n;\n    n.x = fbm6( vec2(7.0*o+vec2(19.2))  );\n    n.y = fbm6( vec2(7.0*o+vec2(15.7))  );\n\n    vec2 p = 4.0*q + 4.0*n;\n\n    float f = 0.5 + .5 * fbm4( p );\n\n    f = mix( f, f*f*f*3.5, f*abs(n.x) );\n\n    float g = 0.5 + 0.5*sin(4.0*p.x)*sin(4.0*p.y);\n    f *= 1.0-0.5*pow( g, 8.0 );\n\n\t\/\/vec4 on = vec4( o, n );\n\t\n    vec3 col = mix(vec3(f, f, 0), vec3(1.0-f*.3), smoothstep(-.01 , -.4, d));\n    col += mix(vec3(0), vec3(pow(f, 5.0))*.4, smoothstep(-.01 , -.5, d));\n    col =  mix(col, vec3(1,1,0), n.x*.5);\n    col -= vec3(.0,1.,1.) * dot(o,o)*(d+.5);\n    \n    return col;\n}\nfloat flare( vec2 U )                            \/\/ rotating hexagon \n{\tvec2 A = sin(vec2(0, 1.57) + iDate.w);\n    U = abs( U * mat2(A, -A.y, A.x) ) * mat2(2,0,1,1.7); \n    return .2\/max(U.x,U.y);                      \/\/ glowing-spiky approx of step(max,.2)\n  \/\/return .2*pow(max(U.x,U.y), -2.);\n \n}\n\n#define r(x)     fract(1e4*sin((x)*541.17))      \/\/ rand, signed rand   in 1, 2, 3D.\n#define sr2(x)   ( r(vec2(x,x+.1)) *2.-1. )\n\nvoid mainImage( out vec4 fragColor, in vec2 coord )\n{\n    vec3 col = vec3(0);\n    vec2 xy = coord \/ iResolution.xy;\n\n    \n    vec2 crd = (xy)*2.-1.;\n    float c = 0.0;\n    \n    \/\/ Thanks to FabriceNeyret2 for his perfect star field effect\n    \/\/-----------------------------------------------------------\n    for (float i=0.; i< 80.; i++)\n    c += flare (crd-sr2(i+9.))           \/\/ rotating flare at random location\n              * r(i+.2)                          \/\/ random scale\n              * (1.4+sin(iGlobalTime+r(i+.3)*18.))*.01;\/\/  \/\/ time pulse\n    col = vec3(c);\n\n\n    xy.x  *= iResolution.x\/iResolution.y;\n    crd.x *= iResolution.x\/iResolution.y; \/\/...Aspect ratio with y still being -1 to 1\n\n    \n    float d = circle(crd, .85);\n    \/\/col = mix(col, vec3(.45, .3, .2), smoothstep(1. , 0., d));\n    col = mix(col, vec3(.0, .7, 1.0), smoothstep(0.05 , .005, d)*.8);\n    col = mix(vec3(.1,0.2,.1), col, smoothstep(0.0, 0.001, d+noise(crd*100.)*.005));\n    col = mix(col, lava(crd, d), smoothstep(-.01 , -.015, d));\n\tcol = mix(col, vec3(1.0, 1.0, 1.0), smoothstep(-.5 , -.8, d));\n   \n\td = 10.;\n    float ti = iGlobalTime;\n    if (ti > 1.)\n    {\n        d = box(xy, vec2(.42, .9), vec2(.17, .015),.02);\n    \td = min(d, arrow(xy, vec2(.44, .93),vec2(.575, .86))); \n    }\n    if (ti > 3.)\n    {\n        d = min(d, box(xy, vec2(.3, .7), vec2(.14, .015),.02));;\n\t\td = min(d, arrow(xy, vec2(.37, .73),vec2(.464, .65))); \n    }\n\n    if (ti > 5.)\n    {\n        d = min(d, box(xy, vec2(.288, .5), vec2(.11, .015),.02));\n        d = min(d, arrow(xy, vec2(.38, .52),vec2(.47, .45))); \n    }\n    if (ti > 7.)\n    {\n        d = min(d, box(xy, vec2(.33, .3), vec2(.1, .015),.02));\n        d = min(d, arrow(xy, vec2(.42, .33),vec2(.56, .28))); \n    }\n    \n    if (ti > 9.)\n    {\n        d = min(d, box(xy, vec2(.45, .11), vec2(.112, .015),.02));\n        d = min(d, arrow(xy, vec2(.5, .14),vec2(.64, .2))); \n    }\n    \n    if (ti > 2.)\n    {\n        d = min(d, box(xy, vec2(1.36, .9), vec2(.165, .015),.02));\n        d = min(d, arrow(xy, vec2(1.3, .89),vec2(1.21, .85))); \n    }\n    if (ti > 4.)\n    {\n        d = min(d, box(xy, vec2(1.51, .71), vec2(.165, .015),.02));\n        d = min(d, arrow(xy, vec2(1.41, .7),vec2(1.315, .65))); \n    }\n    if (ti > 6.)\n    {\n        d = min(d, box(xy, vec2(1.54, .5), vec2(.153, .015),.02));\n        d = min(d, arrow(xy, vec2(1.45, .5),vec2(1.305, .45))); \n    }\n    if (ti > 8.)\n    {\n        d = min(d, box(xy, vec2(1.475, .3), vec2(.13, .015),.02));\n        d = min(d, arrow(xy, vec2(1.35, .29),vec2(1.232, .29))); \n    }\n    if (ti > 9.9)\n    {\n        d = min(d, box(xy, vec2(1.33, .1), vec2(.141, .015),.02));\n        d = min(d, arrow(xy, vec2(1.25, .1),vec2(1.12, .192))); \n    }\n        \n    col = mix(col, vec3(1.0,.9,.8), smoothstep(0.01,.0, d));\n    col = mix(col, vec3(1.,.2,.0), smoothstep(0.005,.011, d)*smoothstep(0.012,.011, d));\n        \n        \n    fragColor = vec4(col,1);\n}","name":"Buf B","description":"","type":"buffer"}]}}