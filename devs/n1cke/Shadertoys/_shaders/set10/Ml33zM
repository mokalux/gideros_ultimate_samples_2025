{"Shader":{"ver":"0.1","info":{"id":"Ml33zM","date":"1468949846","viewed":151,"name":"Please help debugging raymarcher","username":"Glyph","description":"Hello, this is my first raymarcher an it's exhibiting strange behavior. In my distance map, unless I use a uniform to cause an objects characteristics to change at runtime, nothing is rendered at all. To see this change \"work\" to \"fail\" at the top...","likes":0,"published":3,"flags":0,"tags":["raymarching","debugging"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/Change from \"work\" to \"fail\" to see issue. Then scroll to the map and raymarch functions defined under main to see code.\n#define work\n\n#define MAX_DIST 10.0\n#define MAX_ITER 128\n#define EPSILON .0005\n\n#define PI 3.141592653589793\n\n#define RED vec3(1.0,0.0,0.0)\n#define GREEN vec3(0.0,1.0,0.0)\n#define BLUE vec3(0.0,0.0,1.0)\n\nconst float fov = radians(55.0);\nconst float sensize = 1.0;\nconst float flen = .5*sensize\/tan(fov\/2.0);\nconst vec3 background = vec3(0.5,0.98,0.9);\n\n\nstruct camera{\n    vec3 up;\n    vec3 right;\n    vec3 vp; \/\/View vector\n    vec3 loc;\n};\n\n    \n\/\/Forward declarations\ncamera newcam(vec3 loc);\n\nfloat inv(float b);\n\nmat3 rotate3D(vec3 th);\n\nfloat sphere(vec3 p, vec3 loc, float r);\n\nfloat udBox( vec3 p, vec3 loc, vec3 b ); \n\nfloat map(vec3 p);\n\nvec3 raymarch(vec3 p, vec3 phat, camera cam);\n\n    \nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float ar = iResolution.y\/iResolution.x;\n\n    vec2 csuv = (fragCoord.xy \/ iResolution.xy - .5) * 2.0; vec2 cuv = csuv * vec2(1.0,ar); \/\/ Centered Rectangle coord system\n    vec2 tuv = (iMouse.xy \/ iResolution.xy);\n    vec2 ctuv = (iMouse.xy \/ iResolution.xy - .5) * 2.0;\n  \n    camera cam = newcam(vec3(0.0,0.0,-1.0)); \/\/ New camera facing the origin and located -1 units from the origin in z direction.\n    \n    vec3 p = cam.loc;\n    vec3 phat = normalize(cam.right*cuv.x + cam.up*cuv.y + cam.vp*flen); \/\/ Normalized direction of vector to march \"p hat\" \n    \n    vec3 col = raymarch(p,phat,cam);\n    \n    \n    fragColor = vec4(col,1.0);\n}\n\n\n\nvec3 raymarch(vec3 p, vec3 phat, camera cam){\n    float ndist = 0.0;\n    vec3 color = background;\n\n    for(int itr = 0; itr < MAX_ITER; itr++){\n        ndist = map(p);\n        p+=ndist*phat;\n        float hit = step(ndist,EPSILON);\n\n        \/\/This works but only when map uses a changing parameter.\n        if(ndist<=EPSILON){\n\t\t\tcolor = (vec3(1.0,0.0,0.0)*(1.0-distance(p,cam.loc)) + .16*BLUE);\n\t\t\tbreak;\n\t\t}\n\n        \/\/This method works with or without a changing map parameter but has it's own problems\n        \/\/color = inv(hit)*color + hit*(vec3(1.0,0.0,0.0)*(1.0-distance(p,cam.loc)) + .1);\n    }\n    return(color);\n}\n\nfloat map(vec3 p){\n    \n    vec3 sphereloc = vec3(0.0,0.0,.6);\n    vec3 cubeloc = vec3(-.55,0.0,0.4);\n    \n    \/\/HERE is where the issue arrises. When iGlobalTime is not used to change the position of one \n    \/\/of the objects overtime neither are rendered at all. \n    \n    #ifdef fail\n    float ndist = min(sphere(p,sphereloc,0.28),\n                      udBox(p*rotate3D(vec3(0.0,.5\/*iGlobalTime*\/,0.0)),cubeloc,vec3(.15)));                  \n    #endif\n    #ifdef work\n    float ndist = min(sphere(p,sphereloc,0.28),\n                      udBox(p*rotate3D(vec3(0.0,.5+(iGlobalTime*0.0001),0.0)),cubeloc,vec3(.15)));  \n    #endif\n    \n    return(ndist);\n}\n\n\n\/\/Switch the value of a \"floating point boolean\"\nfloat inv(float b){\n    return(1.0-b);\n}\n\nfloat sphere(vec3 p, vec3 loc, float r){\n    return(length(p-loc)-r);\n}\n\n\/\/Iq's box function\nfloat udBox( vec3 p, vec3 loc, vec3 b )\n{\n    return length(max(abs(p-loc)-b,0.0));\n}\n\n\ncamera newcam(vec3 loc){\n    camera rcam = camera(\n        vec3(0.0,1.0,0.0),\n        vec3(1.0,0.0,0.0),\n        vec3(0.0,0.0,1.0),\n        loc\n    );\n    return(rcam);\n}\n\nmat3 rotate3D(vec3 th){\n    mat3 rx = mat3(1.0,0.0,0.0,\n              0.0,cos(th.x),-sin(th.x),\n              0.0,sin(th.x),cos(th.x));\n\n    mat3 ry = mat3(cos(th.y),0.0,sin(th.y),\n              0.0,1.0,0.0,\n              -sin(th.y),0.0,cos(th.y));\n\n    mat3 rz = mat3(cos(th.z),-sin(th.z),0.0,\n              sin(th.z),cos(th.z),0.0,\n              0.0,0.0,1.0);\n    return(rx*ry*rz);\n}\n","name":"Image","description":"","type":"image"}]}}