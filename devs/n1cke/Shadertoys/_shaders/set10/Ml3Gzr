{"Shader":{"ver":"0.1","info":{"id":"Ml3Gzr","date":"1467666675","viewed":77,"name":"Sphere Marching Experiment","username":"culdevu","description":"Improving on iq's sphere marching methods.","likes":1,"published":3,"flags":0,"tags":["spheremarching"],"hasliked":0},"renderpass":[{"inputs":[{"id":1,"src":"\/presets\/tex00.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":6,"src":"\/presets\/tex05.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ distance functions\nfloat dPoint(vec3 p)\n{\n    float ret;\n    ret = length(p);\n    return ret;\n}\n\nfloat dPlane(vec3 p, vec3 norm)\n{\n    float ret;\n    ret = dot(-p, norm);\n    \n    return ret;\n}\n\nfloat dSphere(vec3 p, float rad)\n{\n    float ret;\n    float len = length(p);\n    ret = len - rad;\n    return ret;\n}\n\nfloat dCylinder(vec3 p, vec3 dir, float rad)\n{\n    float ret;\n    vec3 closest = p - dir * dot(p, dir);\n    float lenClosest = length(closest);\n    \n    ret = lenClosest - rad;\n    \n    return ret;\n}\n\n\/\/ main functions\nmat3 sphereAnim;\n\nvec2 rMax(vec2 r1, vec2 r2)\n{\n    if (r1.x < r2.x)\n        return r1;\n    return r2;\n}\n\nvec2 findNearest(vec3 o)\n{\n    vec2 ret;\n    \n    ret = vec2(dPlane(vec3(0, -2, 0) - o, vec3(0, 1, 0)), 0.0);\n    ret = rMax(ret, vec2(dPlane(vec3(-9, 0, 0) - o, vec3(1, 0, 0)), 0));\n    ret = rMax(ret, vec2(dPlane(vec3(9, 0, 0) - o, vec3(-1, 0, 0)), 0));\n    ret = rMax(ret, vec2(dPlane(vec3(0, 0, -9) - o, vec3(0, 0, 1)), 0));\n    ret = rMax(ret, vec2(dPlane(vec3(0, 0, 9) - o, vec3(0, 0, -1)), 0));\n    \n    ret = rMax(ret, vec2(dSphere(vec3(0, -1, 0) - o, 1.0), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(2.3, -1, 0) - o, 0.25), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(-2.3, -1, 0) - o, 0.25), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(0, -1, 2.3) - o, 0.25), 2));\n    ret = rMax(ret, vec2(dSphere(sphereAnim * vec3(0, -1, -2.3) - o, 0.25), 2));\n    \n    ret = rMax(ret, vec2(dCylinder(vec3(2, 0, 0) - o, vec3(0, 1, 0), 1.0), 1));\n    \n    ret.x = max(0.0, ret.x);\n    \n    \/\/return ret;\n    return ret;\n}\n\nvec3 calcNormal(vec3 pos)\n{\n\tvec3 eps = vec3( 0.001, 0.0, 0.0 );\n\tvec3 nor = vec3(\n\t    findNearest(pos+eps.xyy).x - findNearest(pos-eps.xyy).x,\n\t    findNearest(pos+eps.yxy).x - findNearest(pos-eps.yxy).x,\n\t    findNearest(pos+eps.yyx).x - findNearest(pos-eps.yyx).x);\n\treturn normalize(nor);\n}\n\nvec2 calcUV(vec3 pos, vec3 norm)\n{\n    vec3 temp = pos \/ 5.0;\n    vec3 temp2 = vec3(1, 0, 0);\n    \n    if (abs(dot(temp2, norm)) > 0.99)\n        temp2 = vec3(0, 1, 0);\n    \n    vec3 tang = cross(norm, temp2);\n    vec3 bivec = cross(norm, tang);\n    \n    return vec2(dot(temp, tang), dot(temp, bivec));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{   \n    vec2 uv = fragCoord.xy \/ iResolution.y;\n   \tvec3 pxlLoc = 2.0 * vec3(uv, 0) - vec3(iResolution.x \/ iResolution.y, 1, 0);\n    vec3 origin = vec3(0, 0, 2);\n    \n    float mouseX = iMouse.x \/ iResolution.x;\n    \n    \/\/ camera animation\n    {\n        float angle = 2.0 * 3.14159 * mouseX; \/\/0.5 * iGlobalTime;\n        mat3 rot = mat3(cos(angle), 0, -sin(angle),\n                        0, 1, 0,\n                        sin(angle), 0, cos(angle));\n        pxlLoc = rot * pxlLoc;\n        origin = rot * origin;\n   \n        \/\/vec3 animOffset = vec3(4.0 * cos(iGlobalTime), 0, 4.0 * sin(iGlobalTime));\n        vec3 animOffset = rot * vec3(0, 0, 5.0);\n        origin += animOffset;\n        pxlLoc += animOffset;\n    }\n    \n    \/\/ sphere animation\n    {\n        float angle = 1.9 * iGlobalTime;\n        sphereAnim = mat3(cos(-angle), 0, -sin(-angle),\n                          0, 1, 0,\n                          sin(-angle), 0, cos(-angle));\n    }\n    \n    \/\/------------------------------\n    \/\/ Ray tracing\n    \/\/------------------------------\n    vec3 ray = normalize(pxlLoc - origin);\n    vec2 t;\n    for (int i = 0; i < 32; ++i)\n    {\n        t = findNearest(origin);\n        origin += t.x * ray;\n    }\n    \n    \/\/ didn't hit anything\n    if (t.x > 10.0)\n    {\n        fragColor = vec4(0, 0, 0, 1);\n        return;\n    }\n    \n    vec3 intersect = origin;\n    vec3 norm = calcNormal(intersect);\n    vec2 uvCoord = calcUV(intersect, norm);\n    \n    \/\/------------------------------\n    \/\/ Lighting\n    \/\/------------------------------\n    float ambient = 1.0;\n    vec3 albedo;\n    \n    if (-0.5 < t.y && t.y < 0.5)\n        albedo = vec3(texture2D(iChannel0, uvCoord));\n    else if (0.5 < t.y && t.y < 1.5)\n        albedo = vec3(texture2D(iChannel1, uvCoord));\n    else if (1.5 < t.y && t.y < 2.5)\n        albedo = vec3(texture2D(iChannel2, uvCoord));\n    \n    \/\/ direct lighting\n    vec3 lightPos = vec3(2, 2, -5);\n    float flux = 9.0;\n    \n    vec3 rToLight = lightPos - intersect;\n    float dToLight = length(rToLight);\n    float directLight = flux * max(0.0, dot(rToLight, norm)) \/ (dToLight * dToLight);\n    \n    \/\/ shadow casting\n    float smallestDist = 8000.0;\n    float largestTolerance = 0.25;\n    vec3 sray = normalize(lightPos - intersect);\n    vec3 sorigin = intersect + sray * largestTolerance \/ max(0.001, dot(norm, sray));\n    for (int i = 1; i < 20; ++i)\n    {\n        t = findNearest(sorigin);\n        \n        float d = clamp(t.x, 0.0, dToLight - dot(sray, sorigin + t.x * sray - intersect));\n        sorigin += d * sray;\n        \n        if (smallestDist > t.x)\n            smallestDist = t.x;\n    }\n    \n    float penumbra = clamp(smallestDist \/ largestTolerance, 0.0, 1.0);\n    directLight *= penumbra;\n    \n    \/\/ AO\n    vec3 aoOrigin = intersect + 0.05 * norm;\n    vec3 aoRay = norm;\n    for (int i = 0; i < 4; ++i)\n    {\n        t = findNearest(aoOrigin);\n        aoOrigin += t.x * aoRay;\n    }\n    \n    float dist = max(0.0, min(0.8, dot(norm, aoOrigin - intersect)));\n    float ao = pow(dist \/ 0.8, 0.5);\n    \n    float ambientLight = ambient * ao;\n    \n    \/\/ final lighting\n    float irrad = directLight + ambientLight;\n    vec3 d = albedo * irrad;\n    d.xyz = d.xyz \/ (d.xyz + 1.0);\n    \n    fragColor = vec4(d.x, d.y, d.z, 1.0);\n}","name":"Image","description":"","type":"image"}]}}