{"Shader":{"ver":"0.1","info":{"id":"ldGGWw","date":"1455185029","viewed":696,"name":"Polynomial Horizon Tracing","username":"paniq","description":"a grazing-free closed-form solution for describing implicit surfaces with piecewise quadratic functions. This interactive test scene completes in up to 6 iterations. See https:\/\/gist.github.com\/paniq\/002ea2cc587b91ee02a2 for more info.","likes":16,"published":3,"flags":0,"tags":["raytracing","quadratic","polynomial","implicits","arithmetic"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ instant implicit surfaces via polynomial arithmetic\n\/\/ -- @paniq\n\n\/\/ uncomment to visualize various extra graphs\n\/\/ #define DEBUG_VIZ\n\/\/ rainbow zig zag line: actual trace, each hue is an iteration\n\/\/ red: zero line\n\/\/ white: f(x)\n\/\/ yellow: f'(x)\n\/\/ green: f''(x)\n\/\/ magenta: distance to next horizon (discontinuity)\n\/\/ cyan: distance to next root\n\n\/\/ uncomment to use hardmin optimization (broken)\n\/\/ #define USE_HARDMIN\n\n\/\/ undefine if you are running on glslsandbox.com\n\/\/ #define GLSLSANDBOX\n\n\/\/ polynomial arithmetic\n\/\/ describes piecewise univariate polynomial with degree 2\nstruct poly2 {\n    \/\/ the coefficients for f(x) = a0 * x^0 + a1 * x^1 + a2 * x^2\n    vec3 a;\n    \/\/ distance to horizon\n    float h;\n};\n\nconst float infinity = 1. \/ 0.;\n    \nbool hasaxis(poly2 f) {\n    return (f.h != infinity);\n}\n\npoly2 pa_init(float x) {\n    return poly2(vec3(x,1.0,0.0),infinity);\n}\n    \nfloat merge_axes(poly2 f, poly2 g) {\n    if (hasaxis(g)) {\n        if (hasaxis(f)) {\n            float a0 = min(f.h, g.h);\n            float a1 = max(f.h, g.h);\n            return ((a0 > 0.0)?a0:a1);\n        } else {\n            return g.h;\n\t\t}\n    }\n    return f.h;\n}\n\npoly2 pa_add(poly2 f, poly2 g) {\n    return poly2(f.a + g.a,merge_axes(f,g));\n}\npoly2 pa_add(poly2 f, float c) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_add(float c, poly2 f) {\n    return poly2(vec3(f.a[0] + c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(poly2 f, poly2 g) {\n    return poly2(f.a - g.a,merge_axes(f,g));\n}\npoly2 pa_sub(poly2 f, float c) {\n    return poly2(vec3(f.a[0] - c,f.a[1],f.a[2]),f.h);\n}\npoly2 pa_sub(float c, poly2 f) {\n    return poly2(vec3(c - f.a[0],-f.a[1],-f.a[2]),f.h);\n}\npoly2 pa_unm(poly2 f) {\n    return poly2(-f.a,f.h);\n}\n\n\/\/ {a0 a1 a2} * {b0 b1 b2}\n\/\/ = {a0*b0 (a0*b1 + a1*b0) (a0*b2 + a2*b0 + a1*b1) (a1*b2 + a2*b1) (a2*b2)}\n\/\/ the two new coefficients are truncated, so only linear\n\/\/ functions are going to work here reliably.\npoly2 pa_mul(poly2 f, poly2 g) {    \n    return poly2(vec3(\n    \tf.a[0] * g.a[0],\n\t    f.a[0] * g.a[1] + f.a[1] * g.a[0],\n        f.a[0] * g.a[2] + f.a[1] * g.a[1] + f.a[2] * g.a[0]\n        \/\/f.a[1] * g.a[2] + f.a[2] * g.a[1],\n        \/\/f.a[2] * g.a[2]\n        ), f.h);\n}\npoly2 pa_mul(poly2 f, float c) {\n    return poly2(f.a * c,f.h);\n}\npoly2 pa_mul(float c, poly2 f) {\n    return poly2(f.a * c,f.h);\n}\n\n\/\/ the two new coefficients are truncated, so only linear\n\/\/ functions are going to work here reliably.\npoly2 pa_pow2(poly2 f) {\n    return poly2(vec3(\n    \tf.a[0] * f.a[0],\n\t    2.0 * f.a[0] * f.a[1],\n        2.0 * f.a[0] * f.a[2] + f.a[1] * f.a[1]\n        \/\/2.0 * f.a[1] * f.a[2],\n        \/\/f.a[2] * f.a[2]\n        ), f.h);\n}\n\n\/\/ returns f(x), f'(x), f''(x)\nvec3 pa_f(vec3 a, float x) {\n    return vec3(\n        a[0] + (a[1] +       a[2] * x) * x,\n                a[1] + 2.0 * a[2] * x,\n                             a[2]);\n}\n\nfloat solve_quadratic(vec3 fa, float x) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    \/\/ the quadratic solve doesn't work for a=0\n    \/\/ so we need a branch here.\n    if (a == 0.0) {\n        return -c \/ b;\n    } else { \n        \/\/ (-b +- sqrt(b*b - 4.0*a*c)) \/ 2.0*a\n        float k = -0.5*b\/a;\n        float q = sqrt(k*k - c\/a);\n        float q0 = k - q;\n        float q1 = k + q;\n        \n        \/\/ pick the root right of x\n\t\treturn (q0 <= x)?q1:q0;\n    }\n}\n\nfloat solve_quadratic0(vec3 fa) {\n    float a = fa[2];\n    float b = fa[1];\n    float c = fa[0];\n\n    \/\/ the quadratic solve doesn't work for a=0\n    \/\/ so we need a branch here.\n    if (a == 0.0) {\n        return -c \/ b;\n    } else { \n        \/\/ (-b +- sqrt(b*b - 4.0*a*c)) \/ 2.0*a\n        float k = -0.5*b\/a;\n        float q = sqrt(k*k - c\/a);\n        \/\/ pick the closest root right of 0\n\t\treturn k + ((k <= q)?q:-q);\n    }\n}\n\nfloat solve_quadratic(poly2 f) {\n    return solve_quadratic0(f.a);\n}\n\n\/\/ returns the x position of the next root, where f(x) = 0\nfloat nextroot(poly2 f) {\n    return solve_quadratic(f);\n}\n\n\/\/ returns the position of the next event (root or start of new segment)\nfloat nextevent(poly2 f) {\n    float s = nextroot(f);\n    float h = (f.h <= 0.0)?infinity:f.h;\n    s = (s <= 0.0)?h:min(s,h);\n    return s;\n}\n\nfloat axis(poly2 f) {\n    return nextevent(f);\n}\n\npoly2 pa_abs(poly2 f) {\n    float s = ((f.a[0] < 0.0)?-1.0:1.0);\n    \n    f.h = axis(f);    \n    \n    return poly2(f.a * s, f.h);\n}\n\npoly2 pa_const(float c) {\n    return poly2(vec3(c,0.0,0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b) {\n    float a1 = (a.y - b.y)\/(a.x - b.x);\n\tfloat a0 = a.y - a1*a.x;\n    return poly2(vec3(a0, a1, 0.0), infinity);\n}\n\npoly2 pa_ipol(vec2 a, vec2 b, float k) {\n    float a2 = 0.5*k;\n    float aa2 = a2*a.x*a.x;\n    float a1 = (a.y - b.y + a2*b.x*b.x - aa2) \/ (a.x - b.x);\n    float a0 = a.y - a1*a.x - aa2;\n    return poly2(vec3(a0, a1, a2), infinity);\n}\n\npoly2 pa_min(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n}\n\npoly2 pa_max(poly2 f, poly2 g) {\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx > gx)?f.a:g.a, h);\n    \n}\n\n\/\/ the output can only be subject to more comparisons, but must not\n\/\/ be transformed further.\npoly2 pa_hardmin(poly2 f, poly2 g) {\n#ifdef USE_HARDMIN\n    float fe = nextevent(f);\n    float ge = nextevent(g);    \n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    bool fi = (fx < 0.0);\n    bool gi = (gx < 0.0);\n    \/\/ both outside\n    if (!fi && !gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    \/\/ both inside\n    } else if (fi && gi) {\n        if (fe <= ge)\n            return f;\n        else\n            return g;\n    } else {\n        return poly2((fx < gx)?f.a:g.a, h);\n    }    \n#else\n    float h = axis(pa_sub(f,g));\n    float fx = f.a[0];\n    float gx = g.a[0];\n    return poly2((fx < gx)?f.a:g.a, h);\n#endif\n}\n\n\/\/ the output can only be subject to more comparisons, but must not\n\/\/ be transformed further.\npoly2 pa_hardmax(poly2 f, poly2 g) {\n    return pa_unm(pa_hardmin(pa_unm(f),pa_unm(g)));\n}\n\n\/\/ can only be used once on flat surfaces reliably\n\/\/ appears to still work with more complex functions?\npoly2 pa_smin(poly2 a, poly2 b, float r) {\n    poly2 e = pa_min(\n        pa_max(\n            pa_add(\n                pa_unm(\n                    pa_abs(\n                        pa_sub(a, b))), r),\n            pa_const(0.0)),pa_const(r));\n    return pa_sub(pa_min(a, b), pa_mul(pa_pow2(e), 0.25 \/ r));\n}\n\npoly2 pa_smax(poly2 a, poly2 b, float r) {\n    return pa_unm(pa_smin(pa_unm(a),pa_unm(b),r));\n}\n\n\/\/ approximates blend with a quadratic patch, but\n\/\/ very buggy. avoid.\npoly2 pa_smin2(poly2 a, poly2 b, float r) {\n    float h = solve_quadratic0(pa_sub(a, b).a);\n    float x0 = h - r;\n    float x1 = h + r;\n    if (0.0 < x0) {\n        a.h = x0;\n        return a;\n    } else if (0.0 >= x1) {\n        return b;\n    } else {\n        vec3 ay0 = pa_f(a.a, x0);\n        vec3 by0 = pa_f(b.a, x0);\n        vec3 ay1 = pa_f(a.a, x1);\n        vec3 by1 = pa_f(b.a, x1);\n        vec3 y0 = (ay0.x < by0.x)?ay0:by0;\n        vec3 y1 = (ay1.x < by1.x)?ay1:by1;\n        poly2 m = pa_ipol(vec2(x0, y0.x), vec2(x1, y1.x), (y1.y - y0.y) \/ (x1 - x0));\n        m.h = x1;\n    \treturn m;\n    }\n}\n\n\/\/ s: width, height, depth, thickness\n\/\/ r: xy corner radius, z corner radius\n\/*\nDAValue sdSuperprim(DAVec3 p, vec4 s, vec2 r) {\n    DAValue dx = da_sub(da_abs(p.x),s.x);\n    DAValue dy = da_sub(da_abs(p.y),s.y);\n    DAValue dz = da_sub(da_abs(p.z),s.z);\n    DAValue q = \n       \tda_sub(\n            da_abs(\n                da_add(\n                    da_add(\n                        da_length(\n                            da_max(da_add(dx, r.x), 0.0),\n                            da_max(da_add(dy, r.x), 0.0)),\n                  \t\tda_min(-r.x,da_max(dx,dy))),\n                    s.w)), \n                s.w);\n    return da_add(\n                da_length(\n                    da_max(da_add(q, r.y),0.0),\n                    da_max(da_add(dz, r.y),0.0)),\n                da_min(-r.y,da_max(q,dz)));\n}\n*\/\n\n\/\/ interface\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ set color source for stroke \/ fill \/ clear\nvoid set_source_rgba(vec4 c);\nvoid set_source_rgba(float r, float g, float b, float a);\nvoid set_source_rgb(vec3 c);\nvoid set_source_rgb(float r, float g, float b);\nvoid set_source(sampler2D image);\n\/\/ if enabled, blends using premultiplied alpha instead of\n\/\/ regular alpha blending.\nvoid premultiply_alpha(bool enable);\n\n\/\/ set line width in normalized units for stroke\nvoid set_line_width(float w);\n\/\/ set line width in pixels for stroke\nvoid set_line_width_px(float w);\n\/\/ set blur strength for strokes in normalized units\nvoid set_blur(float b);\n\n\/\/ add a circle path at P with radius R\nvoid circle(vec2 p, float r);\nvoid circle(float x, float y, float r);\n\/\/ add a rectangle at O with size S\nvoid rectangle(vec2 o, vec2 s);\nvoid rectangle(float ox, float oy, float sx, float sy);\n\n\/\/ set starting point for curves and lines to P\nvoid move_to(vec2 p);\nvoid move_to(float x, float y);\n\/\/ draw straight line from starting point to P,\n\/\/ and set new starting point to P\nvoid line_to(vec2 p);\nvoid line_to(float x, float y);\n\/\/ draw quadratic bezier curve from starting point\n\/\/ over B1 to B2 and set new starting point to B2\nvoid curve_to(vec2 b1, vec2 b2);\nvoid curve_to(float b1x, float b1y, float b2x, float b2y);\n\/\/ connect current starting point with first\n\/\/ drawing point.\nvoid close_path();\n\n\/\/ clear screen in the current source color\nvoid clear();\n\/\/ fill paths and clear the path buffer\nvoid fill();\n\/\/ fill paths and preserve them for additional ops\nvoid fill_preserve();\n\/\/ stroke paths and clear the path buffer\nvoid stroke_preserve();\n\/\/ stroke paths and preserve them for additional ops\nvoid stroke();\n\/\/ clears the path buffer\nvoid new_path();\n\n\/\/ return rgb color for given hue (0..1)\nvec3 hue(float hue);\n\/\/ return rgb color for given hue, saturation and lightness\nvec3 hsl(float h, float s, float l);\nvec4 hsl(float h, float s, float l, float a);\n\n\/\/ rotate the context by A in radians\nvoid rotate(float a);\n\/\/ uniformly scale the context by S\nvoid scale(float s);\n\/\/ translate the context by offset P\nvoid translate(vec2 p);\nvoid translate(float x, float y);\n\/\/ clear all transformations for the active context\nvoid identity_matrix();\n\/\/ transform the active context by the given matrix\nvoid transform(mat3 mtx);\n\/\/ set the transformation matrix for the active context\nvoid set_matrix(mat3 mtx);\n\n\/\/ return the active query position for in_fill\/in_stroke\n\/\/ by default, this is the mouse position\nvec2 get_query();\n\/\/ set the query position for subsequent calls to\n\/\/ in_fill\/in_stroke; clears the query path\nvoid set_query(vec2 p);\n\/\/ true if the query position is inside the current path\nbool in_fill();\n\/\/ true if the query position is inside the current stroke\nbool in_stroke();\n\n\/\/ return the transformed coordinate of the current pixel\nvec2 get_origin();\n\/\/ draw a 1D graph from coordinate p, result f(p.x),\n\/\/ and gradient1D(f,p.x)\nvoid graph(vec2 p, float f_x, float df_x);\n\/\/ draw a 2D graph from coordinate p, result f(p),\n\/\/ and gradient2D(f,p)\nvoid graph(vec2 p, float f_x, vec2 df_x);\n\/\/ adds a custom distance field as path\n\/\/ this field will not be testable by queries\nvoid add_field(float c);\n\n\/\/ returns a gradient for 1D graph function f at position x\n#define gradient1D(f,x) (f(x + get_gradient_eps()) - f(x - get_gradient_eps())) \/ (2.0*get_gradient_eps())\n\/\/ returns a gradient for 2D graph function f at position x\n#define gradient2D(f,x) vec2(f(x + vec2(get_gradient_eps(),0.0)) - f(x - vec2(get_gradient_eps(),0.0)),f(x + vec2(0.0,get_gradient_eps())) - f(x - vec2(0.0,get_gradient_eps()))) \/ (2.0*get_gradient_eps())\n\/\/ draws a 1D graph at the current position\n#define graph1D(f) { vec2 pp = get_origin(); graph(pp, f(pp.x), gradient1D(f,pp.x)); }\n\/\/ draws a 2D graph at the current position\n#define graph2D(f) { vec2 pp = get_origin(); graph(pp, f(pp), gradient2D(f,pp)); }\n\n\/\/ represents the current drawing context\n\/\/ you usually don't need to change anything here\nstruct Context {\n    \/\/ screen position, query position\n    vec4 position;\n    vec2 shape;\n    float scale;\n    float line_width;\n    bool premultiply;\n    vec2 blur;\n    vec4 source;\n    vec2 start_pt;\n    vec2 last_pt;\n};\n    \n\/\/ save current source color, stroke width and starting\n\/\/ point from active context.\nContext save();\n\/\/ restore source color, stroke width and starting point\n\/\/ to a context previously returned by save()\nvoid restore(Context ctx);\n\n\/\/ draws a half-transparent debug gradient for the\n\/\/ active path\nvoid debug_gradient();\n\/\/ returns the gradient epsilon width\nfloat get_gradient_eps();\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid paint();\n\n\/\/ implementation\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 aspect = vec2(iResolution.x \/ iResolution.y, 1.0);\nvec2 uv;\nvec2 position;\nvec2 query_position;\nfloat ScreenH = min(iResolution.x,iResolution.y);\nfloat AA = ScreenH*0.4;\nfloat AAINV = 1.0 \/ AA;\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat det(vec2 a, vec2 b) { return a.x*b.y-b.x*a.y; }\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 hue(float hue) {\n    return clamp( \n        abs(mod(hue * 6.0 + vec3(0.0, 4.0, 2.0), 6.0) - 3.0) - 1.0, \n        0.0, 1.0);\n}\n\nvec3 hsl(float h, float s, float l) {\n    vec3 rgb = hue(h);\n    return l + s * (rgb - 0.5) * (1.0 - abs(2.0 * l - 1.0));\n}\n\nvec4 hsl(float h, float s, float l, float a) {\n    return vec4(hsl(h,s,l),a);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DEFAULT_SHAPE_V 1e+20\n\nContext _stack;\n\nvoid init (vec2 fragCoord) {\n    uv = fragCoord.xy \/ iResolution.xy;\n    vec2 m = iMouse.xy \/ iResolution.xy;\n    \n    position = (uv*2.0-1.0)*aspect;\n    query_position = (m*2.0-1.0)*aspect;\n    \n    _stack = Context(\n        vec4(position, query_position),\n        vec2(DEFAULT_SHAPE_V),\n        1.0,\n        1.0,\n        false,\n        vec2(0.0,1.0),\n        vec4(vec3(0.0),1.0),\n        vec2(0.0),\n        vec2(0.0)\n    );\n}\n\nvec3 _color = vec3(1.0);\n\nvec2 get_origin() {\n    return _stack.position.xy;\n}\n\nvec2 get_query() {\n    return _stack.position.zw;\n}\n\nvoid set_query(vec2 p) {\n    _stack.position.zw = p;\n    _stack.shape.y = DEFAULT_SHAPE_V;\n}\n\nContext save() {\n    return _stack;\n}\n\nvoid restore(Context ctx) {\n    \/\/ preserve shape\n    vec2 shape = _stack.shape;    \n    _stack = ctx;\n    _stack.shape = shape;\n}\n\nmat3 mat2x3_invert(mat3 s)\n{\n    float d = det(s[0].xy,s[1].xy);\n    d = (d != 0.0)?(1.0 \/ d):d;\n\n    return mat3(\n        s[1].y*d, -s[0].y*d, 0.0,\n        -s[1].x*d, s[0].x*d, 0.0,\n        det(s[1].xy,s[2].xy)*d,\n        det(s[2].xy,s[0].xy)*d,\n        1.0);\n}\n\nvoid identity_matrix() {\n    _stack.position = vec4(position, query_position);\n    _stack.scale = 1.0;\n}\n\nvoid set_matrix(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(position,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(query_position,1.0)).xy;    \n    _stack.scale = length(vec2(mtx[0].x,mtx[1].y));\n}\n\nvoid transform(mat3 mtx) {\n    mtx = mat2x3_invert(mtx);\n    _stack.position.xy = (mtx * vec3(_stack.position.xy,1.0)).xy;\n    _stack.position.zw = (mtx * vec3(_stack.position.zw,1.0)).xy;\n    vec2 u = vec2(mtx[0].x, mtx[1].x);\n    _stack.scale *= length(u);\n}\n\nvoid rotate(float a) {\n    float cs = cos(a), sn = sin(a);\n    transform(mat3(\n        cs, sn, 0.0,\n        -sn, cs, 0.0,\n        0.0, 0.0, 1.0));\n}\n\nvoid scale(float s) {\n    transform(mat3(s,0.0,0.0,0.0,s,0.0,0.0,0.0,1.0));\n}\n\nvoid translate(vec2 p) {\n    transform(mat3(1.0,0.0,0.0,0.0,1.0,0.0,p.x,p.y,1.0));\n}\n\nvoid translate(float x, float y) { translate(vec2(x,y)); }\n\nvoid clear() {\n    _color = mix(_color, _stack.source.rgb, _stack.source.a);\n}\n\nvoid blit(out vec4 dest) {\n    dest = vec4(_color, 1.0);\n}\n\nvoid blit(out vec3 dest) {\n    dest = _color;\n}\n\nvoid add_field(vec2 d) {\n    d = d \/ _stack.scale;\n    _stack.shape = min(_stack.shape, d);    \n}\n\nvoid add_field(float c) {\n    _stack.shape.x = min(_stack.shape.x, c);\n}\n\nvoid new_path() {\n    _stack.shape = vec2(DEFAULT_SHAPE_V);\n}\n\nvoid debug_gradient() {\n    _color = mix(_color, \n        hsl(_stack.shape.x * 6.0, \n            1.0, (_stack.shape.x>=0.0)?0.5:0.3), \n        0.5);\n}\n\nvoid set_blur(float b) {\n    if (b == 0.0) {\n        _stack.blur = vec2(0.0, 1.0);\n    } else {\n        _stack.blur = vec2(\n            b,\n            0.0);\n    }\n}\n\nvoid write_color(vec4 rgba, float w) {\n    float src_a = w * rgba.a;\n    float dst_a = _stack.premultiply?w:src_a;\n    _color = _color * (1.0 - src_a) + rgba.rgb * dst_a;    \n}\n\nvoid premultiply_alpha(bool enable) {\n    _stack.premultiply = enable;\n}\n\nfloat calc_aa_blur(float w) {\n    vec2 blur = _stack.blur;\n    w -= blur.x;\n    float wa = clamp(-w*AA, 0.0, 1.0);\n    float wb = clamp(-w \/ blur.x + blur.y, 0.0, 1.0);    \n\treturn wa * wb; \/\/min(wa,wb);    \n}\n\nvoid fill_preserve() {\n    write_color(_stack.source, calc_aa_blur(_stack.shape.x));\n}\n\nvoid fill() {\n    fill_preserve();\n    new_path();\n}\n\nvoid set_line_width(float w) {\n    _stack.line_width = w;\n}\n\nvoid set_line_width_px(float w) {\n    _stack.line_width = w*_stack.scale\/AA;\n}\n\nfloat get_gradient_eps() {\n    return _stack.scale\/AA;\n}\n\nvec2 stroke_shape() {\n    return abs(_stack.shape) - _stack.line_width\/_stack.scale;\n}\n\nvoid stroke_preserve() {\n    float w = stroke_shape().x;\n    write_color(_stack.source, calc_aa_blur(w));\n}\n\nvoid stroke() {\n    stroke_preserve();\n    new_path();\n}\n\nbool in_fill() {\n    return (_stack.shape.y <= 0.0);\n}\n\nbool in_stroke() {\n    float w = stroke_shape().y;\n    return (w <= 0.0);\n}\n\nvoid set_source_rgba(vec4 c) {\n    _stack.source = c;\n}\n\nvoid set_source_rgba(float r, float g, float b, float a) { \n    set_source_rgba(vec4(r,g,b,a)); }\n\nvoid set_source_rgb(vec3 c) {\n    set_source_rgba(vec4(c,1.0));\n}\n\nvoid set_source_rgb(float r, float g, float b) { set_source_rgb(vec3(r,g,b)); }\n\nvoid set_source(sampler2D image) {\n    set_source_rgba(texture2D(image, _stack.position.xy));\n}\n\nvec2 length2(vec4 a) {\n    return vec2(length(a.xy),length(a.zw));\n}\n\nvec2 dot2(vec4 a, vec2 b) {\n    return vec2(dot(a.xy,b),dot(a.zw,b));\n}\n\nvoid rectangle(vec2 o, vec2 s) {\n    s*=0.5;\n    o += s;\n    vec4 d = abs(o.xyxy - _stack.position) - s.xyxy;\n    vec4 dmin = min(d,0.0);\n    vec4 dmax = max(d,0.0);\n    add_field(max(dmin.xz, dmin.yw) + length2(dmax));\n}\n\nvoid rectangle(float ox, float oy, float sx, float sy) {\n    rectangle(vec2(ox,oy), vec2(sx,sy));\n}\n\nvoid circle(vec2 p, float r) {\n    vec4 c = _stack.position - p.xyxy;\n    add_field(vec2(length(c.xy),length(c.zw)) - r);\n}\nvoid circle(float x, float y, float r) { circle(vec2(x,y),r); }\n\nvoid move_to(vec2 p) {\n    _stack.start_pt = p;\n    _stack.last_pt = p;\n}\n\nvoid move_to(float x, float y) { move_to(vec2(x,y)); }\n\n\/\/ stroke only\nvoid line_to(vec2 p) {\n    vec4 pa = _stack.position - _stack.last_pt.xyxy;\n    vec2 ba = p - _stack.last_pt;\n    vec2 h = clamp(dot2(pa, ba)\/dot(ba,ba), 0.0, 1.0);\n    add_field(length2(pa - ba.xyxy*h.xxyy));\n    \n    _stack.last_pt = p;\n}\n\nvoid line_to(float x, float y) { line_to(vec2(x,y)); }\n\nvoid close_path() {\n    line_to(_stack.start_pt);\n}\n\n\/\/ from https:\/\/www.shadertoy.com\/view\/ltXSDB\n\n\/\/ Solve cubic equation for roots\nvec3 bezier_solve(float a, float b, float c) {\n    float p = b - a*a \/ 3.0, p3 = p*p*p;\n    float q = a * (2.0*a*a - 9.0*b) \/ 27.0 + c;\n    float d = q*q + 4.0*p3 \/ 27.0;\n    float offset = -a \/ 3.0;\n    if(d >= 0.0) { \n        float z = sqrt(d);\n        vec2 x = (vec2(z, -z) - q) \/ 2.0;\n        vec2 uv = sign(x)*pow(abs(x), vec2(1.0\/3.0));\n        return vec3(offset + uv.x + uv.y);\n    }\n    float v = acos(-sqrt(-27.0 \/ p3) * q \/ 2.0) \/ 3.0;\n    float m = cos(v), n = sin(v)*1.732050808;\n    return vec3(m + m, -n - m, n - m) * sqrt(-p \/ 3.0) + offset;\n}\n\n\/\/ Find the signed distance from a point to a quadratic bezier curve\nfloat bezier(vec2 A, vec2 B, vec2 C, vec2 p)\n{    \n    B = mix(B + vec2(1e-4), B, abs(sign(B * 2.0 - A - C)));\n    vec2 a = B - A, b = A - B * 2.0 + C, c = a * 2.0, d = A - p;\n    vec3 k = vec3(3.*dot(a,b),2.*dot(a,a)+dot(d,b),dot(d,a)) \/ dot(b,b);      \n    vec3 t = clamp(bezier_solve(k.x, k.y, k.z), 0.0, 1.0);\n    vec2 pos = A + (c + b*t.x)*t.x;\n    float dis = length(pos - p);\n    pos = A + (c + b*t.y)*t.y;\n    dis = min(dis, length(pos - p));\n    pos = A + (c + b*t.z)*t.z;\n    dis = min(dis, length(pos - p));\n    return dis; \/\/ * bezier_sign(A, B, C, p);\n}\n\nvoid curve_to(vec2 b1, vec2 b2) {\n    add_field(vec2(\n        bezier(_stack.last_pt, b1, b2, _stack.position.xy),\n        bezier(_stack.last_pt, b1, b2, _stack.position.zw)));\n\t_stack.last_pt = b2;\n}\n\nvoid curve_to(float b1x, float b1y, float b2x, float b2y) {\n    curve_to(vec2(b1x,b1y),vec2(b2x,b2y));\n}\n\nvoid graph(vec2 p, float f_x, float df_x) {\n    add_field(abs(f_x - p.y) \/ sqrt(1.0 + (df_x * df_x)));\n}\n\nvoid graph(vec2 p, float f_x, vec2 df_x) {\n    add_field(abs(f_x) \/ length(df_x));\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    init(fragCoord);\n    \n    paint();\n    \n    fragColor = vec4(_color.xyz, 1.0);\n}\n\n#ifdef GLSLSANDBOX\nvoid main() {\n    mainImage(gl_FragColor, gl_FragCoord.xy);\n}\n#endif\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n#define RO -1.5\n\nvec3 ro;\nvec3 rd;\n\npoly2 sphere(poly2 x, poly2 y, poly2 z, float r) {\n    return pa_sub(pa_add(pa_add(pa_pow2(x),pa_pow2(y)),pa_pow2(z)), r*r);\n}\n\npoly2 ellipsoid(poly2 x, poly2 y, poly2 z, vec3 r) {\n    poly2 ex = pa_pow2(pa_mul(x, 1.0\/r.x));\n    poly2 ey = pa_pow2(pa_mul(y, 1.0\/r.y));\n    poly2 ez = pa_pow2(pa_mul(z, 1.0\/r.z));\n    return pa_sub(pa_add(pa_add(ex,ey),ez), 1.0);\n}\n\npoly2 cube(poly2 x, poly2 y, poly2 z, float r) {\n\treturn pa_sub(pa_max(pa_max(pa_abs(x),pa_abs(y)),pa_abs(z)),r);\n}\n\npoly2 plane(poly2 x, poly2 y, poly2 z, vec4 n) {\n\treturn pa_sub(pa_add(pa_add(pa_mul(x,n.x),pa_mul(y,n.y)),pa_mul(z,n.z)),n.w);\n}\n\n\/*\n\/\/ not really a cone - todo :|\npoly2 cone(poly2 x, poly2 y, poly2 z, vec2 a, float l) {\n    return pa_max(\n        pa_add(pa_mul(pa_add(pa_pow2(x),pa_pow2(y)),a.x),\n               pa_mul(a.y, z)),z);\n}\n*\/\n\nvoid rotate(poly2 x, poly2 y, out poly2 rx, out poly2 ry, float a) {\n    float c = cos(a);\n    float s = sin(a);\n    rx = pa_sub(pa_mul(x,c),pa_mul(y,s));    \n    ry = pa_add(pa_mul(x,s),pa_mul(y,c));\n}\n\npoly2 pa_map(poly2 x, poly2 y, poly2 z) {\n\tpoly2 w = plane(x, y, z, vec4(0.0,0.0,1.0,-0.6));\n    poly2 vz = pa_sub(z,sin(iGlobalTime*0.3)*0.4);\n\tpoly2 s = sphere(pa_sub(x,1.0),y,vz, 0.5);\n\tpoly2 s2 = sphere(pa_sub(x,0.65),y,vz, 0.3);\n\t\/\/poly2 c = cone(pa_sub(x,-0.5),y,pa_sub(z,-0.3), normalize(vec2(1.0,0.5)), 0.5);\n    poly2 rx, rz;\n    rotate(pa_sub(x,-0.5),pa_sub(z,-0.5),rx,rz,iGlobalTime*0.5);\n    poly2 c = ellipsoid(rx,y,rz,vec3(0.2,0.5,0.5));\n    \n    \/\/ had to disable smin because there were small noticeable errors\n\treturn pa_hardmin(c, pa_hardmin(pa_hardmax(s,pa_unm(s2)),w));\n}\n\npoly2 pa_map(vec3 ro, vec3 rd, float t) {\n    poly2 dt = pa_init(t);\n    poly2 x = pa_add(ro.x, pa_mul(rd.x, dt));\n    poly2 y = pa_add(ro.y, pa_mul(rd.y, dt));\n    poly2 z = pa_add(ro.z, pa_mul(rd.z, dt));\n    return pa_map(x,y,z);    \n}\n\n\/\/ how to convert pa_map to a classic map function\n\/\/ t is the ray scalar\n\/\/ returns function value at that point, and distance\n\/\/ to next root or horizon\nvec3 map(vec3 ro, vec3 rd, float t) {\n    poly2 f = pa_map(ro, rd, t);\n    return vec3(f.a[0], nextevent(f), f.a[1]);\n}\n\n\/\/ for a 3d gradient, three map calls suffice\nvec3 grad(vec3 p) {\n\tvec2 d = vec2(0.0, 1e-3);\n    poly2 dx = pa_map(p - d.yxx, d.yxx, 2.0);\n    poly2 dy = pa_map(p - d.xyx, d.xyx, 2.0);\n    poly2 dz = pa_map(p - d.xxy, d.xxy, 2.0);\n    \/\/ second coefficient contains first derivative\n    return vec3(dx.a[1],dy.a[1],dz.a[1]) \/ 1e-3;\n}\n\nvec2 dist(vec3 p) {\n    poly2 d = pa_map(pa_const(p.x),pa_const(p.y),pa_const(p.z));\n    return vec2(d.a[0] \/ length(grad(p)),d.a[0]);\n}\n\nvec2 grad2d(vec3 p) {\n    return normalize(grad(p).xz);\n}\n\nvoid arrow(vec2 u, vec2 n) {\n\tvec2 o = vec2(n.y, -n.x);\n\tmove_to(u);\n\tu += n;\n\tline_to(u);\n\tmove_to(u - o*0.2);\n\tline_to(u + o*0.2);\n\tline_to(u + n*0.4);\n\tclose_path();\n}\n\nfloat rayf(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[0];\n}\n\nfloat rayff(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[1];\n}\n\nfloat rayfff(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);\n    return f.a[2];\n}\n\nfloat raynextroot(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);    \n    return nextroot(f);\n}\n\nfloat rayhorizon(float t) {\n    t = t - RO;\n    poly2 f = pa_map(ro, rd, t);    \n    return f.h;\n}\n\nfloat itercount(float maxt) {\n\tfloat precis = 0.01;\n\tfloat h = infinity;\n\tfloat t = 0.01;\n    float steps = 0.0;\n\tfor(int i = 0; i < 32; i++) {\n\t\tif(h <= precis || t > maxt) continue;\n        steps += 1.0;\n\t\tvec3 p = ro+rd*t;\n        vec3 d = map(ro, rd, t);\n        float w = t + d.y;\n        h = abs(d.x);\n\t\tt = w + 0.001;\n\t}    \n    return steps;\n}\n\n\/\/ maps n=0 to blue, n=1 to red, n=0.5 to green\nvec3 normhue(float n) {\n    return hue(0.66667 * (1.0 - clamp(n,0.0,1.0)));\n}\n        \nvoid paint() {\n\tvec2 ms = ((iMouse.xy\/iResolution.xy)*2.0-1.0) * aspect;\n\t\n    ro = vec3(RO,0.0,0.0);\n\n    \/\/ clear screen\n\t\n    vec3 tp = vec3(position.x,0.0,position.y);\n    rd = normalize(tp - ro);\n\t\n    float ic = itercount(length(tp - ro));\n    \n    set_source_rgb(normhue(ic\/6.0)*0.5);\n\tclear();\n\n\tset_line_width_px(1.3);\n\t\n    vec2 dd = dist(tp);\n\t_stack.shape.x = dd.x;\n\tset_source_rgb(hsl(0.6, 1.0, 0.7));\n\tstroke_preserve();\n\tset_source_rgba(hsl(0.6, 1.0, 0.7,0.5));\n\tfill();\n\t\n\tset_line_width_px(1.3);\n\tfor (int i = 0; i < 5; ++i) {\n\t\t_stack.shape.x = dd.y-float(i)*0.2;\n\t\tstroke();\n\t}\n\n\tset_source_rgb(vec3(1.0));\n\tset_line_width_px(1.3);\n\n\trd = normalize(vec3(ms.x, 0.0, ms.y) - ro);\n\t\n\tcircle(ro.xz, 0.02);\n\tfill();\n\n\tfloat maxt = 5.0;\n    \n\tfloat precis = 0.01;\n\tfloat h = infinity;\n\tfloat t = 0.01;\n\tfor(int i = 0; i < 32; i++) {\n\t\tif(h <= precis || t > maxt) continue;\n\t\tset_source_rgb(hsl(float(i)\/32.0, 1.0, 0.5));\n\t\tvec3 p = ro+rd*t;\n        vec3 d = map(ro, rd, t);\n        float ts = t + RO;\n        float w = t + d.y;\n        h = abs(d.x);\n        move_to(ts, 0.0);\n        line_to(ts, d.x);\n        line_to(ts + d.y, 0.0);\n        stroke();\n\t\tif (h <= precis) {\n            circle(ts, 0.0, 0.03);\n            fill();\n            continue;\n        }\n\t\tmove_to(p.xz);\n\t\tt = w + 0.001;\n\t\tline_to((ro+rd*t).xz);\n\t\tstroke();\n\t}\n\t\n\t\/\/ arrow\n    if (h <= precis) {\n        vec3 p = (ro+rd*t);\n        vec2 n = grad2d(p);\n        vec2 o = vec2(n.y, -n.x);\n        set_source_rgb(vec3(1.0));\t\n        arrow(p.xz, n*0.1);\n\t\tstroke();\n    }\n    \n    \/\/ \n\tset_source_rgba(vec4(0.0,0.0,0.0,0.5));\n\tclear();\n    \n    \/\/ draw zero crossing\n    move_to(-2.0,0.0);\n    line_to(2.0,0.0);\n    set_line_width_px(1.0);\n    set_source_rgb(vec3(1.0,0.0,0.0));\n    stroke();\n\n    #ifdef DEBUG_VIZ\n\n    \/\/ draw 1D graph of estimated distance to horizon\n    graph1D(rayhorizon);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0,0.0,1.0));\n    stroke();    \n\n    \/\/ draw 1D graph of estimated distance to root\n    graph1D(raynextroot);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(0.0,1.0,1.0));\n    stroke();    \n\n    \/\/ draw 1D graph of second derivative\n    graph1D(rayfff);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(0.5,1.0,0.0));\n    stroke();    \n\n    \/\/ draw 1D graph of first derivative\n    graph1D(rayff);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0,1.0,0.0));\n    stroke();    \n    \n    #endif\n\n    \/\/ draw 1D graph of ray distances\n    graph1D(rayf);\n    set_line_width_px(1.3);\n    set_source_rgb(vec3(1.0));\n    stroke();    \n    \n    \n}\n","name":"Image","description":"","type":"image"}]}}