{"Shader":{"ver":"0.1","info":{"id":"ldGGWm","date":"1454751609","viewed":274,"name":"Summed Area Table (SAT) Sampling","username":"tsone","description":"SAT building & minification. Left: SAT, right: mipmap. The SAT minification uses 9 tex samples. SAT can be built on CPU in 1 pass, O(N) but here it's built in 4 passes. For shadertoy preview to work, this SAT is dynamically rescaled to fit iResolution.y.","likes":3,"published":3,"flags":32,"tags":["texture","sampling","area","table","sat","summed","minification"],"hasliked":0},"renderpass":[{"inputs":[{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\nCopyright 2016 Valtteri \"tsone\" Heikkil\u00c3\u00a4\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\n*\/\n\n\n\/\/ NOTE: The shader is not optimized.\n\n\n\/\/ Texture size multiplier. See main(). (Also see 'Buf A' pass.)\nfloat M;\n\/\/ SAT size in texels (as stored in FB in iChannel0). See main().\nvec2 TS;\nvec2 INVTS;\n\nfloat length2(in vec2 v) { return dot(v, v); }\n\n\nvec3 SATSample(in vec2 p, in vec2 s, in vec2 fbres)\n{\n    vec2 sc = TS \/ fbres;\n    vec2 mx = (TS - .5) \/ TS;    \n    \n    float area = (4. * TS.x*TS.y) * s.x*s.y;\n    \n    p -= INVTS;\n    p -= floor(p - s);\n\n    vec2 it = floor(p + s);\n    \n    vec2 at = INVTS + p - s;\n    vec2 bt = INVTS + fract(p + vec2(s.x, -s.y));\n    vec2 ct = INVTS + fract(p + vec2(-s.x, s.y));\n    vec2 dt = INVTS + fract(p + s);\n    vec2 b2t = vec2(mx.x, bt.y);\n    vec2 c2t = vec2(ct.x, mx.y);\n    vec2 d2t = vec2(mx);\n    vec2 d3t = vec2(mx.x, dt.y);\n    vec2 d4t = vec2(dt.x, mx.y);\n\n\tvec3 a  = texture2D(iChannel0, sc*at ).rgb;\n\tvec3 b  = texture2D(iChannel0, sc*bt ).rgb;\n\tvec3 c  = texture2D(iChannel0, sc*ct ).rgb;\n\tvec3 d  = texture2D(iChannel0, sc*dt ).rgb;\n    vec3 b2 = texture2D(iChannel0, sc*b2t).rgb;\n    vec3 c2 = texture2D(iChannel0, sc*c2t).rgb;\n    vec3 d2 = texture2D(iChannel0, sc*d2t).rgb;\n    vec3 d3 = texture2D(iChannel0, sc*d3t).rgb;\n    vec3 d4 = texture2D(iChannel0, sc*d4t).rgb;\n    \n    return (a - (it.x*b2 + b) - (it.y*c2 + c)\n            + (it.x*it.y*d2 + it.x*d3 + it.y*d4 + d)) \/ area;\n}\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    M = max(ceil(iChannelResolution[1].y \/ iResolution.y), 1.);\n    TS = iChannelResolution[1].xy \/ M;\n    INVTS = 1. \/ TS;\n    \n    float ti = .2 * cos(.92*iGlobalTime);\n\n    \/\/ Intersect plane and rotate texture coordinates.\n    vec3 c = fragCoord.xyy - vec3(.5*iResolution.x, iResolution.yy);\n    c.y += 1. * iResolution.y;\n    c.xy \/= .02*c.z * iResolution.xy;\n    float sc = 6. - 2.*sin(iGlobalTime);\n    mat2 mat = sc * mat2(cos(ti), -sin(ti), sin(ti), cos(ti));\n    vec2 tc = mat * c.xy;\n    \n    \/\/ SAT sample using derivates.\n    vec2 dtc = fwidth(tc);\n    vec3 s = SATSample(tc, dtc, iChannelResolution[0].xy);\n    \n    \/\/ Mipmap sampling.\n    \/\/ TODO: Make sure mipmap uses anisotropic sampling.\n    float borderx = (iMouse.z > 0.) ? iMouse.x : .5*iResolution.x;\n    if (length2(dtc) < .25\/length(TS) || fragCoord.x > borderx) {\n        s = texture2D(iChannel1, tc).rgb;\n        s = pow(s, vec3(2.2)); \/\/ Gamma decode.\n    }\n    \n    \/\/ Border.\n    s.gb *= clamp(abs(fragCoord.x - borderx) \/ 2.5, .375, 1.);\n\n    \/\/ Gamma encode.\n    s = pow(s, vec3(1.\/2.2));\n    fragColor = vec4(s, 1.);    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/*\n\nCopyright 2016 Valtteri \"tsone\" Heikkil\u00c3\u00a4\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\n*\/\n\n\/*\n\nSAT generation is based on this article: \nhttp:\/\/developer.amd.com\/wordpress\/media\/2012\/10\/GDC2005_SATEnvironmentReflections.pdf\n\n*\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    \/\/ Resizing SAT to fit iResolution.y This is for shadertoy preview to work...\n    float M = max(ceil(iChannelResolution[0].y \/ iResolution.y), 1.);\n    \n    \/\/ Because bilinear interpolation is used to sample the SAT (in the 'Image' shader)\n    \/\/ we must extend the SAT texture size by 1 texel. This is done by offseting with -1.\n    vec2 uv = M * (fragCoord-1.) \/ iChannelResolution[0].xy;\n    float istep = M \/ iChannelResolution[0].x;\n    \n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        \/\/ Allow sampling below u=0 (as SAT is bilinearly sampled).\n        if (uv.x >= -M \/ iChannelResolution[0].x) {\n            vec3 s = texture2D(iChannel0, uv).rgb;\n            s = pow(s, vec3(2.2)); \/\/ Gamma decode.\n            sum += s;\n        }\n        uv.x -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"\/*\n\nCopyright 2016 Valtteri \"tsone\" Heikkil\u00c3\u00a4\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\n*\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord \/ iChannelResolution[0].xy;\n    float istep = 32. \/ iChannelResolution[0].x;\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        if (uv.x >= 0.) {\n            sum += texture2D(iChannel0, uv).rgb;\n        }\n        uv.x -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"\/*\n\nCopyright 2016 Valtteri \"tsone\" Heikkil\u00c3\u00a4\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\n*\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord \/ iChannelResolution[0].xy;\n    float istep = 1. \/ iChannelResolution[0].y;\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        if (uv.y >= .0) {\n            sum += texture2D(iChannel0, uv).rgb;\n        }\n        uv.y -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":260,"channel":0}],"code":"\/*\n\nCopyright 2016 Valtteri \"tsone\" Heikkil\u00c3\u00a4\n\nThis work is licensed under the Creative Commons Attribution 4.0 International License.\nTo view a copy of this license, visit http:\/\/creativecommons.org\/licenses\/by\/4.0\/\n\n*\/\n\nvoid mainImage(out vec4 fragColor, in vec2 fragCoord)\n{\n    vec2 uv = fragCoord \/ iChannelResolution[0].xy;\n    float istep = 32. \/ iChannelResolution[0].y;\n    vec3 sum = vec3(0.);\n    for (int i = 0; i < 32; ++i) {\n        if (uv.y >= 0.) {\n            sum += texture2D(iChannel0, uv).rgb;\n        }\n        uv.y -= istep;\n    }\n    fragColor = vec4(sum, 1.);\n}","name":"Buf D","description":"","type":"buffer"}]}}