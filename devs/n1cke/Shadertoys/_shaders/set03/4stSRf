{"Shader":{"ver":"0.1","info":{"id":"4stSRf","date":"1460628161","viewed":380,"name":"Curvature visualization","username":"sibaku","description":"This shader computes the curvature of a given distance function with auto diff and eigenvalue decomposition. Instructions and more info at the top of the code","likes":8,"published":3,"flags":48,"tags":["curvature","hessian","autodiff","eigenvalues","eigenvectors"],"hasliked":0},"renderpass":[{"inputs":[{"id":17,"src":"\/presets\/tex12.png","ctype":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/*************** INSTRUCTIONS **********************\n\/\/\n\/\/ Move the camera by dragging the mouse with left button held down\n\/\/\n\/\/ Change scenes by redifining SCENE with either TORUS, CYLINDER or CONE in Buf A\n\/\/\n\/\/ Uncomment #define USE_SECOND_DIRECTION to show second principal direction.\n\/\/ This is only working for the torus though, since the other two objects have directions\n\/\/ of zero curvature. In that case, the fallback is to the first direction\n\/\/\n\/\/***************************************************\n\n\/\/*************** INFO **********************\n\/\/\n\/\/ This demo will visualize the curvature of an object\n\/\/ For a real distance function f, ||grad f|| = 1 \n\/\/ The hessian can then be used to compute principal curvatures and -directions\n\/\/ Principal curvatures are the non-zero eigenvalues and the directions the corresponding\n\/\/ eigenvectors\n\/\/\n\/\/ Directions are then projected onto the screen yielding a 2D vector field\n\/\/ That is visualized with a simple version of a line integral convolution\n\/\/\n\/\/ Outlines are done with the distance gained from the distance field, so no sobel edge filter\n\/\/\n\/\/***************************************************\n\n\n\nconst int steps = 30;\nconst float size = 30.;\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uv = fragCoord\/iResolution.xy;\n    vec4 sample =texture2D(iChannel0,uv);\n    \n    \/\/ Background\n    if(sample.w < 1.)\n    {\n        fragColor = vec4(1.)*float(sample.z>0.07);\n        return;\n    }\n    vec2 dir = normalize(sample.xy);\n    \n    vec2 texelSize = 1.\/iResolution.xy;\n    \n    \/\/ Simple line integral convolution\n    \/\/ Step along line for some length and accumulate random weights\n    dir *= size*texelSize;\n    vec2 start = uv - 0.5*dir;\n    float val = 0.;\n    float realSteps = 0.;\n    vec2 pos = start;\n    for(int i = 0; i < steps; i++)\n    {\n        pos = start + dir*float(i)\/float(steps);\n        vec4 samplePos = texture2D(iChannel0,pos);\n        \n        val += texture2D(iChannel1,pos).r;\n    }\n    \n \n    float sat = float(val\/float(steps) );\n    fragColor = vec4(sat < 0.5);\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\/\/*************** INSTRUCTIONS **********************\n\/\/\n\/\/ Move the camera by dragging the mouse with left button held down\n\/\/\n\/\/ Change scenes by redifining SCENE with either TORUS, CYLINDER or CONE in Buf A\n\/\/\n\/\/ Uncomment #define USE_SECOND_DIRECTION to show second principal direction.\n\/\/ This is only working for the torus though, since the other two objects have directions\n\/\/ of zero curvature. In that case, the fallback is to the first direction\n\/\/\n\/\/***************************************************\n\n\/\/*************** INFO **********************\n\/\/\n\/\/ This demo will visualize the curvature of an object\n\/\/ For a real distance function f, ||grad f|| = 1 \n\/\/ The hessian can then be used to compute principal curvatures and -directions\n\/\/ Principal curvatures are the non-zero eigenvalues and the directions the corresponding\n\/\/ eigenvectors\n\/\/\n\/\/ The hessian is calculated exactly with automatic differentiation \n\/\/\n\/\/ Directions are then projected onto the screen yielding a 2D vector field\n\/\/ That is visualized with a simple version of a line integral convolution\n\/\/\n\/\/ Outlines are done with the distance gained from the distance field, so no sobel edge filter\n\/\/ \n\/\/\n\/\/***************************************************\n\n\n\n\n\/\/********************************************************************\n\/\/\n\/\/ Global defines\n\/\/ \n\/\/********************************************************************\n\n\/\/ Infinity\n#define AUTO_INFINITY 3.402823e+38\n\n\/\/#define USE_SECOND_DIRECTION\n\n#define TORUS 0\n#define CYLINDER 1\n#define CONE 2\n\n#define SCENE TORUS\nconst float eps = 0.0001;\n\n\/\/ Eigenvalue stuff\nconst float epsEig = 0.000001;\nconst int maxStepsEig = 20;\n\nconst float pi = 3.14159265359;\n\n\/\/ Maximum number of sphere trace steps\nconst int maxSteps = 150;\n\nbool isPressed(int key)\n{\n    float val = texture2D( iChannel0, vec2( (float(key)+0.5)\/256.0, 0.25 ) ).x;\n\treturn val > 0.5;\n}\n\nbool isToggled(int key)\n{\n    float val = texture2D( iChannel0, vec2( (float(key)+0.5)\/256.0, 0.75 ) ).x;\n\treturn val > 0.5;\n}\n\n\n\/\/ My very simple (and probably not overly great) forward-autodiff code from:\n\/\/ https:\/\/github.com\/sibaku\/glsl-autodiff\n\n\/\/********************************************************************\n\/\/\n\/\/ General functions\n\/\/ \n\/\/********************************************************************\n\nmat2 a_outerProduct(in vec2 a, in vec2 b)\n{\n\treturn mat2(a * b.x, a * b.y);\n}\n\nmat3 a_outerProduct(in vec3 a, in vec3 b)\n{\n\treturn mat3(a * b.x, a * b.y, a * b.z);\n}\n\nmat4 a_outerProduct(in vec4 a, in vec4 b)\n{\n\treturn mat4(a * b.x, a * b.y, a * b.z, a * b.w);\n}\n\n\/\/********************************************************************\n\/\/\n\/\/ Data structure for holding information for 3D Hessian calculation. Gradient is also included\n\/\/ \n\/\/********************************************************************\n\n\nstruct HessNum3\n{\n\tfloat val;\n\tvec3 g;\n\tmat3 h;\n};\n    \n    \/\/********************************************************************\n\/\/\n\/\/ 3D Hessian functions\n\/\/ \n\/\/********************************************************************\n\n\nHessNum3 a_constH3(in float val)\n{\n\treturn HessNum3(val, vec3(0.), mat3(0.));\n}\n\nHessNum3 neg(in HessNum3 a)\n{\n\treturn HessNum3(-a.val,-a.g,-a.h);\n}\n\nHessNum3 add(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val + b.val, a.g + b.g, a.h + b.h);\n}\nHessNum3 add(in HessNum3 a, in float b)\n{\n\treturn HessNum3(a.val + b, a.g , a.h);\n}\n\nHessNum3 add(in float a, in HessNum3 b)\n{\n\treturn HessNum3(b.val + a, b.g , b.h);\n}\n\nHessNum3 sub(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val - b.val, a.g - b.g, a.h - b.h);\n}\nHessNum3 sub(in HessNum3 a, in float b)\n{\n\treturn HessNum3(a.val - b, a.g , a.h);\n}\n\nHessNum3 sub(in float a, in HessNum3 b)\n{\n\treturn HessNum3(a - b.val, -b.g , -b.h);\n}\n\nHessNum3 mult(in HessNum3 a, in HessNum3 b)\n{\n\treturn HessNum3(a.val * b.val, b.val*a.g + a.val*b.g, b.val*a.h + a.val*b.h + a_outerProduct(a.g,b.g) + a_outerProduct(b.g,a.g));\n}\n\nHessNum3 mult(in HessNum3 a, float b)\n{\n\treturn HessNum3(a.val*b, a.g*b, a.h*b);\n}\n\nHessNum3 mult(in float a, in HessNum3 b)\n{\n\treturn HessNum3(b.val*a, b.g*a, b.h*a);\n}\n\nHessNum3 div(in HessNum3 a, in HessNum3 b)\n{\n\tHessNum3 r = HessNum3(a.val \/ b.val, a.g, a.h );\n\tr.g = r.g - r.val*b.g;\n\tr.g = r.g \/ b.val;\n\t\n\tr.h = r.h - r.val * b.h - a_outerProduct(r.g,b.g) - a_outerProduct(b.g,r.g);\n\tr.h = r.h \/ b.val;\n\t\n\treturn r;\n\t\n}\nHessNum3 div(in HessNum3 a, float b)\n{\n\treturn HessNum3(a.val\/b, a.g\/b, a.h\/b);\n}\n\nHessNum3 a_sin(in HessNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum3(s , c * a.g,  c * a.h - s * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_cos(in HessNum3 a)\n{\n\tfloat c = cos(a.val);\n\tfloat s = sin(a.val);\n\treturn HessNum3(c , -s * a.g,  -s * a.h - c * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_exp(in HessNum3 a)\n{\n\tfloat e = exp(a.val);\n\treturn HessNum3(e , e * a.g,  e * a.h + e * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_log(in HessNum3 a)\n{\n\tfloat ai = 1.\/a.val;\n\treturn HessNum3(log(a.val) , ai * a.g,  ai * a.h  - ai * ai * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_pow(in HessNum3 a, float k)\n{\n\tfloat ap = k*pow(a.val,k-1.);\n\treturn HessNum3(pow(a.val,k) , ap * a.g,  ap * a.h + (k-1.)*k*pow(a.val,k-2.) * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_abs(in HessNum3 a)\n{\n\tfloat l = abs(a.val);\n\tfloat lp = sign(a.val);\n\t\/\/ Probably better to always make this 0\n\tfloat lpp = a.val == 0. ? AUTO_INFINITY : 0.;\n\treturn HessNum3(l , lp * a.g,  lp * a.h + lpp * a_outerProduct(a.g,a.g));\n\n}\n\nHessNum3 a_sqrt(in HessNum3 a)\n{\n\tfloat as = sqrt(a.val);\n\tfloat asd = 1. \/ (2.*as);\n\tfloat asdd = -1.\/(4.*pow(a.val,3.\/2.));\n\treturn HessNum3(as,a.g*asd, asd * a.h + asdd * a_outerProduct(a.g,a.g)); \n}\n\nHessNum3 a_min(in HessNum3 a, in HessNum3 b)\n{\n \t\n    if(a.val < b.val)\n    {\n     \treturn a;   \n    }else\n        return b;\n}\n\nHessNum3 a_max(in HessNum3 a, in HessNum3 b)\n{\n \t\n    if(a.val > b.val)\n    {\n     \treturn a;   \n    }else\n        return b;\n}\n\n\n\/\/********************************************************************\n\/\/\n\/\/ Hessians\n\/\/ \n\/\/********************************************************************\n#define HESSIAN3(f,u,v,w,result) { vec3 uGrad = vec3(1.,0.,0.); HessNum3 uHessian = HessNum3(u,uGrad,mat3(0.)); vec3 vGrad = vec3(0.,1.,0.); HessNum3 vHessian = HessNum3(v,vGrad,mat3(0.)); vec3 wGrad = vec3(0.,0.,1.); HessNum3 wHessian = HessNum3(w,wGrad,mat3(0.)); result = f(uHessian,vHessian,wHessian);}\n\n\n\n\/\/********************************************************************\n\/\/\n\/\/ Non autodiff code\n\/\/ \n\/\/********************************************************************\n\n\/\/ Frobenius norm\nfloat frobenius(in mat3 m)\n{\n \treturn sqrt(dot(m[0],m[0]) + dot(m[1],m[1]) + dot(m[2],m[2]));   \n}\n\nfloat calcNorm(in mat3 m)\n{\n \n        return frobenius(m);\n}\n\n\n\n\/\/ Dist funcs taken from: \n\/\/ http:\/\/iquilezles.org\/www\/articles\/distfunctions\/distfunctions.htm\nfloat DE_Sphere(in vec3 p, in vec3 center, in float r)\n{\n \treturn length(p-center)-r;   \n}\n\nfloat DE_Box( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\n\nfloat DE_Torus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\n\nfloat DE_Cylinder( vec3 p)\n{\n  return length(p.xz)-1.;\n}\n\nfloat DE_Cone( vec3 p, vec2 c )\n{\n    \/\/ c must be normalized\n    float q = length(p.xz);\n    return dot(c,vec2(q,p.y));\n}\n\nfloat DE(vec3 p)\n{\n    #if SCENE == TORUS\n    \treturn DE_Torus(p,vec2(1.5,0.4));\n    #elif SCENE == CYLINDER\n    \treturn  DE_Cylinder( p);\n    #elif SCENE == CONE\n    \treturn DE_Cone(p,normalize(vec2(1.,1.)));\n    #else\n    \treturn min(DE_Torus(p,vec2(1.5,0.4)),DE_Sphere(p,vec3(0.),1.4));\n    #endif\n\t\/\/return DE_Sphere(p, vec3(0.),1.);\n    \/\/return  DE_Cylinder( p);\n    \n   \/\/ return DE_Torus(p,vec2(1.5,0.4));\n} \n\n\nHessNum3 DE_Sphere_Hess(in HessNum3 x, in HessNum3 y, in HessNum3 z)\n{\n    return sub(a_sqrt(add(add(mult(x,x),mult(y,y)),mult(z,z))),1.4);  \n}\nHessNum3 DE_Torus_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)\n{\n  HessNum3 x1 = sub(a_sqrt(add(mult(x,x),mult(z,z))),1.5);\n                \n  \n    \n  return sub(a_sqrt(add(mult(x1,x1),mult(y,y))),0.4);\n \n}\n\n\nHessNum3 DE_Cylinder_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)\n{\n    \n  return sub(a_sqrt(add(mult(x,x),mult(z,z))),1.);\n \n}\n\nHessNum3 DE_Cone_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)\n{\n  \n    HessNum3 q = a_sqrt(add(mult(x,x),mult(z,z)));\n    vec2 c = normalize(vec2(1.,1.));\n    \n    return add(mult(q,c.x),mult(y,c.y));\n                       \n \n}\n\n\nHessNum3 DE_Hess( in HessNum3 x, in HessNum3 y, in HessNum3 z)\n{\n \t#if SCENE == TORUS\n    \treturn DE_Torus_Hess(x,y,z);\n    #elif SCENE == CYLINDER\n    \treturn a_max(DE_Cylinder_Hess(x,y,z),DE_Sphere_Hess(x,y,z));\n    #elif SCENE == CONE\n    \t return DE_Cone_Hess(x,y,z);\n    #else\n   \t\t return a_min(DE_Torus_Hess(x,y,z),DE_Sphere_Hess(x,y,z));\n    #endif\n    \n}\n\nbool trace(in vec3 p, in vec3 dir, out float t, out float dist, out int steps,\n           out vec3 pos, out float minDist)\n{\n   \n    \n    \n    steps = 0;\n    dist = 10000.0;\n    t = 0.;\n    \n    float lastT = 0.;\n    minDist = dist;\n    for(int i= 0; i < maxSteps;i++)\n    {\n        pos = p+t*dir;\n     \tfloat d = DE(pos);\n        \n        \n        if(d < 0.)\n        {\n         \tt += 2.*eps;   \n            continue;\n            \n        }\n        if(d < eps)\n        {\n            dist = 0.;\n            minDist = 0.;\n           \/\/ t = lastT;\n            return true;\n        }\n        \n        lastT = t;\n        t += d;\n        dist = d;\n        steps++;\n        minDist = min(minDist,dist);\n        if(t > 100.)\n            return false;\n    }\n  \n    \n    return false;\n}\n\nfloat det(in mat3 m)\n{\n\treturn dot(m[0],cross(m[1],m[2]));\n}\nmat3 inv(in mat3 m)\n{\n \tvec3 v0 = cross(m[1],m[2]);\n    vec3 v1 = cross(m[2],m[0]);\n    vec3 v2 = cross(m[0],m[1]);\n    mat3 r = mat3(v0[0],v1[0],v2[0],\n                  v0[1],v1[1],v2[1],\n                  v0[2],v1[2],v2[2]);\n    \n    return r\/det(m);\n}\n\nfloat trace(in mat3 m)\n{\n    return m[0][0] + m[1][1] + m[2][2];   \n}\n\n\n\n\/\/********************************************************************\n\/\/\n\/\/ Givens Rotations\n\/\/\n\/\/ Mutliple methods since non-const indexing doesn't work\n\/\/ \n\/\/********************************************************************\n\n\n\/\/ p = 0\n\/\/ q = 1\nvoid givensAngle01(in mat3 m,out float c, out float s)\n{\n    float mpq = m[1][0];\n    \n    if(abs(mpq) < epsEig)\n    {\n\t\tc = 1.;\n        s = 0.;\n        return;\n    }\n    \n   \tfloat tau = (m[1][1]- m[0][0])\/(2.*m[1][0]);\n    \n    float tsqr = sqrt(1. + tau*tau);\n    \n    float t1 = tsqr  -tau;\n    float t2 = -tau - tsqr;\n    \n    float t= abs(t1) < abs(t2) ? t1 : t2;\n    \n    \n    c = 1.\/sqrt(1.+t*t);\n    s = t*c;\n}\n\nmat3 givensMatrix01(in mat3 m)\n{\n \tfloat c,s;\n    givensAngle01(m,c,s);\n    \n    return mat3(c,-s,0.,\n               s,c,0.,\n               0.,0.,1.);\n    \n}\n\n\n\/\/ p = 0\n\/\/ q = 2\nvoid givensAngle02(in mat3 m,out float c, out float s)\n{\n    float mpq = m[2][0];\n    \n    if(abs(mpq) < epsEig)\n    {\n\t\tc = 1.;\n        s = 0.;\n        return;\n    }\n    \n    float tau = (m[2][2]- m[0][0])\/(2.*m[2][0]);\n    \n    float tsqr = sqrt(1. + tau*tau);\n    \n    float t1 = tsqr  -tau;\n    float t2 = -tau - tsqr;\n    \n    float t= abs(t1) < abs(t2) ? t1 : t2;\n    \n    \n    c = 1.\/sqrt(1.+t*t);\n    s = t*c;\n}\n\nmat3 givensMatrix02(in mat3 m)\n{\n \tfloat c,s;\n    givensAngle02(m,c,s);\n    \n    return mat3(c,0.,-s,\n               0.,1.,0.,\n               s,0.,c);\n    \n}\n\n\n\/\/ p = 1\n\/\/ q = 2\nvoid givensAngle12(in mat3 m,out float c, out float s)\n{\n    float mpq = m[2][1];\n    \n    if(abs(mpq) < epsEig)\n    {\n\t\tc = 1.;\n        s = 0.;\n        return;\n    }\n    \n   \tfloat tau = (m[2][2]- m[1][1])\/(2.*m[2][1]);\n    \n    float tsqr = sqrt(1. + tau*tau);\n    \n    float t1 = tsqr  -tau;\n    float t2 = -tau - tsqr;\n    \n    float t= abs(t1) < abs(t2) ? t1 : t2;\n    \n    \n    c = 1.\/sqrt(1.+t*t);\n    s = t*c;\n}\n\nmat3 givensMatrix12(in mat3 m)\n{\n \tfloat c,s;\n    givensAngle12(m,c,s);\n    \n    return mat3(1.,0.,0.,\n               0.,c,-s,\n               0.,s,c);\n    \n}\n\n\nmat3 transpose(in mat3 m)\n{\n      return mat3(m[0][0], m[1][0], m[2][0],\n                m[0][1], m[1][1], m[2][1],\n                m[0][2], m[1][2], m[2][2]);\n}\n\n\/\/ Difference between diagonal matrix and non diagonal one \nfloat offError(in mat3 m)\n{\n    return abs(m[1][0]) +abs(m[0][1]) + abs(m[0][2]) + abs(m[2][0]) + abs(m[1][2]) + abs(m[2][1]);  \n}\n\n\n\n\/\/\n\/\/\n\/\/\n\/\/ Jacobi eigenvalue iteration using givens rotations\n\/\/ This will compute both eigenvalues and -vectors\n\/\/ Each givens rotation will zero an off diagonal element\n\/\/ Overall the off diagonals will tend to zero and the matrix\n\/\/ will become diagonal. \n\/\/\n\/\/ D is a more or less diagonal matrix with eigenvalues on the diagonal\n\/\/ V contains the eigenvectors in its cols\n\/\/\n\/\/\nvoid jacobiIteration(in mat3 m, out mat3 D, out mat3 V)\n{\n \n    D = m;\n    V = mat3(1.);\n    \n   \tmat3 g01,g02,g12;\n    \n    \n    for(int i = 0; i < maxStepsEig; i++)\n    {\n        g01 = givensMatrix01(D);\n    \n    \tD = transpose(g01)*D*g01;\n    \tV = V*g01;\n        \n        g02 = givensMatrix02(D);\n    \tD = transpose(g02)*D*g02;\n     \tV = V*g02;\n        \n   \t \tg12 = givensMatrix12(D);\n    \tD = transpose(g12)*D*g12;\n   \t\tV = V*g12;\n    \n     \n        if(offError(D) < epsEig)\n            break;\n    }\n       \n    \n    \n    \n}\n\n\/\/ Compute symmetry error -> hessians will be symmetric, if not, something went wrong\nfloat symmetricError(in mat3 m)\n{\n \treturn abs(m[0][1] - m[1][0]) + abs(m[0][2] - m[2][0]) + abs(m[1][2] - m[2][1]);   \n}\n\n\n\n\n\n\/\/\n\/\/\n\/\/ Sort curvatures to get highest and lowest non zero one\n\/\/\n\/\/\n#define isZero(v) (abs(v) < 10.*eps)\n#define isEqual(a,b) (abs(a-b) < 10.*eps)\nvoid getPrincipalCurvatures(in mat3 D, in mat3 V, \n                 out float k1, out vec3 p1, \n                 out float k2, out vec3 p2)\n{\n \tfloat l1 = D[0][0];\n    float l2 = D[1][1];\n    float l3 = D[2][2];\n    \n    vec3 v1 = V[0];\n    vec3 v2 = V[1];\n    vec3 v3 = V[2];\n    \n \tif(isZero(l1))\n    {\n     \tif((l2) > (l3))\n        {\n         \tk1 = l2;\n            p1 = v2;\n            \n            k2 = l3;\n            p2 = v3;\n        }else\n        {\n         \tk1 = l3;\n            p1 = v3;\n            \n            k2 = l2;\n            p2 = v2;\n        }\n    }else if(isZero(l2))\n    {\n     \tif((l1) > (l3))\n        {\n         \tk1 = l1;\n            p1 = v1;\n            \n            k2 = l3;\n            p2 = v3;\n        }else\n        {\n         \tk1 = l3;\n            p1 = v3;\n            \n            k2 = l1;\n            p2 = v1;\n        }\n    }else\n    {\n     \tif((l2) > ( l1))\n        {\n         \tk1 = l2;\n            p1 = v2;\n            \n            k2 = l1;\n            p2 = v1;\n        }else\n        {\n         \tk1 = l1;\n            p1 = v1;\n            \n            k2 = l2;\n            p2 = v2;\n        }\n    }\n   \n\n    if(isEqual(k1,k2))\n    {\n     \tp2 = p1;\n        k2 = k1;\n    }\n    \n\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tfragColor = vec4(uv,0.5+0.5*sin(iGlobalTime),1.0);\n\n\tvec2 camRes = vec2(2.,2.*iResolution.y\/iResolution.x);\n    float focal = 1.;\n    \n    vec3 eye;\n    vec3 center;\n    eye = vec3(3.4,2.,0.);\n    center = vec3(0.);\n    \n    \/\/ Camera thanks to stb\n    vec2 relativeMouse = iMouse.z <= 0. ? vec2(.5\/iResolution.xy) : iMouse.xy\/iResolution.xy-.5;\n\teye += vec3(0.,relativeMouse.yx)*12.;\n    \n    \n    \/\/ Camera coordinate system\n    \n    vec3 dir = normalize(center-eye);\n    \n    vec3 up = vec3(0.,1.,0.);\n    \n    vec3 right = normalize(cross(dir,up));\n    \n   \n    up = normalize(cross(right,dir));\n    vec3 lowerleft =  eye + focal*dir - right*camRes.x\/2.0 - up*camRes.y\/2.0;\n    \n    \/\/ starting position\n    vec3 p = lowerleft + uv.x*camRes.x*right + uv.y*camRes.y*up;\n    \n    \n    vec3 rayDir = normalize(p-eye);\n    \n    \/\/ Light currently not used -> didn't look too nice\n    vec3 LPos = vec3(0.,sin(2.*pi\/10.*iGlobalTime)*10.,cos(2.*pi\/10.*iGlobalTime)*10.);\n    \n    \n   \tvec3 col;\n    float t;\n    int steps;\n    float d;\n    vec3 P;\n    float minDist;\n    \n    \n    bool hit = trace(p,rayDir,t,d,steps,P,minDist);\n\n   \n    \/\/ alternatively store t in z to use sobel edge detection\n    \n    if(!hit)\n    {\n        col = vec3(1.,0.,minDist);\n        fragColor = vec4( col,0.);\n        return;\n    }\n    \n    \n    \/\/ compute hessian matrix\n    HessNum3 result;\n    \n    HESSIAN3(DE_Hess,P.x,P.y,P.z,result);\n  \n\n   \n    \n    \n    \/\/ D is diag with eigenvalues, V is eigenvector mat\n    mat3 D,V;\n    jacobiIteration(result.h,D,V);\n    \n    \/\/ eigenvalues of distancefield hessian are principal curvatures \n    \/\/ -> at most 2 non zero ones \n    \/\/ greatest one is max curvature, lowest is min \n    \/\/ eigenvectors correspond to directions of highest\/lowest curvature\n   \tfloat k1,k2;\n\tvec3  p1,p2;\n    \n    \/\/ sort\n    getPrincipalCurvatures(D,V,k1,p1,k2,p2);\n    \n\t\n\n    \/\/ Project onto screen\n    #ifdef USE_SECOND_DIRECTION\n    \t\/\/ Still use p1 if second direction has no curvature\n    \tif(isZero(k2))\n            p2 = p1;\n    \tvec3 curve = p2;\n    #else\n    \tif(isZero(k1))\n            p1 = right;\n    \tvec3 curve = p1;\n    #endif\n    vec3 curvProj = curve - dot(curve,dir)*dir;\n \n    float cx = dot(right,curvProj);\n    float cy = dot(up,curvProj);\n    \n    vec2 c = normalize(vec2(cx,cy));\n   \n    fragColor = vec4(c,minDist,1.);\n   \n}","name":"Buf A","description":"","type":"buffer"}]}}