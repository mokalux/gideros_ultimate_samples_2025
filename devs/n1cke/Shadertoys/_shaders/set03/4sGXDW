{"Shader":{"ver":"0.1","info":{"id":"4sGXDW","date":"1464284863","viewed":442,"name":"Plex","username":"GonzaloQuero","description":"Plexus-like shader. Movement of the vertices is based on the frequencies of the music.","likes":17,"published":3,"flags":0,"tags":["2d","particles"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":1,"sampler":{"filter":"linear","wrap":"repeat","vflip":"false","srgb":"false","internal":"byte"}},{"id":19,"src":"\/presets\/mzk02.mp3","ctype":"music","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"#define PNUM 32\n#define PRADIUS 0.005\n#define LINEWIDTH 0.003\n#define LINEFADEDISTANCE 0.05\n#define LINECOLOR vec4(0.4, 0.4, 1.0, 1.0) * 4.0\n\nfloat getFreq(int i) {\n    vec2 uv = vec2(float(i) \/ float(PNUM), 0.25);\n    float freq = texture2D(iChannel0, uv).x;\n    return freq * 0.6;\n}\n\nvec2 makePoint(int i)\n{\n   \tvec2 uv =  vec2(float(i) \/ 64.0, 0.3);\n    vec2 movement = texture2D(iChannel1, uv).xy;\n    movement *= vec2(2.0, 1.5);\n    movement += vec2(-0.5, -0.5);\n    movement *= 2.0 * texture2D(iChannel1, uv * sin(0.01 * iGlobalTime)).xy;\n  \treturn movement;\n}\n\nvoid getPoints(out vec2[PNUM] p)\n{\n    \/\/ First sample the sound texture.\n    for(int i = 0; i < PNUM; i++)\n    {\n         p[i] = makePoint(i);\n    }\n    \n    \/\/ Then sample the noise texture to help with cache locality.\n    for(int i = 0; i < PNUM; i++)\n    {\n        float freqx = getFreq(i);\n        float freqy = getFreq(PNUM - 1 - i);\n        p[i] = p[i]  + vec2(freqx, freqy);\n    }\n}\n\nfloat DistToLine(vec2 pt1, vec2 pt2, vec2 testPt)\n{\n  \tvec2 lineDir = pt2 - pt1;\n  \tvec2 perpDir = vec2(lineDir.y, -lineDir.x);\n  \tvec2 dirToPt1 = pt1 - testPt;\n    \n    float a = abs(distance(pt1, testPt));\n    float b = abs(distance(pt2, testPt));\n    float c = abs(distance(pt1, pt2));\n    \n    float agtc = sign(a - c);\n    float bgtc = sign(b - c);\n    \n    \/\/ a >= c || b >= c\n    float comp = clamp(max(agtc, bgtc), 0.0, 1.0);\n     \n  \treturn mix(abs(dot(normalize(perpDir), dirToPt1)), 1000.0, comp);\n}\n\nfloat inLine(vec2 testPoint, vec2 iPoint, vec2 jPoint)\n{\n  return LINEWIDTH - DistToLine(iPoint, jPoint, testPoint);\n}\n\nvec4 drawLines(vec2[PNUM] points, vec2 uv)\n{\n \tvec4 ret = vec4(0.0);\n    \n    for(int i = 0; i < PNUM; i++)\n    {\n        vec2 iPoint = points[i];\n        \n     \tfor(int j = 0; j < PNUM; j++)\n        {\n            vec2 jPoint = points[j];\n            \n            float lineDist = inLine(uv, iPoint, jPoint);\n            float lineMix = clamp(lineDist, 0.0, 1.0) \/ LINEWIDTH;\n\n            float fade = pow(LINEFADEDISTANCE \/ distance(iPoint, jPoint), 2.0);\n            vec4 possibleColor = LINECOLOR * clamp(fade, 0.0, 1.0);   \n            possibleColor = mix(vec4(0.0), possibleColor, lineMix);\n            ret = max(ret, possibleColor);\n        }\n    }\n    \n    return ret;\n}\n\nvec4 getFragColor(vec2[PNUM] points, vec2 uv)\n{\n    vec4 ret = drawLines(points, uv);    \n    return ret;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 points[PNUM];\n    getPoints(points);\n    \n    float x = fragCoord.x * (iResolution.x \/ iResolution.y) \/ iResolution.x;\n    float y = fragCoord.y \/ iResolution.y;\n    vec2 uv = vec2(x, y);\n    \n\tfragColor = getFragColor(points, uv);\n}","name":"Image","description":"","type":"image"}]}}