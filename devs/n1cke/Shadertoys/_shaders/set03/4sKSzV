{"Shader":{"ver":"0.1","info":{"id":"4sKSzV","date":"1465447716","viewed":414,"name":"NuitD'Automne","username":"Unix","description":"based on great work of Mu6k... Add some cloud and radial blur stuff ;-)\nmy music called Summertime was done for a unreleased iPhone game...\n\n","likes":20,"published":3,"flags":96,"tags":["terrain","raymarch","cloud","mountain","godray","unix"],"hasliked":0},"renderpass":[{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\n\nvec2 uvToTex(vec2 uv){\n\tuv.y-=0.05;\n\tuv *=iResolution.yy;\n    uv +=iResolution.xy*.5;\n    uv \/=iResolution.xy;\n    return uv;\n}\n\n\nvec3 sampleColor(vec2 uv){\n    return texture2D(iChannel2, uvToTex(uv)).xyz;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 uvo = fragCoord.xy \/ iResolution.xy;\n\tvec2 uv = (fragCoord.xy - iResolution.xy*.5) \/ iResolution.yy;\n    if (abs(uv.y)>.27) {\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    uv.y+=0.05;\n    \n    vec4 fb = texture2D(iChannel2, uvToTex(uv));\n    float td = fb.w;\n    \n    \n    vec3 acc = vec3(0);\n    float motionBlurAmp =0.04;\n    vec4 noise = texture2D(iChannel1, (fragCoord+floor(iGlobalTime*vec2(12.0,56.0)))\/64.0);    \n    acc += sampleColor(uv*((noise.x+2.0)\/td*motionBlurAmp+1.0))*vec3(.4,.1,.1);\n    acc += sampleColor(uv*((noise.y+1.0)\/td*motionBlurAmp+1.0))*vec3(.3,.3,.1);\n    acc += sampleColor(uv*((noise.z+0.0)\/td*motionBlurAmp+1.0))*vec3(.2,.4,.2);\n    acc += sampleColor(uv*((noise.w-1.0)\/td*motionBlurAmp+1.0))*vec3(.1,.3,.3);\n    acc += sampleColor(uv*((noise.x-2.0)\/td*motionBlurAmp+1.0))*vec3(.1,.1,.4);\n    \n    \n    vec3 c = acc.xyz;\n    c*=3.0;\n    c-=0.04;\n    c = max(c,.0);\n    c=(vec3(1.3,1.3,1.3)*c)\/(vec3(1)+c);\n    c=sqrt(max(c,.0));\n    c+=noise.xyz*0.01;    \n    vec2 offset = vec2(iGlobalTime*vec2(0.0,-1.0))\/4096.0;    \n    \n    c *= texture2D(iChannel3, uvToTex(uv+offset)).xyz*1.9;        \n    \/\/\/\/c *= texture2D(iChannel0, uvToTex(uv+offset)).xyz*1.5;    \n    vec3 c2 = texture2D(iChannel0, uvToTex(uv+offset)).xyz*1.3;        \n    c = (c*0.9)*(c2*c2)*1.4;\n    \n    fragColor = vec4(c, 1.0);\n    \n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":16,"src":"\/presets\/tex11.png","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":47,"src":"\/presets\/tex19.png","ctype":"texture","channel":0,"sampler":{"filter":"linear","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":3615,"src":"https:\/\/soundcloud.com\/imalogic\/summertime","ctype":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"\nfloat df ( in vec3 p){\n    float terra = p.y+1.0;\n    if (terra<1.0){\n        terra+=-texture2D(iChannel0, p.xz*0.04).r;\n        terra+=texture2D(iChannel0, p.xz*0.03+vec2(.4,.3)).r;\n        if (terra<0.1){\n        \tterra+=-pow(texture2D(iChannel0, p.xz*0.05+vec2(.4,.3)).r,4.0)*texture2D(iChannel0, p.xz*2.0).r*0.1;\n        }\n    }\n        \n    return terra;\n}\n\nvec3 nf(in vec3 p, in float theta){\n    vec2 e = vec2(theta, 0.0);\n    float c = df(p);\n    return normalize(vec3(c-df(p+e.xyy),c-df(p+e.yxy),c-df(p+e.yyx)));\n}\n#define LDIR normalize(vec3(9,-2,-6))\n#define ATMOS_COLOR vec3(.4,.5,.6)\n#define SUN_COLOR vec3(.9,.7,.4)\n\nvec3 skyColor(in vec3 d){\n    vec3 ldir = LDIR;\n    vec3 atmosColor = ATMOS_COLOR;\n    atmosColor = mix(atmosColor, vec3(.9,.5,.2), pow(dot(d,-ldir)*.5+.5,4.0));\n    atmosColor = mix(atmosColor, vec3(.9,.1,.1), pow(dot(d,-ldir)*.5+.5,16.0));\n    \/\/vec3 sun = SUN_COLOR*pow(dot(d,-ldir)*.5+.501,6960.0)*.03;\n\treturn (pow((1.0-abs(d.y)),2.0)*atmosColor);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec4 noise = texture2D(iChannel1, (fragCoord+floor(iGlobalTime*vec2(12.0,56.0)))\/64.0);\n\tvec2 uv = ((fragCoord.xy+noise.xy*0.5) - iResolution.xy*.5) \/ iResolution.yy;\n    if (abs(uv.y)>.27){\n        fragColor = vec4(0,0,0,1);\n        return;\n    }\n    uv.y+=0.05;\n    \n    vec3 pos = vec3(0,0,-4.0+iGlobalTime);\n    vec3 dir = normalize(vec3(uv, 1));\n    \n    float d,td=.0;\n\tint it;\n    for(int i=0; i<150; i++){\n    \td = df(pos);\n        pos += d*dir;\n        td += d;\n        it = i;\n        if (d<0.001||d>100.0) break;\n    }\n    float sky = min(max(d*.5,.0),1.0);\n    vec3 ldir = LDIR;\n    vec3 atmosColor = ATMOS_COLOR;\n    atmosColor = mix(atmosColor, vec3(.9,.5,.2), pow(dot(dir,-ldir)*.5+.5,4.0));\n    atmosColor = mix(atmosColor, vec3(.9,.1,.1), pow(dot(dir,-ldir)*.5+.5,16.0));\n    vec3 sunColor = SUN_COLOR;\n    \n    float wf = (-df(pos-vec3(-1,0,0))+df(pos))*0.5;\n    wf=min(max(wf,0.0),1.0);\n    float w = (-df(pos-vec3(0,0,-1))+df(pos))*0.5;\n    w=min(max(w,0.0),1.0);\n    vec3 normal = normalize(nf(pos, 0.1)+nf(pos, 0.025));\n    float wfa = (df(pos)-df(pos+normal))*.5;\n    wfa=min(max(wfa,0.0),1.0);\n    float wfa2 = pow(wfa*1.5,8.0);\n    wfa2=min(max(wfa2,0.0),1.0);\n    \n    vec3 c;\n    float fog = min(max((pow(-1.0+pos.y,2.0)),.0)*0.004*td+td*0.005+0.001,1.0);\n    c=vec3(fog);\n    vec3 albedo = mix(mix(vec3(.6,.5,.3), vec3(.4,.6,.2), wf), vec3(.3,.3,.3),w);\n    albedo = mix(albedo, vec3(.9,.9,.4), wfa2);\n \n    \n    \n    \n    float sunDiffuse = (max(dot(ldir,normal),.0));\n    sunDiffuse = min(sunDiffuse, df(pos-ldir*.5)*2.0);\n    sunDiffuse = min(sunDiffuse, df(pos-ldir));\n    sunDiffuse = max(.0,sunDiffuse);\n    float atmosDiffuse = (dot(vec3(0,-1,0),normal)*.5+.5);\n    atmosDiffuse *= wfa*0.125;\n    \n    c = sunDiffuse*albedo*sunColor + atmosDiffuse*albedo*atmosColor*wfa;\n    c = mix(c,atmosColor,fog);\n    c = mix(c, skyColor(dir),sky);\n    \n\tfragColor = vec4(c,td);\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":30,"src":"\/presets\/tex16.png","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"#define MIN_HEIGHT 2.0\n#define MAX_HEIGHT 4.5\n#define WIND vec2(0.2, 0.1)\n\nvec3 sundir = normalize(vec3(1.0,0.75,1.0));\n\nfloat noise( in vec3 x )\n{\n    vec3 f = fract(x);\n    vec3 p = floor(x);\n    f = f * f * (3.0 - 2.0 * f);\n    \n    p.xz += WIND * iGlobalTime;\n    vec2 uv = (p.xz + vec2(37.0, 17.0) * p.y) + f.xz;\n    vec2 rg = texture2D(iChannel0, (uv + 0.5)\/256.0, -100.0).yx;\n    return mix(rg.x, rg.y, f.y);\n}\n\nfloat fractal_noise(vec3 p)\n{\n    float f = 0.0;\n    \/\/ add animation\n    p = p + (vec3(0.5, 0.0, 0.3) * iGlobalTime\/10.);\n    p = p * 2.0;\n    f += 0.50000 * noise(p); p = 2.0 * p;\n    f += 0.25000 * noise(p); p = 2.0 * p;\n\tf += 0.12500 * noise(p); p = 2.0 * p;\n\tf += 0.06250 * noise(p); p = 2.0 * p;\n    f += 0.03125 * noise(p);\n    \n    return f;\n}\n\nfloat density(vec3 pos)\n{    \n    float den = 3.0 * fractal_noise(pos * 0.3) - 2.0 + (pos.y - MIN_HEIGHT);\n    float edge = 1.0 - smoothstep(MIN_HEIGHT, MAX_HEIGHT, pos.y);\n    edge *= edge;\n    den *= edge;\n    den = clamp(den, 0.0, 1.0);\n    \n    return den;\n}\n\nvec3 raymarching(vec3 ro, vec3 rd, float t, vec3 backCol)\n{   \n    vec4 sum = vec4(0.0);\n    vec3 pos = ro + rd * t;\n    for (int i = 0; i < 80; i++) {\n        if (sum.a > 0.99 || \n            pos.y < (MIN_HEIGHT-1.0) || \n            pos.y > (MAX_HEIGHT+1.0)) break;\n        \n        float den = density(pos);\n        \n        if (den > 0.01) {\n            float dif = clamp((den - density(pos+0.3*sundir))\/0.6, 0.0, 1.0);\n\n            vec3 lin = vec3(0.65,0.7,0.75)*1.5 + vec3(1.0, 0.6, 0.3)*dif;        \n            vec4 col = vec4( mix( vec3(1.0,0.95,0.8)*1.1, vec3(0.35,0.4,0.45), den), den);\n            col.rgb *= lin;\n\n            \/\/ front to back blending    \n            col.a *= 0.5;\n            col.rgb *= col.a;\n\n            sum = sum + col*(1.0 - sum.a); \n        }\n        \n        t += max(0.05, 0.02 * t);\n        pos = ro + rd * t;\n    }\n    \n    sum = clamp(sum, 0.0, 1.0);\n    \n    float h = rd.y;\n    sum.rgb = mix(sum.rgb, backCol, exp(-20.*h*h) );\n    \n    return mix(backCol, sum.xyz, sum.a);\n}\n\nfloat planeIntersect( vec3 ro, vec3 rd, float plane)\n{\n    float h = plane - ro.y;\n    return h\/rd.y;\n}\n\nmat3 setCamera(vec3 ro, vec3 ta, float cr)\n{\n\tvec3 cw = normalize(ta-ro);\n\tvec3 cp = vec3(sin(cr), cos(cr),0.0);\n\tvec3 cu = normalize( cross(cw,cp) );\n\tvec3 cv = normalize( cross(cu,cw) );\n    return mat3( cu, cv, cw );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 p = (2.0 * fragCoord.xy - iResolution.xy) \/ iResolution.yy;\n    vec2 mo = vec2(0.0);       \n    vec3 ro = vec3(0.0, 0.0, -2.0);\n    \n    \/\/ Rotate the camera\n    vec3 target = vec3(ro.x+10., 1.0+mo.y*3.0, ro.z);\n    \n    vec2 cossin = vec2(cos(mo.x), sin(mo.x));\n    mat3 rot = mat3(cossin.x, 0.0, -cossin.y,\n                   \t0.0, 1.0, 0.0,\n                   \tcossin.y, 0.0, cossin.x);\n    target = rot * (target - ro) + ro;\n    \n    \/\/ Compute the ray\n    vec3 rd = setCamera(ro, target, 0.0) * normalize(vec3(p.xy, 1.5));\n    \n    float dist = planeIntersect(ro, rd, MIN_HEIGHT);\n    \n    float sun = clamp(dot(sundir, rd), 0.0, 1.0);\n\tvec3 col = mix(vec3(0.78,0.78,0.7), vec3(0.3,0.4,0.5), p.y * 0.5 + 0.5);\n\tcol += 0.5*vec3(1.0,0.5,0.1)*pow(sun, 8.0);\n    \n    if (dist > 0.0) {\n        col = raymarching(ro, rd, dist, col);\n    }\n    \n    fragColor = vec4(col, 1.0);\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"\/*\n\tFull Scene Radial Blur\n\t----------------------\n\n\tRadial blur - as a postprocessing effect - is one of the first things I considered doing \n\twhen the multipass system came out. I've always loved this effect. Reminds me of the early \n\tdemos from Aardbei et al. \n\n\tAnyway, Shadertoy user, Passion, did a really cool radial blur on a field of spheres that\n\tinspired me to do my own. Radial blurs are pretty straight forward, but it was still\n    helpful to have Passion's version as a guide. \n\n    As for the radial blur process, there's not much to it. Start off at the pixel position, \n    then radiate outwards gathering up pixels with decreased weighting. The result is a\n\tblurring of the image in a radial fashion, strangely enough. :)\n\n\tInspired by:\n\n\tBlue Dream - Passion\n\thttps:\/\/www.shadertoy.com\/view\/MdG3RD\n\n\tRadial Blur - IQ\n\thttps:\/\/www.shadertoy.com\/view\/4sfGRn\n\n\tRays of Blinding Light - mu6k\n\thttps:\/\/www.shadertoy.com\/view\/lsf3Dn\n\n*\/\n\n\/\/ The radial blur section. Shadertoy user, Passion, did a good enough job, so I've used a\n\/\/ slightly trimmed down version of that. By the way, there are accumulative weighting \n\/\/ methods that do a slightly better job, but this method is good enough for this example.\n\n\n\/\/ Radial blur samples. More is always better, but there's frame rate to consider.\nconst float SAMPLES = 96.; \n\n\n\/\/ 2x1 hash. Used to jitter the samples.\nfloat hash( vec2 p ){ return fract(sin(dot(p, vec2(41, 289)))*45758.5453); }\n\n\n\/\/ Light offset.\n\/\/\n\/\/ I realized, after a while, that determining the correct light position doesn't help, since \n\/\/ radial blur doesn't really look right unless its focus point is within the screen boundaries, \n\/\/ whereas the light is often out of frame. Therefore, I decided to go for something that at \n\/\/ least gives the feel of following the light. In this case, I normalized the light position \n\/\/ and rotated it in unison with the camera rotation. Hacky, for sure, but who's checking? :)\nvec3 lOff(){    \n    \n    \/\/vec2 u = sin(vec2(1.57, 0) - iGlobalTime\/200.);\n    \/\/vec2 u = sin(vec2(1.27, -2.5));\n    vec2 u = vec2(2.447-iGlobalTime\/20., -0.161);\n    mat2 a = mat2(u, -u.y, u.x);\n    \n    vec3 l = normalize(vec3(-1.3+sin(iGlobalTime\/50.)*5., 1.0+cos(iGlobalTime\/50.)*5., 0.5+cos(iGlobalTime\/40.)*5.));\n    l.xz = a * l.xz;\n    l.xy = a * l.xy;\n    \n    return l;\n    \n}\n\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ){\n    \n    \/\/ Screen coordinates.\n    vec2 uv = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ Radial blur factors.\n    \/\/\n    \/\/ Falloff, as we radiate outwards.\n    float decay = 0.96; \n    \/\/ Controls the sample density, which in turn, controls the sample spread.\n    float density = 0.99; \n    \/\/ Sample weight. Decays as we radiate outwards.\n    float weight = 0.039; \n    \n    \/\/ Light offset. Kind of fake. See above.\n    vec3 l = lOff();\n    \n    \/\/ Offset texture position (uv - .5), offset again by the fake light movement.\n    \/\/ It's used to set the blur direction (a direction vector of sorts), and is used \n    \/\/ later to center the spotlight.\n    \/\/\n    \/\/ The range is centered on zero, which allows the accumulation to spread out in\n    \/\/ all directions. Ie; It's radial.\n    vec2 tuv =  uv - .5 - l.xy*.45;\n    \n    \/\/ Dividing the direction vector above by the sample number and a density factor\n    \/\/ which controls how far the blur spreads out. Higher density means a greater \n    \/\/ blur radius.\n    vec2 dTuv = tuv*density\/SAMPLES;\n    \n    \/\/ Grabbing a portion of the initial texture sample. Higher numbers will make the\n    \/\/ scene a little clearer, but I'm going for a bit of abstraction.\n    vec4 col = texture2D(iChannel0, uv.xy)*0.25;\n    \n    \/\/ Jittering, to get rid of banding. Vitally important when accumulating discontinuous \n    \/\/ samples, especially when only a few layers are being used.\n    uv += dTuv*(hash(uv.xy + fract(iGlobalTime))*2. - 1.);\n    \n    \/\/ The radial blur loop. Take a texture sample, move a little in the direction of\n    \/\/ the radial direction vector (dTuv) then take another, slightly less weighted,\n    \/\/ sample, add it to the total, then repeat the process until done.\n    for(float i=0.; i < SAMPLES; i++){\n    \n        uv -= dTuv;\n        vec4 cola = texture2D(iChannel0, uv);\n        if (cola.r<0.6 && cola.r>0.3) col += ((cola*cola) *weight );\n        else col += ((cola*cola) * weight*0.8);\n        weight *= decay;\n        \n    }\n    \n    \/\/ Multiplying the final color with a spotlight centered on the focal point of the radial\n    \/\/ blur. It's a nice finishing touch... that Passion came up with. If it's a good idea,\n    \/\/ it didn't come from me. :)\n    col *= (1. - dot(tuv, tuv)*.75);\n    fragColor = col;\n    \/\/ Smoothstepping the final color, just to bring it out a bit.\n    fragColor = smoothstep(0., 0.9, col);\n        \n}\n\n","name":"Buf C","description":"","type":"buffer"}]}}