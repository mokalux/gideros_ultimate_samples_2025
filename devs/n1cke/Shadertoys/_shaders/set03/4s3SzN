{"Shader":{"ver":"0.1","info":{"id":"4s3SzN","date":"1458145370","viewed":333,"name":"Earth Not Above","username":"NBickford","description":"A very ad-hoc gravitational raytracer made as part of my final project for UCLA's Math 32BH!\nThis Shadertoy prototype was developed as part of an article explaining gravitational raytracing, which you can find at http:\/\/bit.ly\/254or0K .","likes":6,"published":3,"flags":0,"tags":["raytracing","gravitational"],"hasliked":0},"renderpass":[{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"#define PI 3.1415926535\n\nfloat map(float v, float s){\n    return pow(clamp(0.5*v*s+0.5,0.,1.),2.2);\n}\n\nvec3 pimg(vec3 v, float p){\n    return vec3(pow(v.x,p),pow(v.y,p),pow(v.z,p));\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 uv = 2.0*(fragCoord.xy-0.5*iResolution.xy) \/ iResolution.x;\n    if(abs(uv.y)>0.4){\n        fragColor=vec4(0.,0.,0.,1.);\n        return;\n    }\n    uv*=6.0;\n    \n    \/\/Get spherical coordinates from the camera ray (uv.x,1,uv.y)\n    float cd=4.0+6.0*(1.0-pow(1.1,-(2.0*iGlobalTime+25.0) ));\n    vec3 nF=vec3(0.4,uv.x,uv.y);\n    \n    float beta=0.0;\n    float betap=sqrt(1.-beta*beta);\n    nF=vec3(-nF.x*betap,-nF.y+beta,-nF.z*betap)\/(1.-beta*nF.y);\n    nF*=3.0;\n    \n    \/\/For the moment, the camera's coordinates will be (cd,pi\/2,0), it'll be at\n    \/\/rest with respect to the FIDO (i.e. we're not accounting for special-relativistic\n    \/\/phenomena), and the ray's canonical momenta will be some multiple of nF.\n    \n    \/\/Initialize the state!\n    float a = 0.7;\n    \n    \n    float lr=cd;\n    float lo=PI*(0.49-0.007*pow(1.1,-iGlobalTime));\n    float lp=0.0+0.04*iGlobalTime;\n    float pr=nF.x;\n    float po=nF.z; \/\/we use 'o' because it looks like theta.\n    float b =(nF.y+3.);\n    \n    float dt=0.1;\n    \n    float drdz=0.0;\n    float dodz=0.0;\n    float dpdz=0.0;\n    float dprdz=0.0;\n    float dpodz=0.0;\n    \n    float q=po*po+cos(lo)*cos(lo)*(b*b\/(sin(lo)*sin(lo))-a*a); \n    \/\/vec2 maxP=vec2(0.0,0.0);\n    \n    int exitCode=0;\n    vec4 accCol=vec4(0.0,0.0,0.0,0.0);\n    \n    for(int i=0;i<300;i++){\n\n        \n        float co=cos(lo);\n        float so=sin(lo);\n        \n        float p2=lr*lr+a*a*co*co;\n        float D=lr*lr-2.0*lr+a*a;\n        \n        if(D*p2<0.0){\n            exitCode=1;\n            break;\n        }\n        \n        drdz=pr*D\/p2;\n        dodz=po\/p2;\n        \n        float P=lr*lr+a*a-a*b;\n        float R=P*P-D*((b-a)*(b-a)+q);\n        \n        dpdz=(a*(P-D)+b*D\/(so*so))\/(D*p2);\n        \/\/dprdz=(lr*D*(-R+pr*pr*D*D)+p2*p2*((1.0-lr)*R+D*(2.0*lr*P+(1.0-lr)*((b-a)*(b-a)+q+pr*pr*D))))\/(D*D*p2*p2);\n        dprdz=(lr*D*(-R+pr*pr*D*D)+p2*((1.0-lr)*R+D*(2.0*lr*P+(1.0-lr)*((b-a)*(b-a)+q+pr*pr*D))))\/(D*D*p2*p2);\n        dpodz=(b*b*D*p2*co\/(so*so*so)+a*a*so*co*(R-D*(pr*pr*D+p2)))\/(D*p2*p2);\n        \n        dt=min(min(0.5\/abs(dprdz),0.1\/abs(dpodz)),0.05+4.0*abs(mod(lo,PI)-0.5*PI) );\n        \n        \n        if(min(0.5\/abs(dprdz),0.5*.5\/abs(dpodz))<0.001){\n            exitCode=1;\n            break;\n        }\n        \n               dt=clamp(dt,0.005,0.5);\n        \n        if(lr+dt*drdz>16.0){\n            \/\/call it\n            dt=(16.0-lr)\/drdz;\n            lr+=dt*drdz;\n        \tlo+=dt*dodz;\n        \tlp+=dt*dpdz;\n            break;\n        }\n        \n        \/\/if we might have just passed through the ring\n        lo=mod(lo,PI);\n        \/\/lo+dt*dodz=Pi\/2\n        float tdt=(PI*0.5-lo)\/dodz;\n        if((-1.*dt<=tdt && tdt<=1.*dt) || (0.<=(PI*0.51-lo)\/dodz && (PI*0.49-lo)\/dodz<=dt)){\n            float tr=lr+tdt*drdz;\n            if(tr>3. && tr<8.){\n                \/*vec4 tex=texture2D(iChannel1,vec2(mod(lr,2.0)\/2.0,mod(lp,1.) ));\n                tex+=texture2D(iChannel1,vec2(mod(lr+0.01*drdz,2.0)\/2.0,mod(lp,1.) ));\n                tex.a*=0.2;\n                tex.a*=sqrt(smoothstep(4.,8.,tr)*smoothstep(8.,4.,tr));\n                tex.r=1.2*pow(tex.r,2.2);\n                tex.g=1.4*pow(tex.g,2.2);\n                tex.b=0.4*pow(tex.g,2.2);\n                tex.rgb*=2.0;*\/\n\n               \n                float lines=(smoothstep(3.,6.1,tr)*(1.-smoothstep(7.49,7.5,tr)));\n                lines*=texture2D(iChannel1,vec2(mod(tr+0.00*drdz,2.0)\/2.0,mod(lp,3.14)\/3.14 ),20.0*abs(dodz)).r;\n                \n                \n                lines*=(1.-smoothstep(0.0,0.001,mod(lp,0.2))*(1.-smoothstep(0.009,0.01,mod(lp,0.2))));\n                lines*=exp(abs(dodz))*exp(abs(dpdz))*exp(dt);\n                lines*=0.68;\n                lines=pow(lines,0.45);\n                \/\/lines*=2.0;\n                \n                \n                \n\t\t\t\tvec4 tex=vec4(lines*0.2+0.1*dpdz,lines*0.08,lines*0.04-0.3*dpdz,3.0*lines*exp(dt));\n                \n                accCol.rgb=(accCol.rgb+tex.rgb*tex.a*(1.-accCol.a));\n                accCol.a=accCol.a*(1.-tex.a);\n                \n                \n                \/\/break;\n            }\n        }\n        \n        lr+=dt*drdz;\n        lo+=dt*dodz;\n        lp+=dt*dpdz;\n        \n        pr+=dt*dprdz;\n        po+=dt*dpodz;\n        \n        \/\/if(dt*abs(dprdz)>maxP.x)maxP.x=dt*abs(dprdz);\n        \/\/if(dt*abs(dpodz)>maxP.y)maxP.y=dt*abs(dpodz);\n        \n        \/\/if(float(i)>iGlobalTime+20.0) break;\n        \n\n\n        \n    }\n    \n    \/\/fragColor=vec4(0.0,maxP.x,maxP.y,1.0);\n    \/*if(lr<2.0){\n        fragColor=vec4(0.,0.,0.,1.0);\n    }else{\n    \tfragColor=vec4(0.2*lr,(lo-PI*0.5)\/PI,lp\/PI,1.0);\n    }*\/\n    \n    \n    vec3 col;\n    if(exitCode==1){\n        col=vec3(0.,0.,0.);\n    }else{\n        \/*turn phi and theta into equiangular lookups *\/\n        float eqPhi=mod(lp,2.*PI);\n        eqPhi=(eqPhi\/(2.*PI));\n        float eqTheta=1.-mod(lo,PI);\n        eqTheta\/=PI;\n        col = texture2D(iChannel0,vec2(1.*eqPhi,2.*eqTheta)).rgb;\n        col.b*=1.0+2.0*dpdz;\n        col.r*=1.0-2.0*dpdz;\n        \/\/hey, color grading!\n        col.r*=0.8;\n        col.g*=0.8;\n        col*=(0.25*col.r+0.5*col.g+0.25*col.b);\n        col+=1.0*pimg(texture2D(iChannel0,vec2(4.*eqPhi,8.*eqTheta)).rgb,2.2);\n        \/\/col+=0.25*pimg(texture2D(iChannel0,vec2(16.*eqPhi,32.*eqTheta)).rgb,2.2);\n        \/\/col+=pimg(\n        \/\/col*=0.4;\n        \n    }\n    \n            \/\/blend in accCol\n        col=accCol.rgb+col*(1.-accCol.a);\n        \n    \n        col.r=0.5*col.r+0.5*smoothstep(0.,1.,col.r);\n        col.b=0.7*col.b+0.3*(col.b-smoothstep(0.,1.,col.b));\n        col.b+=0.1*col.r;\n        col.g*=0.8;\n    \n    col.b*=1.2;\n    col.g*=1.3;\n    \n    fragColor=vec4(col,1.0);\n    \n    \/*if(lr<0.5){\n        fragColor=vec4(0.0,0.0,0.0,1.0);\n        \/\/fragColor=vec4(lr,lo-PI*0.5,map(lp,10.0),1.0);\n    }else{\n        \n    }*\/\n\n    \n    \n    \n    \n\t\/\/fragColor = vec4(-nF,1.0);\n}","name":"Image","description":"","type":"image"}]}}