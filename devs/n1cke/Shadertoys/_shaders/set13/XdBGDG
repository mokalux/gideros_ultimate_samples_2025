{"Shader":{"ver":"0.1","info":{"id":"XdBGDG","date":"1392656432","viewed":458,"name":"Integer voxel traversal","username":"Dave_Hoskins","description":"I've always liked this old-school voxel stuff, but is it useful? There are no multiplies.\n2D integer voxel traversal culled from Graphics Gems IV:-\nhttp:\/\/read.pudn.com\/downloads56\/sourcecode\/graph\/texture_mapping\/194552\/gemsiv\/vox_traverse.c__.htm\n","likes":12,"published":3,"flags":0,"tags":["integervoxeltraversal"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Integer voxel traversal\n\n\/\/ From Graphics Gems IV \n\/\/ http:\/\/read.pudn.com\/downloads56\/sourcecode\/graph\/texture_mapping\/194552\/gemsiv\/vox_traverse.c__.htm\n\n\/\/===================================================================================\nfloat PlotPos(vec2 uv, vec2 pos)\n{\n\tvec2 pix = floor(uv \/ (1.0\/vec2(64.0)));\n\tif (pix == pos)\n\t{\n\t\treturn 1.0;\n\t}else\n\t{\n\t\treturn 0.0;\n\t}\n}\n\n\/\/ No multiplies!...\n\/\/===================================================================================\nfloat Line2D(vec2 uv, ivec2 pos, ivec2 dir)  \n{  \n\tfloat c = 0.0;\n\tivec2 s, a, b;\n\t\n\tif (dir.x > 0)\n\t\t{s.x =  1; a.x =  dir.x;}\n\telse\n\t\t{s.x = -1; a.x = -dir.x;}\n\tif (dir.y > 0)\n\t\t{s.y =  1; a.y =  dir.y;}\n\telse\n\t\t{s.y = -1; a.y = -dir.y;}\n\t\t\t\n\tb = a + a;\n\tint e   = a.y - a.x;\n    int len = a.x + a.y;\n\t\/\/ This is the traversal...\n    for (int i = 0; i < 30; i++)\n\t{\n\t\tif (i > len) break;\n\t\t\n\t\tc += PlotPos(uv, vec2(pos.xy));\n\t\tif (e < 0)\n\t\t{  \n\t\t\tpos.x += s.x;  \n\t\t\te += b.y;\n\t\t}  \n\t\telse\n\t\t{  \n\t\t\tpos.y += s.y;  \n\t\t\te -= b.x;\n\t\t}  \n    } \n\treturn c;\n} \n\n\/\/===================================================================================\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    fragCoord.xy+=.01;\n\tvec2 uv = fragCoord.xy \/ iResolution.xy;\n\tvec2 gr = fragCoord.xy;\n\tfloat aspect = iResolution.y \/ iResolution.x;\n\tvec2 pixel = vec2(1.0);\n\tuv.y    *= aspect;\n\tpixel.y *= aspect;\n\tgr.y    *= aspect;\n\n\tvec2 gridXY  = step(pixel,  mod(gr, iResolution.xy\/64.0)) * .75;\n\tvec3 backCol = vec3(gridXY.x*gridXY.y) * vec3(.5)+.15;\n\n\tfloat ang = iGlobalTime;\n\t\n\tivec2 beg = ivec2(31, 18);\n\tivec2 dxy = ivec2(floor(vec2(sin(ang)*16.5, cos(ang)*16.5)));\n\t\n\tfloat col = Line2D(uv, beg, dxy);\n\t\n\tfragColor = vec4(min(backCol+backCol*col*2.0, 1.0), 1.0);\n}\n\n\/\/===================================================================================\n\n\n\/\/ This is the 3D version, not tidy...\n\/\/float Line3D(vec2 uv, ivec3 pos, ivec3 d)  \n\/\/{  \n\/\/    int n;  \n\/\/\tivec3 a, b, s, e;\n\/\/\tfloat c = 0.0;\n\/\/\tvec3 dir = vec3(d);  \/\/ eeek! Didn't have integer maths routines so converted it to float type.\n\/\/  \n\/\/\ts = ivec3(sign(dir));\n\/\/\ta = ivec3(abs(dir));\n\/\/\tb = 2*a;\n\/\/    \/\/exy = a.y-a.x;   exz = a.z-a.x;   ezy = a.y-a.z;  \n\/\/\te = ivec3(a.y-a.x,  a.z-a.x, a.y-a.z);\n\/\/\t\n\/\/    n = a.x + a.y + a.z;  \n\/\/    for (int i = 0; i < 100; i++)\n\/\/\t{\n\/\/\t\tif (i > n ) continue;\n\/\/\t\t\n\/\/\t\tc += PlotPos(uv, vec2(pos.xy));  \n\/\/\t\tif ( e.x < 0 )\n\/\/\t\t{  \n\/\/\t\t\tif ( e.y < 0 )\n\/\/\t\t\t{  \n\/\/\t\t\t\tpos.x += s.x;  \n\/\/\t\t\t\te.x += b.y;\n\/\/\t\t\t\te.y += b.z;  \n\/\/\t\t\t}  \n\/\/\t\t\telse\n\/\/\t\t\t{  \n\/\/\t\t\t\tpos.z += s.z;  \n\/\/\t\t\t\te.y -= b.x;\n\/\/\t\t\t\te.z += b.y;  \n\/\/\t\t\t}  \n\/\/\t\t}  \n\/\/\t\telse\n\/\/\t\t{  \n\/\/\t\t\tif ( e.z < 0 )\n\/\/\t\t\t{  \n\/\/\t\t\t\tpos.z += s.z;  \n\/\/\t\t\t\te.y -= b.x;\n\/\/\t\t\t\te.z += b.y;  \n\/\/\t\t\t}  \n\/\/\t\t\telse\n\/\/\t\t\t{  \n\/\/\t\t\t\tpos.y += s.y;  \n\/\/\t\t\t\te.x -= b.x;\n\/\/\t\t\t\te.z -= b.z;  \n\/\/\t\t\t}  \n\/\/\t\t}  \n\/\/    } \n\/\/\treturn c;\n\/\/} \n","name":"Image","description":"","type":"image"}]}}