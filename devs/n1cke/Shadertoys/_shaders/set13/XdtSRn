{"Shader":{"ver":"0.1","info":{"id":"XdtSRn","date":"1457401059","viewed":3266,"name":"Light Propagation Volume","username":"paniq","description":"diffuse illumination with occlusion and infinite bounces using a single 32^3 light propagation volume. Implemented after http:\/\/www.crytek.com\/download\/Light_Propagation_Volumes.pdf","likes":87,"published":3,"flags":32,"tags":["illumination","bounce","occlusion","spherical","harmonics","radiosity","lpv"],"hasliked":0},"renderpass":[{"inputs":[{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/*\n\nalso helpful for reference:\nLight Propagation Volumes - Annotations, Andreas Kirsch (2010)\nhttp:\/\/blog.blackhc.net\/wp-content\/uploads\/2010\/07\/lpv-annotations.pdf\n\n*\/\nconst vec3 lpvsize = vec3(32.0);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) \/ s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) \/ s.x, s.y);\n    float z = (p - x - floor(y) * s.x) \/ (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvec4 sample_lpv(vec3 p, float channel) {\n    p = clamp(p * lpvsize, vec3(0.5), lpvsize - 0.5);\n    float posidx = packfragcoord3(p, lpvsize) + channel * (lpvsize.x * lpvsize.y * lpvsize.z);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) \/ iChannelResolution[0].xy;\n    return texture2D(iChannel0, uv);    \n}\n\nvec4 fetch_lpv(vec3 p, float channel) {\n    p = clamp(p, vec3(0.5), lpvsize - 0.5);\n    float posidx = packfragcoord3(p, lpvsize) + channel * (lpvsize.x * lpvsize.y * lpvsize.z);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) \/ iChannelResolution[0].xy;\n    return texture2D(iChannel0, uv);    \n}\n\nvec4 sample_lpv_trilin(vec3 p, float channel) {\n    p = clamp(p * lpvsize - 0.5, vec3(0.5), lpvsize - 0.5);\n    vec2 e = vec2(0.0,1.0);\n    vec4 p000 = fetch_lpv(p + e.xxx, channel);\n    vec4 p001 = fetch_lpv(p + e.xxy, channel);\n    vec4 p010 = fetch_lpv(p + e.xyx, channel);\n    vec4 p011 = fetch_lpv(p + e.xyy, channel);\n    vec4 p100 = fetch_lpv(p + e.yxx, channel);\n    vec4 p101 = fetch_lpv(p + e.yxy, channel);\n    vec4 p110 = fetch_lpv(p + e.yyx, channel);\n    vec4 p111 = fetch_lpv(p + e.yyy, channel);\n\n    vec3 w = fract(p);\n\n    vec3 q = 1.0 - w;\n\n    vec2 h = vec2(q.x,w.x);\n    vec4 k = vec4(h*q.y, h*w.y);\n    vec4 s = k * q.z;\n    vec4 t = k * w.z;\n        \n    return\n          p000*s.x + p100*s.y + p010*s.z + p110*s.w\n        + p001*t.x + p101*t.y + p011*t.z + p111*t.w;\n}\n\nvec4 sh_project(vec3 n) {\n    return vec4(\n        n,\n        0.57735026918963);\n}\n\nfloat sh_dot(vec4 a, vec4 b) {\n    return max(dot(a,b),0.0);\n}\n\n\/\/ 3 \/ (4 * pi)\nconst float m3div4pi = 0.23873241463784;\nfloat sh_flux(float d) {\n\treturn d * m3div4pi;\n}\n\n#ifndef M_DIVPI\n#define M_DIVPI 0.3183098861837907\n#endif\n\nfloat sh_shade(vec4 vL, vec4 vN) {\n    return sh_flux(sh_dot(vL, vN)) * M_DIVPI;\n}\n\n#define SHSharpness 1.0 \/\/ 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 \/ 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n\nfloat shade_probe(vec4 sh, vec4 shn) {\n    return sh_shade(sh_irradiance_probe(sh), shn);\n}\n\nvoid doCamera( out vec3 camPos, out vec3 camTar, in float time, in float mouseX )\n{\n    float an = 1.5 + sin(time * 0.37) * 0.4;\n\tcamPos = vec3(4.5*sin(an),2.0,4.5*cos(an));\n    camTar = vec3(0.0,0.0,0.0);\n}\n\nvec3 doBackground( void )\n{\n    return vec3( 0.0, 0.0, 0.0);\n}\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, float s )\n{\n  return length(p.xz)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+1.0,4.0);\n}\n\nvec2 doModel( vec3 p ) {\n\t\n    vec2 d = plane(p);\n    \n    vec2 q = vec2(sdSphere(p - vec3(0.0,0.0,-0.8), 1.0),1.0);\n    q = max2(q, vec2(-sdCylinder(p - vec3(0.0,0.0,-0.8), 0.5),2.0));\n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,2.2), vec3(2.0,4.0,0.3)),2.0));\n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,-2.2), vec3(2.0,4.0,0.3)),3.0));\n    d = min2(d, vec2(sdBox(p - vec3(-2.2,0.0,0.0), vec3(0.3,4.0,2.0)),1.0));\n    \n    q = vec2(sdBox(p - vec3(-1.0,0.0,1.0), vec3(0.5,1.0,0.5)),1.0);\n    q = max2(q, vec2(-sdBox(p - vec3(-0.5,0.5,0.5), vec3(0.5,0.7,0.5)),3.0));\n    \n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdTorus(p.yxz - vec3(-0.5 + sin(iGlobalTime*0.25),1.4,0.5), vec2(1.0, 0.3)),1.0));\n    \n    \/\/d = max2(d, vec2(p.y, 1.0));\n    \n    return d;\n}\n\nvec4 doMaterial( in vec3 pos, in vec3 nor )\n{\n    float k = doModel(pos).y;\n    \n    vec3 c = vec3(0.0);\n    \n    c = mix(c, vec3(1.0,1.0,1.0), float(k == 1.0));\n    c = mix(c, vec3(1.0,0.2,0.1), float(k == 2.0));\n    c = mix(c, vec3(0.1,0.3,1.0), float(k == 3.0));\n    c = mix(c, vec3(0.3,0.15,0.1), float(k == 4.0));\n    c = mix(c, vec3(0.4,1.0,0.1), float(k == 5.0));\n    \n    \n    return vec4(c,0.0);\n}\n\n\/\/------------------------------------------------------------------------\n\/\/ Lighting\n\/\/------------------------------------------------------------------------\nvec3 doLighting( in vec3 pos, in vec3 nor, in vec3 rd, in float dis, in vec4 mal )\n{\n    vec3 col = mal.rgb;\n    \n    vec3 tpos = ((pos - vec3(0.0,1.0,0.0)) \/ 2.5) * 0.5 + 0.5;\n    vec4 shr = sample_lpv_trilin(tpos, 0.0);\n    vec4 shg = sample_lpv_trilin(tpos, 1.0);\n    vec4 shb = sample_lpv_trilin(tpos, 2.0);\n    \n    vec4 shn = sh_project(-nor);\n    col *= vec3(shade_probe(shr, shn),shade_probe(shg, shn),shade_probe(shb, shn));\n    \/\/col = vec3(shade_probe(shb, shn));   \n\n    return col;\n}\n\nfloat calcIntersection( in vec3 ro, in vec3 rd )\n{\n\tconst float maxd = 20.0;           \/\/ max trace distance\n\tconst float precis = 0.001;        \/\/ precission of the intersection\n    float h = precis*2.0;\n    float t = 0.0;\n\tfloat res = -1.0;\n    for( int i=0; i<90; i++ )          \/\/ max number of raymarching iterations is 90\n    {\n        if( h<precis||t>maxd ) break;\n\t    h = doModel( ro+rd*t ).x;\n        t += h;\n    }\n\n    if( t<maxd ) res = t;\n    return res;\n}\n\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \/\/ precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\nmat3 calcLookAtMatrix( in vec3 ro, in vec3 ta, in float roll )\n{\n    vec3 ww = normalize( ta - ro );\n    vec3 uu = normalize( cross(ww,vec3(sin(roll),cos(roll),0.0) ) );\n    vec3 vv = normalize( cross(uu,ww));\n    return mat3( uu, vv, ww );\n}\n\nvec3 ff_filmic_gamma3(vec3 linear) {\n    vec3 x = max(vec3(0.0), linear-0.004);\n    return (x*(x*6.2+0.5))\/(x*(x*6.2+1.7)+0.06);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 p = (-iResolution.xy + 2.0*fragCoord.xy)\/iResolution.y;\n    vec2 m = iMouse.xy\/iResolution.xy;\n\n    \/\/-----------------------------------------------------\n    \/\/ camera\n    \/\/-----------------------------------------------------\n    \n    \/\/ camera movement\n    vec3 ro, ta;\n    doCamera( ro, ta, iGlobalTime, m.x );\n    \/\/doCamera( ro, ta, 3.0, 0.0 );\n\n    \/\/ camera matrix\n    mat3 camMat = calcLookAtMatrix( ro, ta, 0.0 );  \/\/ 0.0 is the camera roll\n    \n\t\/\/ create view ray\n\tvec3 rd = normalize( camMat * vec3(p.xy,2.0) ); \/\/ 2.0 is the lens length\n\n    \/\/-----------------------------------------------------\n\t\/\/ render\n    \/\/-----------------------------------------------------\n\n\tvec3 col = doBackground();\n\n\t\/\/ raymarch\n    float t = calcIntersection( ro, rd );\n    if( t>-0.5 )\n    {\n        \/\/ geometry\n        vec3 pos = ro + t*rd;\n        vec3 nor = calcNormal(pos);\n\n        \/\/ materials\n        vec4 mal = doMaterial( pos, nor );\n\n        col = doLighting( pos, nor, rd, t, mal );\n\t}\n\n\t\/\/-----------------------------------------------------\n\t\/\/ postprocessing\n    \/\/-----------------------------------------------------\n    \/\/ gamma\n\tcol = ff_filmic_gamma3(col); \/\/pow( clamp(col,0.0,1.0), vec3(0.4545) );\n\t   \n    fragColor = vec4( col, 1.0 );\n}","name":"Image","description":"","type":"image"},{"inputs":[],"outputs":[{"id":257,"channel":0}],"code":"\/\/ geometry volume (stores occlusion coefficients)\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, float s )\n{\n  return length(p.xz)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+1.0,4.0);\n}\n\nvec2 doModel( vec3 p ) {\n\t\n    vec2 d = plane(p);\n    \n    vec2 q = vec2(sdSphere(p - vec3(0.0,0.0,-0.8), 1.0),1.0);\n    q = max2(q, vec2(-sdCylinder(p - vec3(0.0,0.0,-0.8), 0.5),2.0));\n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,2.2), vec3(2.0,4.0,0.3)),2.0));\n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,-2.2), vec3(2.0,4.0,0.3)),3.0));\n    d = min2(d, vec2(sdBox(p - vec3(-2.2,0.0,0.0), vec3(0.3,4.0,2.0)),1.0));\n    \n    q = vec2(sdBox(p - vec3(-1.0,0.0,1.0), vec3(0.5,1.0,0.5)),1.0);\n    q = max2(q, vec2(-sdBox(p - vec3(-0.5,0.5,0.5), vec3(0.5,0.7,0.5)),3.0));\n    \n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdTorus(p.yxz - vec3(-0.5 + sin(iGlobalTime*0.25),1.4,0.5), vec2(1.0, 0.3)),1.0));\n    \n    return d;\n}\nvec3 calcNormal( in vec3 pos )\n{\n    const float eps = 0.002;             \/\/ precision of the normal computation\n\n    const vec3 v1 = vec3( 1.0,-1.0,-1.0);\n    const vec3 v2 = vec3(-1.0,-1.0, 1.0);\n    const vec3 v3 = vec3(-1.0, 1.0,-1.0);\n    const vec3 v4 = vec3( 1.0, 1.0, 1.0);\n\n\treturn normalize( v1*doModel( pos + v1*eps ).x + \n\t\t\t\t\t  v2*doModel( pos + v2*eps ).x + \n\t\t\t\t\t  v3*doModel( pos + v3*eps ).x + \n\t\t\t\t\t  v4*doModel( pos + v4*eps ).x );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nconst vec3 lpvsize = vec3(32.0);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) \/ s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) \/ s.x, s.y);\n    float z = (p - x - floor(y) * s.x) \/ (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvec4 sh_project(vec3 n) {\n    return vec4(\n        n,\n        0.57735026918963);\n}\n\n#define M_PI 3.1415926535898\nfloat sh_dot(vec4 a, vec4 b) {\n    return max(dot(a,b),0.0) * 3.0 \/ (4.0 * M_PI);\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    if (posidx < (lpvsize.x * lpvsize.y * lpvsize.z)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        float offset = -0.5;\n        vec3 tpos = (pos + offset) \/ lpvsize;\n        vec3 wpos = (tpos * 2.0 - 1.0) * 2.5 + vec3(0.0,1.0,0.0);\n        float r = 1.0 * 1.7320508075689 \/ lpvsize.x;\n\t\tfloat d = doModel(wpos).x;\n        \n        if (d > r) {\n\t        fragColor = vec4(0.0);\n        } else {\n            float opacity = 1.0 - max(d, 0.0) \/ r;\n            fragColor = sh_project(calcNormal(wpos)) * opacity;\n        }\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buf A","description":"","type":"buffer"},{"inputs":[],"outputs":[{"id":258,"channel":0}],"code":"\/\/ albedo volume for bounces\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec2 min2(vec2 a, vec2 b) {\n    return (a.x <= b.x)?a:b;\n}\n\nvec2 max2(vec2 a, vec2 b) {\n    return (a.x > b.x)?a:b;\n}\n\nfloat sdSphere( vec3 p, float s )\n{\n  return length(p)-s;\n}\n\nfloat sdCylinder( vec3 p, float s )\n{\n  return length(p.xz)-s;\n}\n\nfloat sdTorus( vec3 p, vec2 t )\n{\n  vec2 q = vec2(length(p.xz)-t.x,p.y);\n  return length(q)-t.y;\n}\n\nfloat sdBox( vec3 p, vec3 b )\n{\n  vec3 d = abs(p) - b;\n  return min(max(d.x,max(d.y,d.z)),0.0) +\n         length(max(d,0.0));\n}\n\nvec2 plane( vec3 p) {\n    return vec2(p.y+1.0,4.0);\n}\n\nvec2 doModel( vec3 p ) {\n\t\n    vec2 d = plane(p);\n    \n    vec2 q = vec2(sdSphere(p - vec3(0.0,0.0,-0.8), 1.0),1.0);\n    q = max2(q, vec2(-sdCylinder(p - vec3(0.0,0.0,-0.8), 0.5),2.0));\n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,2.2), vec3(2.0,4.0,0.3)),2.0));\n    d = min2(d, vec2(sdBox(p - vec3(0.0,0.0,-2.2), vec3(2.0,4.0,0.3)),3.0));\n    d = min2(d, vec2(sdBox(p - vec3(-2.2,0.0,0.0), vec3(0.3,4.0,2.0)),1.0));\n    \n    q = vec2(sdBox(p - vec3(-1.0,0.0,1.0), vec3(0.5,1.0,0.5)),1.0);\n    q = max2(q, vec2(-sdBox(p - vec3(-0.5,0.5,0.5), vec3(0.5,0.7,0.5)),3.0));\n    \n    d = min2(d, q);\n    \n    d = min2(d, vec2(sdTorus(p.yxz - vec3(-0.5 + sin(iGlobalTime*0.25),1.4,0.5), vec2(1.0, 0.3)),1.0));\n    \n    return d;\n}\n\nvec4 doMaterial( in vec3 pos )\n{\n    float k = doModel(pos).y;\n    \n    vec3 c = vec3(0.0);\n    \n    c = mix(c, vec3(1.0,1.0,1.0), float(k == 1.0));\n    c = mix(c, vec3(1.0,0.2,0.1), float(k == 2.0));\n    c = mix(c, vec3(0.1,0.3,1.0), float(k == 3.0));\n    c = mix(c, vec3(0.3,0.15,0.1), float(k == 4.0));\n    c = mix(c, vec3(0.4,1.0,0.1), float(k == 5.0));\n    \n    return vec4(c,0.0);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\nconst vec3 lpvsize = vec3(32.0);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) \/ s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) \/ s.x, s.y);\n    float z = (p - x - floor(y) * s.x) \/ (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    if (posidx < (lpvsize.x * lpvsize.y * lpvsize.z)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        float offset = -0.5;\n        vec3 tpos = (pos + offset) \/ lpvsize;\n        vec3 wpos = (tpos * 2.0 - 1.0) * 2.5 + vec3(0.0,1.0,0.0);\n        fragColor = doMaterial(wpos);\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ iterative light propagation, one step per frame\n\n#define USE_LPV_OCCLUSION 1\n#define USE_LPV_BOUNCE 1\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst vec3 lpvsize = vec3(32.0);\n\nfloat packfragcoord2 (vec2 p, vec2 s) {\n    return floor(p.y) * s.x + p.x;\n}\nvec2 unpackfragcoord2 (float p, vec2 s) {\n    float x = mod(p, s.x);\n    float y = (p - x) \/ s.x + 0.5;\n    return vec2(x,y);\n}\nfloat packfragcoord3 (vec3 p, vec3 s) {\n    return floor(p.z) * s.x * s.y + floor(p.y) * s.x + p.x;\n}\nvec3 unpackfragcoord3 (float p, vec3 s) {\n    float x = mod(p, s.x);\n    float y = mod((p - x) \/ s.x, s.y);\n    float z = (p - x - floor(y) * s.x) \/ (s.x * s.y);\n    return vec3(x,y+0.5,z+0.5);\n}\n\nvec4 fetch_gv(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return vec4(0.0);\n    float posidx = packfragcoord3(p, lpvsize);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[0].xy) \/ iChannelResolution[0].xy;\n    return texture2D(iChannel0, uv);\n}\n\nfloat numvoxels;\nfloat channel;\nvec3 cmix;\n\nfloat fetch_av(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return 0.0;\n    float posidx = packfragcoord3(p, lpvsize);\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[1].xy) \/ iChannelResolution[1].xy;\n    return dot(texture2D(iChannel1, uv).rgb, cmix);\n}\n\nvec4 fetch_lpv(vec3 p) {\n    if ((min(p.x,min(p.y,p.z)) < 0.5) || (max(p.x,max(p.y,p.z)) > (lpvsize.x - 0.5)))\n        return vec4(0.0);\n    float posidx = packfragcoord3(p, lpvsize) + channel * numvoxels;\n    vec2 uv = unpackfragcoord2(posidx, iChannelResolution[2].xy) \/ iChannelResolution[2].xy;\n    return texture2D(iChannel2, uv);\n}\n\n\/\/#if USE_LPV_OCCLUSION || USE_LPV_BOUNCE\nvec4 gv4[6];\nvec4 gv[8];\n\/\/#if USE_LPV_BOUNCE\nfloat bc4[6];\nfloat bc[8];\n\/\/#endif \/\/ USE_LPV_BOUNCE\n\/\/#endif \/\/ USE_LPV_OCCLUSION || USE_LPV_BOUNCE\n\nvec4 sh_project(vec3 n) {\n    return vec4(\n        n,\n        0.57735026918963);\n}\n\nfloat sh_dot(vec4 a, vec4 b) {\n    return max(dot(a,b),0.0);\n}\n\n\/\/ 3 \/ (4 * pi)\nconst float m3div4pi = 0.23873241463784;\nfloat sh_flux(float d) {\n\treturn d * m3div4pi;\n}\nvec4 sh_flux(vec4 d) {\n\treturn d * m3div4pi;\n}\n\n#define SHSharpness 1.0 \/\/ 2.0\nvec4 sh_irradiance_probe(vec4 v) {\n    const float sh_c0 = (2.0 - SHSharpness) * 1.0;\n    const float sh_c1 = SHSharpness * 2.0 \/ 3.0;\n    return vec4(v.xyz * sh_c1, v.w * sh_c0);\n}\n\n\/\/angle = (4.0*atan(sqrt(11.0)\/33.0));\nconst float solid_angle_front = 0.4006696846462392 * m3div4pi;\n\/\/angle = (-M_PI\/3.0+2.0*atan(sqrt(11.0)*3.0\/11.0));\nconst float solid_angle_side = 0.4234313544367392 * m3div4pi;\n\n\/\/ 6 * (solid_angle_side * 4 + solid_angle_front) = 4 * PI\n\nvec4 accum_face(vec4 shcoeffs, int i, int j, int dim, int face_dim, \n                vec3 p, vec3 offset, vec3 face_offset,\n                vec4 gvcoeffs, vec4 gvrefcoeffs, float gvrefcolor) {\n    if (i == j) return vec4(0.0);\n\n    vec3 dirw = normalize(face_offset - offset);\n    \n    float solid_angle = (dim == face_dim)?solid_angle_front:solid_angle_side;\n    \n    vec4 outdirsh = sh_project(dirw);\n    vec4 indirsh = outdirsh;\n    vec4 invindirsh = sh_project(-dirw);\n    \n\t\/\/ how much flux has been received\n    float influx = sh_dot(shcoeffs, indirsh) * solid_angle;\n   \n    \/\/ how much flux will be occluded\n    #if USE_LPV_OCCLUSION\n    float occluded = sh_dot(gvcoeffs, indirsh);\n    #else\n    float occluded = 0.0;\n    #endif\n    \n    \/\/ how much flux will be passed on\n    float outflux = influx * (1.0 - occluded);\n    \n    vec4 result = outdirsh * outflux; \n    \n    \/\/ how much flux will be reflected\n    #if USE_LPV_BOUNCE\n    vec4 rvec = gvrefcoeffs;\n    float reflected = outflux * sh_dot(rvec, invindirsh);\n    if (reflected > 0.0) {\n        result += rvec * (reflected * gvrefcolor);\n    }\n    #endif    \n    \n    return result;\n}\n    \nvec4 sample_neighbors( int i, int dim, vec3 p, vec3 offset, vec4 gvcoeffs) {\n    vec4 shcoeffs = fetch_lpv(p + offset);\n\tvec4 shsumcoeffs = vec4(0.0);\n    \n    vec3 e = vec3(-0.5,0.5,0.0);\n    shsumcoeffs += accum_face(shcoeffs, i, 0, dim, 2, p, offset, e.zzx, gvcoeffs, gv4[0], bc4[0]);\n    shsumcoeffs += accum_face(shcoeffs, i, 1, dim, 2, p, offset, e.zzy, gvcoeffs, gv4[1], bc4[1]);\n    shsumcoeffs += accum_face(shcoeffs, i, 2, dim, 1, p, offset, e.zxz, gvcoeffs, gv4[2], bc4[2]);\n    shsumcoeffs += accum_face(shcoeffs, i, 3, dim, 1, p, offset, e.zyz, gvcoeffs, gv4[3], bc4[3]);\n    shsumcoeffs += accum_face(shcoeffs, i, 4, dim, 0, p, offset, e.xzz, gvcoeffs, gv4[4], bc4[4]);\n    shsumcoeffs += accum_face(shcoeffs, i, 5, dim, 0, p, offset, e.yzz, gvcoeffs, gv4[5], bc4[5]);\n    return shsumcoeffs;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float posidx = packfragcoord2(fragCoord.xy, iResolution.xy);\n    numvoxels = lpvsize.x * lpvsize.y * lpvsize.z;\n    channel = floor(posidx \/ numvoxels);\n    posidx -= channel * numvoxels;\n    cmix = vec3(\n        float(channel == 0.0),\n        float(channel == 1.0),\n        float(channel == 2.0));\n    if ((iFrame != 0) && (posidx < numvoxels)) {\n\t    vec3 pos = unpackfragcoord3(posidx,lpvsize);\n        vec3 tpos = pos \/ lpvsize;\n        \/\/ 28.0\n        if ((floor(pos.y) == (lpvsize.y - 10.0)) && ((length(tpos.xz - 0.5) - 0.3) < 0.0)) {\n\t\t   \tfloat lightcolor = dot(cmix,vec3(1.0,1.0,1.0));\n        \tfragColor = sh_project(vec3(0.0,-1.0,0.0)) * 50.0 * lightcolor;\n        } else {\n            vec4 shsumcoeffs = vec4(0.0);\n            vec3 e = vec3(-1.0,1.0,0.0);\n            \n            #if USE_LPV_OCCLUSION || USE_LPV_BOUNCE\n            vec2 w = vec2(0.0,1.0);\n            gv[0] = fetch_gv(pos + w.xxx);\n            gv[1] = fetch_gv(pos + w.xxy);\n            gv[2] = fetch_gv(pos + w.xyx);\n            gv[3] = fetch_gv(pos + w.xyy);\n            gv[4] = fetch_gv(pos + w.yxx);\n            gv[5] = fetch_gv(pos + w.yxy);\n            gv[6] = fetch_gv(pos + w.yyx);\n            gv[7] = fetch_gv(pos + w.yyy);\n\n            #if USE_LPV_BOUNCE\n            bc[0] = fetch_av(pos + w.xxx);\n            bc[1] = fetch_av(pos + w.xxy);\n            bc[2] = fetch_av(pos + w.xyx);\n            bc[3] = fetch_av(pos + w.xyy);\n            bc[4] = fetch_av(pos + w.yxx);\n            bc[5] = fetch_av(pos + w.yxy);\n            bc[6] = fetch_av(pos + w.yyx);\n            bc[7] = fetch_av(pos + w.yyy);\n            #endif    \n\n            gv4[0] = (gv[0]+gv[1]+gv[2]+gv[3])*0.25;\n            gv4[1] = (gv[4]+gv[5]+gv[6]+gv[7])*0.25;\n            gv4[2] = (gv[0]+gv[4]+gv[1]+gv[5])*0.25;\n            gv4[3] = (gv[2]+gv[6]+gv[3]+gv[7])*0.25;\n            gv4[4] = (gv[0]+gv[2]+gv[4]+gv[6])*0.25;\n            gv4[5] = (gv[1]+gv[3]+gv[5]+gv[7])*0.25;\n\n            #if USE_LPV_BOUNCE\n            bc4[0] = (bc[0]+bc[1]+bc[2]+bc[3])*0.25;\n            bc4[1] = (bc[4]+bc[5]+bc[6]+bc[7])*0.25;\n            bc4[2] = (bc[0]+bc[4]+bc[1]+bc[5])*0.25;\n            bc4[3] = (bc[2]+bc[6]+bc[3]+bc[7])*0.25;\n            bc4[4] = (bc[0]+bc[2]+bc[4]+bc[6])*0.25;\n            bc4[5] = (bc[1]+bc[3]+bc[5]+bc[7])*0.25;\n            #endif\n\n            #endif \/\/ USE_LPV_OCCLUSION || USE_LPV_BOUNCE \n            \n            \n            shsumcoeffs += sample_neighbors(0, 2, pos, e.zzx, gv4[0]);\n            shsumcoeffs += sample_neighbors(1, 2, pos, e.zzy, gv4[1]);\n            shsumcoeffs += sample_neighbors(2, 1, pos, e.zxz, gv4[2]);\n            shsumcoeffs += sample_neighbors(3, 1, pos, e.zyz, gv4[3]);\n            shsumcoeffs += sample_neighbors(4, 0, pos, e.xzz, gv4[4]);\n            shsumcoeffs += sample_neighbors(5, 0, pos, e.yzz, gv4[5]);\n        \n            fragColor = shsumcoeffs;\n        }\n    } else {\n        fragColor = vec4(0.0,0.0,0.0,0.0);\n    }\n}","name":"Buf C","description":"","type":"buffer"}]}}