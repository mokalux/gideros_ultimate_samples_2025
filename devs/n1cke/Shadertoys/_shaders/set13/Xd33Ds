{"Shader":{"ver":"0.1","info":{"id":"Xd33Ds","date":"1452681135","viewed":1034,"name":"lens: bokeh blur, hexagon 5pass","username":"hornet","description":"Implementation of http:\/\/www.slideshare.net\/DICEStudio\/five-rendering-ideas-from-battlefield-3-need-for-speed-the-run - without the MRT optimisations.","likes":33,"published":3,"flags":32,"tags":["blur","lens","filter","bokeh","hex"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":2,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"#define USE_RANDOM\n\nconst vec2 blurdir = vec2( -1.0, -0.577350269189626 );\n\n\/\/ ====\n\nconst float blurdist_px = 32.0;\nconst int NUM_SAMPLES = 16;\n\n\n\n\n\/\/#define GAMMA_SRGB\n#if defined( GAMMA_SRGB )\n\/\/ see http:\/\/www.opengl.org\/registry\/specs\/ARB\/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs \/ 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) \/ 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\t\/\/cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n#else\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n#endif \/\/GAMMA_SRGB\n\n\/\/note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blurvec = normalize(blurdir) \/ iResolution.xy;\n    \n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 suv = (fragCoord + 25.0 * vec2( cos(iGlobalTime), sin(iGlobalTime ) )) \/ iResolution.xy;\n    float sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + iGlobalTime ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x\/iResolution.x : blurdist_px * sinblur;\n    \n    vec2 p0 = uv;\n    vec2 p1 = uv + blurdist * blurvec;\n    vec2 stepvec = (p1-p0) \/ float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iGlobalTime)+0.5)) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n     \tsumcol += srgb2lin( texture2D( iChannel1, p, -10.0 ).rgb);\n        p += stepvec;\n    }\n    sumcol \/= float(NUM_SAMPLES);\n    \n    vec3 s2 = srgb2lin( texture2D( iChannel2, uv).rgb );\n    vec3 s3 = srgb2lin( texture2D( iChannel3, uv).rgb );\n\n    \/\/DEBUG\n    \/\/fragColor = texture2D( iChannel1, uv); return; \/\/DBG\n    \/\/fragColor = vec4(sumcol,1.0); return; \/\/DBG\n    \/\/fragColor = texture2D( iChannel0, uv); return; \/\/DBG\n    \/\/fragColor = vec4(lin2srgb(s2),1.0); return; \/\/DBG\n    \/\/fragColor = vec4(lin2srgb(s3),1.0); return; \/\/DBG\n    \n    vec3 outcol = sumcol + s2 + s3;\n    fragColor = vec4( lin2srgb(outcol), 1.0 );\n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"#define USE_RANDOM\n\nconst vec2 blurdir = vec2( 0.0, 1.0 );\n\n\/\/ ====\n\nconst float blurdist_px = 32.0;\nconst int NUM_SAMPLES = 16;\n\nconst float THRESHOLD = 0.1;\nconst float MULT = 2.0;\n\n\/\/#define GAMMA_SRGB\n#if defined( GAMMA_SRGB )\n\/\/ see http:\/\/www.opengl.org\/registry\/specs\/ARB\/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs \/ 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) \/ 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\t\/\/cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n#else\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n#endif \/\/GAMMA_SRGB\n\n\/\/note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvec4 pattern( vec2 p )\n{\n    float aspect = iResolution.x\/iResolution.y;\n    float p0 = step(abs(p.x-0.125), 0.01) * step(abs(p.y-0.27), 0.01);\n    float p1 = step( length( p-vec2(0.125, 0.45) ), 0.025 );\n    \n    float p2_0 = step( length( p-vec2(0.08, 0.14) ), 0.0125 );\n    float p2_1 = step( length( p-vec2(0.16, 0.125) ), 0.0125 );\n    float p2_2 = step( length( p-vec2(0.1, 0.07) ), 0.0125 );\n    float p2 = max(p2_0, max(p2_1,p2_2));\n    \n    return vec4( max( p0, max(p1,p2) ) );\n}\n\nvec3 sampletex( vec2 uv )\n{\n    float t = fract( 0.1*iGlobalTime );\n    if ( t < 1.0\/3.0)\n    \treturn srgb2lin( texture2D( iChannel0, uv, -10.0 ).rgb );\n    else if ( t < 2.0\/3.0 )\n        return srgb2lin( texture2D( iChannel1, uv, -10.0 ).rgb );\n    else\n\t    return srgb2lin( texture2D( iChannel2, uv, -10.0 ).rgb );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blurvec = normalize(blurdir) \/ iResolution.xx;\n    fragCoord += 25.0 * vec2( cos(iGlobalTime), sin(iGlobalTime ) );\n    vec2 suv = fragCoord \/ iResolution.xy; \n    vec2 uv = fragCoord \/ iResolution.xx;\n   \tfloat sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + iGlobalTime ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x\/iResolution.x : blurdist_px * sinblur;\n    \n    vec2 p0 = uv;\n    vec2 p1 = uv + blurdist * blurvec;\n    vec2 stepvec = (p1-p0) \/ float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iGlobalTime)+0.1)) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        if ( p.x < 0.25 )\n            sumcol += pattern( p ).rgb;\n        else\n        {\n            vec3 sample = (sampletex(p) - THRESHOLD ) \/ (1.0-THRESHOLD);\n            \/\/sumcol += sample;\n            sumcol += sample*sample; \/\/wtf?\n        }\n        \n        p += stepvec;\n    }\n    sumcol \/= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n    \n    fragColor = vec4( lin2srgb( sumcol * MULT ), 1.0 );\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":4,"src":"\/presets\/tex03.jpg","ctype":"texture","channel":0,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":10,"src":"\/presets\/tex09.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"#define USE_RANDOM\n\nconst vec2 blurdir = vec2( 1.0, -0.577350269189626 );\n\n\/\/ ====\n\nconst float blurdist_px = 32.0;\nconst int NUM_SAMPLES = 16;\n\nconst float THRESHOLD = 0.1;\nconst float MULT = 2.0;\n\n\/\/#define GAMMA_SRGB\n#if defined( GAMMA_SRGB )\n\/\/ see http:\/\/www.opengl.org\/registry\/specs\/ARB\/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs \/ 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) \/ 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\t\/\/cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n#else\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n#endif \/\/GAMMA_SRGB\n\n\/\/note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvec4 pattern( vec2 p )\n{\n    float aspect = iResolution.x\/iResolution.y;\n    float p0 = step(abs(p.x-0.125), 0.01) * step(abs(p.y-0.27), 0.01);\n    float p1 = step( length( p-vec2(0.125, 0.45) ), 0.025 );\n    \n    float p2_0 = step( length( p-vec2(0.08, 0.14) ), 0.0125 );\n    float p2_1 = step( length( p-vec2(0.16, 0.125) ), 0.0125 );\n    float p2_2 = step( length( p-vec2(0.1, 0.07) ), 0.0125 );\n    float p2 = max(p2_0, max(p2_1,p2_2));\n    \n    return vec4( max( p0, max(p1,p2) ) );\n}\n\nvec3 sampletex( vec2 uv )\n{\n    float t = fract( 0.1*iGlobalTime );\n    if ( t < 1.0\/3.0)\n    \treturn srgb2lin( texture2D( iChannel0, uv, -10.0 ).rgb );\n    else if ( t < 2.0\/3.0 )\n        return srgb2lin( texture2D( iChannel1, uv, -10.0 ).rgb );\n    else\n\t    return srgb2lin( texture2D( iChannel2, uv, -10.0 ).rgb );    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blurvec = normalize(blurdir) \/ iResolution.xx;\n    fragCoord += 25.0 * vec2( cos(iGlobalTime), sin(iGlobalTime ) );\n    vec2 suv = fragCoord \/ iResolution.xy; \n    vec2 uv = fragCoord \/ iResolution.xx;\n   \tfloat sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + iGlobalTime ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x\/iResolution.x : blurdist_px * sinblur;\n    \n    vec2 p0 = uv;\n    vec2 p1 = uv + blurdist * blurvec;\n    vec2 stepvec = (p1-p0) \/ float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iGlobalTime)+0.2)) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n        if ( p.x < 0.25 )\n            sumcol += pattern( p ).rgb;\n        else\n        {\n            vec3 sample = (sampletex(p) - THRESHOLD ) \/ (1.0-THRESHOLD);\n            \/\/sumcol += sample;\n            sumcol += sample*sample; \/\/wtf?\n        }\n        \n        p += stepvec;\n    }\n    sumcol \/= float(NUM_SAMPLES);\n    sumcol = max( sumcol, 0.0 );\n    \n    fragColor = vec4( lin2srgb( sumcol * MULT ), 1.0 );\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"#define USE_RANDOM\n\nconst vec2 blurdir = vec2( -1.0, -0.577350269189626 );\n\n\/\/ ====\n\nconst float blurdist_px = 32.0;\nconst int NUM_SAMPLES = 16;\n\n\n\n\n\/\/#define GAMMA_SRGB\n#if defined( GAMMA_SRGB )\n\/\/ see http:\/\/www.opengl.org\/registry\/specs\/ARB\/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs \/ 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) \/ 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\t\/\/cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n#else\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n#endif \/\/GAMMA_SRGB\n\n\/\/note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blurvec = normalize(blurdir) \/ iResolution.xy;\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 suv = (fragCoord + 25.0 * vec2( cos(iGlobalTime), sin(iGlobalTime ) )) \/ iResolution.xy;\n    float sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + iGlobalTime ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x\/iResolution.x : blurdist_px * sinblur;\n    \n    vec2 p0 = uv;\n    vec2 p1 = uv + blurdist * blurvec;\n    vec2 stepvec = (p1-p0) \/ float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iGlobalTime)+0.3)) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n     \tsumcol += srgb2lin( texture2D( iChannel0, p, -10.0 ).rgb);\n        p += stepvec;\n    }\n    sumcol \/= float(NUM_SAMPLES);\n    \n    fragColor = vec4( lin2srgb(sumcol), 1.0 );\n}\n","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":260,"channel":0}],"code":"#define USE_RANDOM\n\nconst vec2 blurdir = vec2( 1.0, -0.577350269189626 );\n\n\/\/ ====\n\nconst float blurdist_px = 32.0;\nconst int NUM_SAMPLES = 16;\n\n\n\n\n\/\/#define GAMMA_SRGB\n#if defined( GAMMA_SRGB )\n\/\/ see http:\/\/www.opengl.org\/registry\/specs\/ARB\/framebuffer_sRGB.txt\nvec3 srgb2lin( vec3 cs )\n{\n\tvec3 c_lo = cs \/ 12.92;\n\tvec3 c_hi = pow( (cs + 0.055) \/ 1.055, vec3(2.4) );\n\tvec3 s = step(vec3(0.04045), cs);\n\treturn mix( c_lo, c_hi, s );\n}\nvec3 lin2srgb( vec3 cl )\n{\n\t\/\/cl = clamp( cl, 0.0, 1.0 );\n\tvec3 c_lo = 12.92 * cl;\n\tvec3 c_hi = 1.055 * pow(cl,vec3(0.41666)) - 0.055;\n\tvec3 s = step( vec3(0.0031308), cl);\n\treturn mix( c_lo, c_hi, s );\n}\n#else\nvec3 srgb2lin(vec3 c) { return c*c; }\nvec3 lin2srgb(vec3 c) { return sqrt(c); }\n#endif \/\/GAMMA_SRGB\n\n\/\/note: uniform pdf rand [0;1[\nfloat hash12n(vec2 p)\n{\n\tp  = fract(p * vec2(5.3987, 5.4421));\n    p += dot(p.yx, p.xy + vec2(21.5351, 14.3137));\n\treturn fract(p.x * p.y * 95.4307);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 blurvec = normalize(blurdir) \/ iResolution.xy;\n    vec2 uv = fragCoord \/ iResolution.xy;\n    vec2 suv = (fragCoord + 25.0 * vec2( cos(iGlobalTime), sin(iGlobalTime ) )) \/ iResolution.xy;\n    float sinblur = ( 0.55 + 0.45 * sin( 5.0 * uv.x + iGlobalTime ) );\n    float blurdist = (iMouse.z>0.5) ? 100.0 * iMouse.x\/iResolution.x : blurdist_px * sinblur;\n    \n    vec2 p0 = uv;\n    vec2 p1 = uv + blurdist * blurvec;\n    vec2 stepvec = (p1-p0) \/ float(NUM_SAMPLES);\n    vec2 p = p0;\n    #if defined(USE_RANDOM)\n    p += (hash12n(uv+fract(iGlobalTime)+0.4)) * stepvec;\n    #endif\n    \n    vec3 sumcol = vec3(0.0);\n    for (int i=0;i<NUM_SAMPLES;++i)\n    {\n     \tsumcol += srgb2lin( texture2D( iChannel0, p, -10.0 ).rgb);\n        p += stepvec;\n    }\n    sumcol \/= float(NUM_SAMPLES);\n    \n    fragColor = vec4( lin2srgb(sumcol), 1.0 );\n}\n","name":"Buf D","description":"","type":"buffer"}]}}