{"Shader":{"ver":"0.1","info":{"id":"XdGGWD","date":"1454425202","viewed":553,"name":"Liquid Experiment","username":"P_Malin","description":"Click mouse to interact.<br\/>Press D and click mouse to draw solid<br\/>Press E and click mouse to erase<br\/>Press S and click mouse to spawn liquid<br\/>Press P to show particles","likes":12,"published":3,"flags":48,"tags":["simulation","dynamics","liquid"],"hasliked":0},"renderpass":[{"inputs":[{"id":3,"src":"\/presets\/tex02.jpg","ctype":"texture","channel":2,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":7,"src":"\/presets\/tex06.jpg","ctype":"texture","channel":1,"sampler":{"filter":"mipmap","wrap":"repeat","vflip":"true","srgb":"false","internal":"byte"}},{"id":22,"src":"\/presets\/cube00_0.jpg","ctype":"cubemap","channel":3,"sampler":{"filter":"mipmap","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":0,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Liquid Experiment\n\/\/ @P_Malin\n\n\/\/ Click mouse to interact.\n\/\/ Press D and click mouse to draw solid\n\/\/ Press E and click mouse to erase\n\/\/ Press S and click mouse to spawn liquid\n\nvec3 SampleCubemap( vec3 vDir )\n{\n\tvec3 vSpec = textureCube( iChannel3, vDir ).rgb;\n    vSpec = vSpec * vSpec;\n    vSpec = -log2(1.0 - vSpec * 0.999);\n    return vSpec;\n}\n\nvec2 ScaleUV( vec2 vUV )\n{\n    return vUV;\n    \/\/vec2 vClampRes = min( iResolution.xy, vec2(640.0, 480.0) );    \n    \/\/return vUV * vClampRes \/ iResolution.xy;    \n}\n\nvec4 SampleImage( vec2 vUV )\n{\n    return texture2D( iChannel0, ScaleUV(vUV) );\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord \/ iResolution.xy;\n    \n    vec2 vOffset = vec2(1.0) \/ iResolution.xy;\n    float fScale = 0.5;\n    \n    vec4 vSampleA = SampleImage( vUV );\n    float fIsLiquid = clamp( vSampleA.r * 2.0, 0.0, 1.0);\n    float fPressure = vSampleA.g;\n\n    vec4 vSampleB = SampleImage( vUV - vec2(vOffset.x, 0.0) );\n    vec4 vSampleC = SampleImage( vUV - vec2(0.0, vOffset.y) );\n    \n    vec2 vDelta;\n    \n    vDelta.x = vSampleB.x - vSampleA.x;\n    vDelta.y = vSampleC.x - vSampleA.x;\n    vec3 vNormal = normalize( vec3( vDelta.x * fScale, vDelta.y * fScale, 1.0 ) );\n    \n    vec3 vView = normalize( vec3(vUV * 2.0 - 1.0, 1.0) * vec3(1.0, -1.0, 1.0));\n    vec3 vRefl = reflect( vView, vNormal );\n    vec3 vRefr = refract( vView, vNormal, 0.9 );\n    \n    \/\/vec4 vSample = texture2D( iChannel1, vUV + vRefl.xy);\n    vec3 vRefraction = SampleCubemap( vRefr );\n    vec3 vReflection = SampleCubemap( vRefl );\n    \n    fragColor = vec4(vRefraction.xyz,1.0);\n    \n    fragColor = fragColor * fragColor;\n    \n    vec3 vColor = vec3( 0.01, 1.0, 0.8 );\n    \n    fragColor.rgb *= exp2( (1.0 - vColor) * (fIsLiquid * 0.2 + fPressure) * -10.0 );\n        \n    vec3 vSpec = SampleCubemap( vRefl );\n    \n    float NdotV = clamp( dot( vNormal, vView ), 0.0, 1.0);\n    float fFresnel =  0.02 + pow( 1.0 - NdotV, 5.0 ) * (1.0 - 0.02);\n    fragColor.rgb = mix( fragColor.rgb, vSpec, fFresnel );\n    \n    \n    fragColor = 1.0 - exp2( fragColor * -5.0 );\n    fragColor = sqrt( fragColor );\n    \n    if( vSampleA.z < -50.0 )\n    {\n        fragColor.rgb = texture2D( iChannel2, vUV ).rgb;\n        \n        if(vSampleB.z > -50.0)\n        {\n            fragColor.rgb *= 0.5;\n        }\n        if(vSampleC.z > -50.0)\n        {\n            fragColor.rgb *= 0.5;\n        }\n    }    \n}\n","name":"Image","description":"","type":"image"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"#define SIZE 16\n\nvec4 SampleCell( const in vec2 vCellCoord )\n{\n    vec2 vUV = (floor(vCellCoord.xy) - 0.5) \/ iChannelResolution[0].xy;\n    vec4 vSample = texture2D( iChannel0, vUV );            \t    \n    \n    return vSample;\n}\n\nbool InCell( const in vec2 vCellCoord, const in vec2 vTestPos )\n{\n    vec2 vCellMin = floor( vCellCoord );\n    vec2 vCellMax = vCellMin + 1.0;\n    \n    if ( vTestPos.x < vCellMin.x ) return false;\n    if ( vTestPos.y < vCellMin.y ) return false;\n    if ( vTestPos.x >= vCellMax.x ) return false;\n    if ( vTestPos.y >= vCellMax.y ) return false;\n    \n    return true;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Keyboard \n\n\n\/\/ Keyboard constants definition\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nbool KeyIsPressed(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool KeyIsToggled(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 1.0) ).x > 0.0;\n}\n\n\n\nconst float g_fTimeStep = 1.0 \/ 60.0;\nconst float g_fTimeStepSq = g_fTimeStep * g_fTimeStep;\nconst float g_fSmoothingRadius = float(SIZE);\n\nconst float g_fRestDensity = 2000000.0;\nconst float g_fK = 0.01;\nconst float g_fViscosity = 0.25;\n\nvoid UpdateParticle( const in vec2 fragCoord, inout vec2 vParticlePos, inout vec2 vParticleVel )\n{    \n#if 1     \n    float fDensity = 0.0;\n    float fNearDensity = 0.0;\n    \n    \n    {\n        vec2 vOffset;\n        vOffset.y = -float(SIZE);\n        for( int iY=-SIZE; iY<=SIZE; iY++ )\n        {\n            vOffset.x = -float(SIZE);\n            for( int iX=-SIZE; iX<=SIZE; iX++ )\n            {\n                vec2 vCoord = fragCoord + vOffset;\n\n                vec4 vSample = SampleCell( vCoord );\n                vec2 vOtherPos = vSample.xy;\n                vec2 vOtherVel = vSample.zw;\n                \n                if( vOtherPos.x >= 0.0 )\n                {\n                    float fDist = length(vOtherPos.xy - vParticlePos);\n                    if ( fDist > 0.0 )\n                    {\n                        if ( fDist < g_fSmoothingRadius )\n                        {\n                            float fOneMinusQ = 1.0 - (fDist \/ g_fSmoothingRadius);\n\n                            fDensity += fOneMinusQ * fOneMinusQ;\n                        }\n                    }\n                }                \t\t\t\t\n\n                vOffset.x += 1.0;\n            }\n\n            vOffset.y += 1.0;\n        }      \n    }\n    \n\tfloat fPressure = g_fK * (fDensity - g_fRestDensity);\n    \n    vec2 vD = vec2( 0.0 );\n\n    vec2 vI = vec2( 0.0 );\n    \n    {\n        vec2 vOffset;\n        vOffset.y = -float(SIZE);\n        for( int iY=-SIZE; iY<=SIZE; iY++ )\n        {\n            vOffset.x = -float(SIZE);\n            for( int iX=-SIZE; iX<=SIZE; iX++ )\n            {\n                vec2 vCoord = fragCoord + vOffset;\n\n                vec4 vSample = SampleCell( vCoord );\n                vec2 vOtherPos = vSample.xy;\n                vec2 vOtherVel = vSample.zw;\n\n                if( vOtherPos.x >= 0.0 )\n                {\n\n                    float fDist = length(vOtherPos.xy - vParticlePos);\n                    if ( fDist > 0.0 )\n                    {\n                        if ( fDist < g_fSmoothingRadius )\n                        {\n                            float fOneMinusQ = 1.0 - (fDist \/ g_fSmoothingRadius);\n\n                            vec2 vDiff = vOtherPos - vParticlePos;\n                            float fDist = length( vDiff );\n                            vec2 vDir = normalize( vDiff );\n\n                            if ( fDist < g_fSmoothingRadius )\n                            {\n                                float fOneMinusQ = 1.0 - (fDist \/ g_fSmoothingRadius);\n                                vD += vDir * (g_fTimeStepSq * (fPressure * fOneMinusQ));\n\n\n                                vec2 vVelDiff = vOtherVel - vParticleVel;\n                                float u = dot( vVelDiff, vDir );\n\n                                if( u > 0.0 )\n                                {\n                                    vI += vDir * (g_fTimeStep * fOneMinusQ * (g_fViscosity * u * u));\n                                }\n                            }\n                        }                                               \n                    }\n                }\n                else if( vOtherPos.x < -50.0 )\n                {\n                    vec2 vOtherPos = vCoord;\n                    vec2 vDelta = vOtherPos - vParticlePos;\n                    float fDist = length( vDelta );\n                    float g_CollideRadius = 16.0;\n                    if( fDist < g_CollideRadius )\n                    {\n                    \tfloat fOneMinusQ = 1.0 - (fDist \/ g_CollideRadius);\n                        vParticleVel -= normalize( vDelta ) * fOneMinusQ * 10.0;                        \n                    }\n                }\n                \n\n                vOffset.x += 1.0;\n            }\n\n            vOffset.y += 1.0;\n        }      \n    }\n\n    vParticleVel += vI * 0.5;\n\tvParticleVel += vD * 0.5 \/ g_fTimeStep;    \n    \n\n#endif    \n    \n    vParticleVel.y -= 1000.0 * g_fTimeStep;  \n    \n    float fVelMag = length(vParticleVel);\n    if ( fVelMag > 0.0 )\n    {\n        fVelMag = clamp( fVelMag, 0.0, 8.0 * 60.0 );\n\t    vParticleVel = normalize( vParticleVel ) * fVelMag;\n    }\n\n    vParticlePos += vParticleVel * g_fTimeStep;    \n}\n\nvec2 GetMouse()\n{\n\treturn iMouse.xy;    \n    \n    \/\/vec2 vClampRes = min( iResolution.xy, vec2(640.0, 480.0) );    \n    \/\/return iMouse.xy * vClampRes \/ iResolution.xy;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/if( fragCoord.x > 640.0 || fragCoord.y > 480.0 ) discard;\n    fragCoord = fragCoord + 0.5;\n    fragColor = vec4( -10.0, -10.0, 0.0, 0.0 );\n    \n    if ( iGlobalTime <= 1.0 )\n    {\n        if( (fragCoord.x > 16.0) && \n           (fragCoord.y > 16.0) && \n           (fragCoord.x < (iResolution.x - 16.0)) && \n           (fragCoord.y < (iResolution.y - 16.0)) )\n        {\n            if( mod( fragCoord.x, 10.0 ) < 1.0 )\n            if( mod( fragCoord.y, 10.0 ) < 1.0 )\n            {\n        \t\tfragColor = vec4( fragCoord.x, fragCoord.y, 0.0, 0.0 );\n            }\n        }\n        else\n        {\n        \tfragColor = vec4( -100.0, -10.0, 0.0, 0.0 );\n        }\n        return;\n    }\n        \n    vec4 vSample = SampleCell( fragCoord );\n    \n    if ( vSample.x < 0.0 )\n    {\n        if ( vSample.x <= -100.0 )\n        {\n\t        fragColor = vec4( -100.0, -10.0, 0.0, 0.0 );\n        }\n        else\n        {\n\t        fragColor = vec4( -10.0, -10.0, 0.0, 0.0 );            \n        }\n    }\n    \n    if ( vSample.x >= 0.0 )\n    {    \n        UpdateParticle( fragCoord, vSample.xy, vSample.zw );\n    }\n\n    if ( iMouse.z > 0.0 )\n    {\n        if ( KeyIsToggled( KEY_E ) )\n        {\n            vec2 vDelta = fragCoord.xy - GetMouse();\n            if( length(vDelta) < 10.0 )\n            {\n            \tfragColor = vec4( -10.0, -10.0, 0.0, 0.0 );\n                return;\n            }\n        }            \n        else            \n        if ( KeyIsToggled( KEY_D ) )\n        {\n            vec2 vDelta = fragCoord.xy - GetMouse();\n            if( length(vDelta) < 10.0 )\n            {\n            \tfragColor = vec4( -100.0, -10.0, 0.0, 0.0 );\n                return;\n            }\n        }            \n        else\n        if ( KeyIsToggled( KEY_S ) )\n        {     \n            vec2 vParticlePos = GetMouse();\n            vec2 vParticleVel = vec2(0.0, -10.0);\n\n            {\n                if( InCell( fragCoord, vParticlePos ) )\n                {        \n                    vSample.xy = vParticlePos;\n                    vSample.zw = vParticleVel;\n                }\n\n            }            \n        }\n        else            \n        {\n            float fRadius = 128.0;\n\n            vec2 vDelta = vSample.xy - GetMouse();\n            float fDelta = length( vDelta );\n            if( fDelta < fRadius )\n            {\n                vec2 vDir = normalize( vDelta );\n                float fForce = clamp( (fRadius - fDelta) \/ fRadius, 0.0, 1.0 );\n                vSample.zw += vDir * fForce * 100.0;\n            }\n        }\n        \n\n    }        \n    \t\n\n    fragColor = vSample;\n}\n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"#define SIZE 16\n\nvec4 SampleCell( const in vec2 vCellCoord )\n{\n    vec2 vUV = (floor(vCellCoord.xy) - 0.5) \/ iChannelResolution[0].xy;\n    vec4 vSample = texture2D( iChannel0, vUV );            \t    \n    \n    return vSample;\n}\n\nbool InCell( const in vec2 vCellCoord, const in vec2 vTestPos )\n{\n    vec2 vCellMin = floor( vCellCoord );\n    vec2 vCellMax = vCellMin + 1.0;\n    \n    if ( vTestPos.x < vCellMin.x ) return false;\n    if ( vTestPos.y < vCellMin.y ) return false;\n    if ( vTestPos.x >= vCellMax.x ) return false;\n    if ( vTestPos.y >= vCellMax.y ) return false;\n    \n    return true;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    \/\/if( fragCoord.x > 640.0 || fragCoord.y > 480.0 ) discard;\n    \n    fragCoord = fragCoord + 0.5;\n    \n    fragColor = vec4( -10.0, -10.0, 0.0, 0.0 );\n    \n    vec4 vSample = SampleCell( fragCoord );\n    if( vSample.x < -50.0) \n    {\n        fragColor = vSample;\n    }\n    else\n    {\n\n        vec2 vOffset;\n        vOffset.y = -float(SIZE);\n        for( int iY=-SIZE; iY<=SIZE; iY++ )\n        {\n            vOffset.x = -float(SIZE);\n            for( int iX=-SIZE; iX<=SIZE; iX++ )\n            {\n                vec2 vCoord = fragCoord + vOffset;\n\n                vec4 vSample = SampleCell( vCoord );\n\n                if( InCell( fragCoord, vSample.xy ) )\n                {\n                    fragColor = vSample;\n                }\n\n                \/\/float fCurrDist = length( vSample.xy - fragCoord.xy );\n                \/\/fDist = min( fDist, fCurrDist );\n\n                vOffset.x += 1.0;\n            }\n\n            vOffset.y += 1.0;\n        }    \n    }\n}","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":1,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"#define SIZE 16\n\nvec4 SampleCell( const in vec2 vCellCoord )\n{\n    vec2 vUV = (floor(vCellCoord.xy) - 0.5) \/ iChannelResolution[0].xy;\n    vec4 vSample = texture2D( iChannel0, vUV );            \t    \n    \n    return vSample;\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\/\/ Keyboard \n\n\n\/\/ Keyboard constants definition\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nbool KeyIsPressed(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool KeyIsToggled(float key)\n{\n\treturn texture2D( iChannel1, vec2(key, 1.0) ).x > 0.0;\n}\n\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{        \n    \/\/if( fragCoord.x > 640.0 || fragCoord.y > 480.0 ) discard;\n    \n    float fResult = 0.0;\n    \n    vec2 vOffset;\n    vOffset.y = -float(SIZE);\n    for( int iY=-SIZE; iY<=SIZE; iY++ )\n    {\n\t    vOffset.x = -float(SIZE);\n        for( int iX=-SIZE; iX<=SIZE; iX++ )\n        {\n            vec2 vCoord = fragCoord + vOffset;\n            \n    \t\tvec4 vSample = SampleCell( vCoord );\n            \n            float fCurrDist = length( vSample.xy - fragCoord.xy );\n            \n            float g_fSmoothingRadius = float(SIZE);\n            \n            if( KeyIsToggled( KEY_P ) )\n            {\n                g_fSmoothingRadius *= 0.25;\n            }\n            \n            if( fCurrDist < g_fSmoothingRadius )\n            {\n\t\t\t\tfloat fOneMinusQ = 1.0 - (fCurrDist \/ g_fSmoothingRadius);\n                    \n           \t\tfResult = fResult + fOneMinusQ * fOneMinusQ;\n            }\n                    \n            vOffset.x += 1.0;\n        }\n            \n        vOffset.y += 1.0;\n    }\n    \n    vec3 vResult = vec3(fResult);\n    \/\/\n    vResult.x = 1.0 - exp2( vResult.x * -10.0 );\n    vResult.x = smoothstep( 0.0, 1.0, vResult.x);\n    \n    vResult.x = pow( vResult.x, 0.5 );\n    vResult.x -= pow( 1.0 - vResult.y * 0.5, 2.0);\n    vResult.y = pow( vResult.y, 3.0 );                        \n    \n    vResult.z = SampleCell( fragCoord ).x;                        \n    \n    \/\/vResult = vec3(1.0) \/ (fDist + 0.5);\n    \n\tfragColor = vec4(vResult.xyz, 1.0);\n}","name":"Buf C","description":"","type":"buffer"}]}}