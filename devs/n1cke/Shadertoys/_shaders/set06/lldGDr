{"Shader":{"ver":"0.1","info":{"id":"lldGDr","date":"1469384349","viewed":748,"name":"[SH16C] Doom","username":"P_Malin","description":"I had to change the controls as pressing Ctrl + W closes the window.\nPress Space \/ Enter to Start!\nCursors - Turn\nWASD - Move\nSpace - Fire\nEnter\/F - Open Door\nShift - Run\nAlt - Strafe\nL - Mouse look\nI - Invert Y\n(see ReadControls() in  buffer C)","likes":17,"published":3,"flags":112,"tags":["game","doom","competition","sh16c"],"hasliked":0},"renderpass":[{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":260,"src":"\/presets\/previz\/buffer03.png","ctype":"buffer","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":37,"channel":0}],"code":"\/\/ Entry for shadertoy 2016 competetion Part C\n\n\/\/ Comment out for faster rendering:\n#define HUD_MESSAGES\n#define FULL_HUD\n\n\/\/#define SHOW_SPRITES\n\/\/#define SHOW_MAP_DATA\n\n\/\/ Enables map on Tab key (slow):\n\/\/ Also need define in buf c\n\/\/#define ALLOW_MAP\n\n\/\/ Controls: \n\n\/\/ Press Space \/ Enter to Start!\n\/\/ Cursors - Turn\n\/\/ WASD - Move\n\/\/ Space - Fire\n\/\/ Enter\/F - Open Door\n\/\/ Shift - Run\n\/\/ Alt - Strafe\n\/\/ L - Mouse look\n\/\/ I - Invert Y\n\n\/\/ ( see ReadControls() in  buffer C )\n\n\n\/\/ Note: I've added a bunch of additional stuff to this shader since the competition deadline\n\/\/\n\/\/ * Fixed framerate issue on some machines\n\/\/ * Fixed some state machine timer logic\n\/\/ * Enemy sprites for different compass directions\n\/\/ * Changed aspect ratio\n\/\/ * Added mouse control + mouselook\n\/\/ * Sergeants carry shotguns\n\/\/ * Added sprites for more enemy states\n\/\/ * Fixed sky rendering\n\/\/ * Added viemodel\n\/\/ * Added enemy model textures sprites\n\/\/ * Added muzzle flash sprite\n\/\/ * Improved barrel explode sprite\n\/\/ * Impreove imp fireball sprite\n\/\/ * Improved HUD and added numbers font\n\/\/ * Added messages for pickups etc.\n\n\/\/ Music : https:\/\/soundcloud.com\/plasma3\/doom-remix-at-dooms-gate-level-1-theme-e1m1\n\n\/\/ HUD \/ UI \/ Viewmodel\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define FAR_CLIP 1000000.0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Util\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 Quantize( const in vec3 col, float fLevels )\n{\n\treturn floor( col * fLevels + 0.5 ) * (1.0 \/ fLevels);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    return vA.x * vB.y - vA.y * vB.x;\n}\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid SetFlag( inout float fBits, float fFlag )\n{\n    \/\/ TODO: flag mask logic \n    fBits = fFlag;\n}\n\n\nbool FlagSet( float fBits, float fFlag )\n{\n    return fract( floor( fBits \/ fFlag ) * 0.5 ) >= 0.5;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nconst float KEY_1 = \t49.5\/256.0;\nconst float KEY_2 = \t50.5\/256.0;\nconst float KEY_3 = \t51.5\/256.0;\nconst float KEY_ENTER = 13.5\/256.0;\nconst float KEY_SHIFT = 16.5\/256.0;\nconst float KEY_CTRL  = 17.5\/256.0;\nconst float KEY_ALT   = 18.5\/256.0;\nconst float KEY_TAB\t  = 9.5\/256.0;\n\nbool Key_IsPressed(float key)\n{\n    return texture2D( iChannel3, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool Key_IsToggled(float key)\n{\n    return texture2D( iChannel3, vec2(key, 1.0) ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Packing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat BytePack2( vec2 val )\n{ \n    return dot( floor(val), vec2(1, 256) );\n}\n\nfloat BytePack2( float x, float y )\n{\n    return BytePack2( vec2( x, y ) );\n}\n\nvec2 ByteUnpack2( float x )\n{\n    return mod( floor(vec2(x) \/ vec2(1, 256)), 256. );\n}\n\nfloat BytePack3( vec3 val )\n{ \n    return dot( floor(val), vec3(1, 256, 65536) );\n}\n\nfloat BytePack3( float x, float y, float z )\n{\n    return BytePack3( vec3( x, y, z ) );\n}\n\nvec3 ByteUnpack3( float x )\n{\n    return mod( floor(vec3(x) \/ vec3(1, 256, 65536)), 256. );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( sampler, vUV, -100.0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in vec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nvec4 ReadMapData( vec2 address )\n{\n    return LoadVec4( MAP_CHANNEL, address );\n}\n    \nvec4 ReadStateData( vec2 address )\n{\n    return LoadVec4( STATE_CHANNEL, address );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Game State\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MAIN_GAME_STATE_BOOT\t\t\t0.\n#define MAIN_GAME_STATE_SKILL_SELECT\t1.\n#define MAIN_GAME_STATE_INIT_LEVEL\t\t2.\n#define MAIN_GAME_STATE_GAME_RUNNING\t3.\n#define MAIN_GAME_STATE_WIN\t\t\t\t4.\n\nstruct GameState\n{\n    float fMainState;\n    float fStateTimer;\n    float fSkill;\n    float fGameTime;\n    \n    vec4 vPrevMouse;\n    \n    float fMap;\n    float fHudFx;\n    \n    float fMessage;\n    float fMessageTimer;\n};\n\nvoid GameState_Reset( out GameState gameState )\n{\n    gameState.fMainState = MAIN_GAME_STATE_BOOT;\n\tgameState.fSkill = 0.;\n    gameState.fGameTime = 0.;\n    gameState.fStateTimer = 0.;\n    \n    gameState.vPrevMouse = iMouse;\n    \n    gameState.fMap = 0.0;\n    gameState.fHudFx = 0.0;\n    \n    gameState.fMessage = -1.0;\n    gameState.fMessageTimer = 0.0;\n}\n\nGameState GameState_Read()\n{\n    GameState gameState;\n    \n    vec2 vAddress = vec2( 0 );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    gameState.fMainState = vData0.x;\n    gameState.fSkill = vData0.y;\n    gameState.fGameTime = vData0.z;\n    gameState.fStateTimer = vData0.w;    \n\n    gameState.vPrevMouse = vData1;\n    \n    gameState.fMap = vData2.x;\n    gameState.fHudFx = vData2.y;\n\n    gameState.fMessage = vData2.z;\n    gameState.fMessageTimer = vData2.w;\n    \n    return gameState;\n}\n\nvoid GameState_Store( GameState gameState, inout vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 vData0 = vec4( gameState.fMainState, gameState.fSkill, gameState.fGameTime, gameState.fStateTimer );    \n\n    vec4 vData1 = vec4( gameState.vPrevMouse );    \n\n    vec4 vData2 = vec4( gameState.fMap, gameState.fHudFx, gameState.fMessage, gameState.fMessageTimer );    \n\n    vec2 vAddress = vec2( 0 );\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.x++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Map Data\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n#define MAX_SECTOR_COUNT 96\n#define MAX_SIDEDEF_COUNT 32\n\n#define SECTOR_NONE -1.\n\nstruct MapInfo\n{\n    float fSectorCount;\n};\n    \nMapInfo ReadMapInfo()\n{\n    MapInfo mapInfo;\n    \n    vec4 vData = ReadMapData( vec2(0.0, 0.0) );\n    \n    mapInfo.fSectorCount = vData.x;\n    \n    return mapInfo;\n}\n\nstruct Sector\n{\n    float fSectorId;\n    float fLightLevel;\n\n    float fFloorHeight;\n    float fCeilingHeight;\n\n    float fFloorTexture;\n    float fCeilingTexture;\n};\n    \nvec2 GetSectorAddress( float fSectorId )\n{\n    return vec2(0.0, 1.0 + fSectorId );\n}\n\nvec2 GetSideDefAddress( float fSectorId, float fSideDefIndex )\n{\n    return vec2(2.0 + fSideDefIndex * 3.0, 1.0 + fSectorId );\n}\n    \nSector Map_ReadSector( float fSectorId )\n{\n    Sector sector;\n    \n    sector.fSectorId = fSectorId;\n    \n    vec2 vAddress = GetSectorAddress( fSectorId );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n\n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sector.fLightLevel = vData0.x;\n\n    sector.fFloorHeight = vData1.x;\n    sector.fCeilingHeight = vData1.y;\n    sector.fFloorTexture = vData1.z;\n    sector.fCeilingTexture = vData1.w;\n    \n    return sector;\n}\n\nstruct SideDef\n{\n    vec2 vA;\n    vec2 vB;\n    float fLength;\n    \n    float fNextSector;\n    \n    float fLightLevel;\n    \n    float fUpperTexture;\n    float fMiddleTexture;\n    float fLowerTexture;    \n    \n    float fFlags;\n};\n\nSideDef Map_ReadSideDefInfo( float fSectorId, float fSideDefIndex )\n{\n    SideDef sideDef;\n    \n    vec2 vAddress = GetSideDefAddress( fSectorId, fSideDefIndex );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;                       \n\n    sideDef.vA = vData0.xy;\n    sideDef.vB = vData0.zw;\n    \n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sideDef.fLength = vData1.x;\n    sideDef.fLightLevel = vData1.y;    \n    sideDef.fMiddleTexture = vData1.z;\n    sideDef.fNextSector = vData1.w;\n    \n    vec4 vData2 = ReadMapData(vAddress);\n    sideDef.fLowerTexture = vData2.x;\n    sideDef.fUpperTexture = vData2.y;\n    sideDef.fFlags = vData2.z;\n    \n    return sideDef;\n}\n\n\/\/ Return:\n\/\/   ray t value\n\/\/   sidedef u value\n\/\/   edge crossing direction\nvec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )\n{\n    vec2 vEdgeDir = sideDef.vB - sideDef.vA;\n    vec2 vOA = sideDef.vA - vRayPos;\n    float fDenom = Cross2d( vRayDir, vEdgeDir );\n    float fRcpDenom = 1.0 \/ fDenom;\n    \n    vec3 vHitTUD;\n    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;\n    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;\n    vHitTUD.z = fDenom;\n    \n    return vHitTUD;    \n}\n\nbool Map_ValidSectorId( MapInfo mapInfo, float fSectorId )\n{\n    return ( fSectorId >= 0.0 && fSectorId < mapInfo.fSectorCount );\n}\n\nbool Map_PointInSector( vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n    {\n        float fSideDefIndex = float(iSideDefIndex);\n        \n        SideDef sideDef = Map_ReadSideDefInfo( sector.fSectorId, fSideDefIndex );                        \n        \n        if ( sideDef.fLength <= 0.0)\n        {\n            break;\n        }\n\n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( MapInfo mapInfo, vec2 vPos, float fSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, fSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( fSectorId );\n\n    return Map_PointInSector( vPos, sector );\n}\n\nfloat Map_SeekSector( MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    {\n        float fSectorId = float(iSectorIndex);\n        \n        if ( !Map_ValidSectorId( mapInfo, fSectorId ) )\n        {\n            break;\n        }\n\n        if ( Map_PointInSector( mapInfo, vPos, fSectorId ) )\n        {\n            return fSectorId;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout float fSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapInfo, vPos, fSectorId ) )\n    {\n        float fNewSectorId = Map_SeekSector( mapInfo, vPos );\n        \n        if ( fNewSectorId != SECTOR_NONE )\n        {\n        \tfSectorId = fNewSectorId;\n        }                \n    }\n}\n\nstruct TraceResult\n{\n    float fDist;\n    vec3 vTexture; \/\/ UV \/ TexureId during trace. Resolved to RGB for sprite rendering\n  \tfloat fLightLevel;\n    float fSector;\n};\n\nstruct TraceSectorState\n{\n    float fEnterDist;\n    float fExitY;\n    float fNextSector;\n    bool bNoUpper;\n};\n\nvoid TraceSideDef( vec3 vRayOrigin, vec3 vRayDir, inout TraceResult result, inout TraceSectorState sectorState, Sector sector, SideDef sideDef )\n{    \n\tvec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vRayOrigin.xz, vRayDir.xz );\n    float fHitT = vHitTUD.x;\n    float fHitU = vHitTUD.y;\n    float fDenom = vHitTUD.z;\n\n    if( \n        \/\/ We hit the edge between the endpoints\n        (fHitU >= 0.0) && (fHitU < 1.0) &&\n        \/\/ Hit point is further than sector entrance distance\n        (fHitT > sectorState.fEnterDist) && \n        \/\/ Track closest hit\n        (fHitT < result.fDist) && \n        \/\/ Ignore faces entering sector\n        (fDenom < 0.0)\n      )\n    {\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        sectorState.fExitY = fHitY;\n        result.fDist = fHitT;\n        \n        if( (sectorState.fExitY > sector.fFloorHeight) )                \n        {\n            sectorState.fNextSector = SECTOR_NONE;\n            if( sideDef.fNextSector == SECTOR_NONE && sideDef.fMiddleTexture != 0.0 && (sectorState.fExitY < sector.fCeilingHeight ) )\n            {\n                result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY);\n                result.vTexture.z = sideDef.fMiddleTexture;\n                result.fLightLevel = sideDef.fLightLevel;\n                sectorState.bNoUpper = false;\n            }\n            else\n            {\n                Sector nextSector = Map_ReadSector( sideDef.fNextSector );\n                                \n\t\t        bool bNoUpper = mod(sideDef.fFlags, 2.0) != 0.0;\n\n\t            if (sectorState.fExitY < sector.fCeilingHeight || bNoUpper )\n                {                                    \n                    if( nextSector.fFloorHeight > sector.fFloorHeight && fHitY > sector.fFloorHeight && fHitY < nextSector.fFloorHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fFloorHeight);\n                        result.vTexture.z = sideDef.fLowerTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }            \n                    else\n                    if( sideDef.fUpperTexture != 0.0 && nextSector.fCeilingHeight < sector.fCeilingHeight && fHitY < sector.fCeilingHeight && fHitY > nextSector.fCeilingHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fCeilingHeight);\n                        result.vTexture.z = sideDef.fUpperTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }\n                    else\n                    {\n                        sectorState.bNoUpper = bNoUpper;\n                        sectorState.fNextSector = sideDef.fNextSector;                          \n                    }\n                }\n            }\n        }\n    }\n}\n\nTraceResult Map_Trace( MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, float fSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.fSector = SECTOR_NONE;\n    \n    for(int iSectorIndex=0; iSectorIndex<20; iSectorIndex++)\n    {\n        if ( fSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( fSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.fNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.fSector = fSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n        {\n            float fSideDefIndex = float(iSideDefIndex);\n            \n            SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n            \n            if ( sideDef.fLength <= 0.0)\n            {\n\t\t\t\tbreak;\n            }\n\n            TraceSideDef( vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.vTexture.z = sector.fFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.vTexture.z = sector.fCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }        \n\n        fSectorId = sectorState.fNextSector;\n    }\n    \n    if ( result.vTexture.z == 1.0 )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Entity Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ENTITY_TYPE_NONE -1.\n\nstruct Entity\n{\n    float fId;\n    \n    float fType;\n    float fSubType;\n    float fSectorId;    \n\n    vec3 vPos;\n    float fYaw;\n    float fPitch;\n    \n    vec3 vVel;\n    float fYawVel;\n    \n    float fHealth;\n    float fArmor;    \n    \n    float fUseWeapon;    \n    float fHaveShotgun;\n    \n    float fTookDamage; \/\/ For HUD damage indicator\n    float fEvent; \/\/ Message event for UI \"Picked up an armor bonus\" etc.\n    \n    float fTimer; \/\/ Weapon reload for player, think timer for AI\n    float fTarget; \/\/ AI nemesis and also used for player aim up \/ down \n    float fFrameFlags;\n};\n    \n#define ENTITY_DATA_YPOS 8.\n#define ENTITY_DATA_SIZE 4.\n\n#define ENTITY_MAX_COUNT 128.\n    \n#define ENTITY_NONE -1.\n    \nfloat Entity_GetOutputId( vec2 fragCoord )\n{\n    if (\n           fragCoord.y < ENTITY_DATA_YPOS\n        || fragCoord.y >= (ENTITY_DATA_YPOS + ENTITY_DATA_SIZE)\n        || fragCoord.x >= ENTITY_MAX_COUNT\n       )\n    {\n        return ENTITY_NONE;        \n    }\n\n    return floor(fragCoord.x);\n}\n\nbool Entity_IdValid( float fEntityId )\n{\n    return ( fEntityId >= 0. && fEntityId < ENTITY_MAX_COUNT );\n}\n\nvoid Entity_Clear( inout Entity entity )\n{\n    entity.fType = ENTITY_TYPE_NONE;\n    entity.vPos = vec3(0);\n    entity.fSectorId = SECTOR_NONE;\n    entity.fYaw = 0.0;\n    entity.vVel = vec3(0);\n    entity.fYawVel = 0.0;\n    entity.fPitch = 0.0;\n    entity.fHealth = 0.0;\n    entity.fArmor = 0.0;\n    entity.fTimer = 0.0;\n    entity.fTarget = ENTITY_NONE;\n    entity.fFrameFlags = 0.0;    \n    entity.fUseWeapon = 1.;\n    entity.fHaveShotgun = 0.;\n    entity.fTookDamage = 0.;\n    entity.fEvent = 0.;\n}\n\nEntity Entity_Read( float fEntityId )\n{\n    Entity entity;\n    \n    entity.fId = fEntityId;\n    \n    vec2 vAddress = vec2( fEntityId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vec3 vUnpacked0x = ByteUnpack3( vData0.x ) - 1.;\n    vAddress.y++;\n    \n    \n    entity.fType = vUnpacked0x.x;\n    entity.fSubType = vUnpacked0x.y;\n    entity.fSectorId = vUnpacked0x.z;\n    \n    entity.fFrameFlags = vData0.y;\n    \n    entity.fTarget = vData0.z;\n    entity.fTimer = vData0.w;\n    \n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vPos = vData1.xyz;\n    entity.fYaw = vData1.w;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vVel = vData2.xyz;\n    entity.fYawVel = vData2.w;\n\n    vec4 vData3 = ReadStateData( vAddress );\n    vec2 vUnpacked3x = ByteUnpack2(vData3.x);\n    vec2 vUnpacked3y = ByteUnpack2(vData3.y);\n    vec2 vUnpacked3z = ByteUnpack2(vData3.z) -1.;\n    vAddress.y++;\n    \n    entity.fHealth = vUnpacked3x.x;\n    entity.fArmor = vUnpacked3x.y;\n    float fPackedWeaponInfo = vData3.y;\n    entity.fUseWeapon = vUnpacked3y.x;\n    entity.fHaveShotgun = vUnpacked3y.y;\n    entity.fTookDamage = vUnpacked3z.x;\n    entity.fEvent = vUnpacked3z.y;\n    entity.fPitch = vData3.w;\n    \n    return entity;\n}\n\nvoid Entity_Store( Entity entity, inout vec4 fragColor, in vec2 fragCoord )\n{\n    if ( !Entity_IdValid( entity.fId ) ) \n        return;\n\n    float fPacked0 = BytePack3( vec3(entity.fType, entity.fSubType, entity.fSectorId ) + 1. );\n\n    entity.fHealth = floor( clamp( entity.fHealth, 0.0, 255.0 ) );\n    entity.fArmor = floor( clamp( entity.fArmor, 0.0, 255.0 ) );\n    float fPackedHealthAndArmor = BytePack2( vec2( entity.fHealth, entity.fArmor ) ); \n\tfloat fPackedWeaponInfo = BytePack2( vec2( entity.fUseWeapon, entity.fHaveShotgun ) );\n\tfloat fPackedEvents = BytePack2( vec2( entity.fTookDamage, entity.fEvent ) + 1. );\n    \n    vec2 vAddress = vec2( entity.fId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = vec4( fPacked0, entity.fFrameFlags, entity.fTarget, entity.fTimer );    \n    vec4 vData1 = vec4( entity.vPos, entity.fYaw );\n    vec4 vData2 = vec4( entity.vVel, entity.fYawVel );\n    vec4 vData3 = vec4( fPackedHealthAndArmor, fPackedWeaponInfo, fPackedEvents, entity.fPitch );\n\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData3, fragColor, fragCoord );\n    vAddress.y++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Weapon Defs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define WEAPON_TYPE_PISTOL\t\t0.\n#define WEAPON_TYPE_SHOTGUN\t\t1.\n#define WEAPON_TYPE_FIREBALL\t2.\n\nstruct WeaponDef\n{\n    float fWeaponType;\n    float fReloadTime;\n    float fProjectileCount;\n    float fBaseDamagePerProjectile;\n    float fRandomDamagePerProjectile;\n    float fSpread;\n};\n\nWeaponDef Weapon_GetDef( float fWeaponType, bool bEnemy )\n{\n    WeaponDef weaponDef;\n\n    if ( fWeaponType == WEAPON_TYPE_SHOTGUN )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_SHOTGUN;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = bEnemy ? 3.0 : 7.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = radians(4.0);\n    }\n    else\n    if ( fWeaponType == WEAPON_TYPE_FIREBALL )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_FIREBALL;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = 5.0;\n        weaponDef.fRandomDamagePerProjectile = 0.0;\n        weaponDef.fSpread = radians(0.0);\n    }\n    else\n    {\n        \/\/ Pistol\n        weaponDef.fWeaponType = WEAPON_TYPE_PISTOL;\n        weaponDef.fReloadTime = 0.5;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = bEnemy ? radians(4.0) : 0.0;\n    }\n    \n    return weaponDef;\n}\n    \n#define ENTITY_TYPE_PLAYER \t0.\n\n#define ENTITY_TYPE_BARREL \t1.\n#define ENTITY_SUB_TYPE_BARREL_INACTIVE\t\t\t0.\n#define ENTITY_SUB_TYPE_BARREL_EXPLODING\t\t1.\n#define ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE\t\t2.\n\n#define ENTITY_TYPE_ITEM \t2.\n#define ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS \t0.\n#define ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS \t1.\n#define ENTITY_SUB_TYPE_ITEM_SHOTGUN \t\t2.\n#define ENTITY_SUB_TYPE_ITEM_STIMPACK\t\t3.\n#define ENTITY_SUB_TYPE_ITEM_GREENARMOR\t\t4.\n#define ENTITY_SUB_TYPE_ITEM_BLUEARMOR\t\t5.\n#define ENTITY_SUB_TYPE_ITEM_MEDIKIT\t\t6.\n\n#define ENTITY_TYPE_DECORATION 3.\n#define ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS\t\t\t0.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER\t\t\t1.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT\t\t2.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_IMP\t\t\t\t3.\n#define ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR\t4.\n#define ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP\t\t\t5.\n\n#define ENTITY_TYPE_ENEMY\t4.\n#define ENTITY_SUB_TYPE_ENEMY_TROOPER \t\t0.\n#define ENTITY_SUB_TYPE_ENEMY_IMP \t\t\t1.\n#define ENTITY_SUB_TYPE_ENEMY_SERGEANT \t\t2.\n\n#define ENTITY_TYPE_BULLET 5.\n#define\tENTITY_SUB_TYPE_BULLET_WALL\t\t\t0.\n#define\tENTITY_SUB_TYPE_BULLET_FLESH\t\t1.\n\n#define ENTITY_TYPE_DOOR 6.\n\n#define ENTITY_TYPE_PLATFORM 7.\n\n#define ENTITY_TYPE_FIREBALL 8.\n#define ENTITY_SUB_TYPE_FIREBALL 0.\n#define ENTITY_SUB_TYPE_FIREBALL_IMPACT 1.\n\n\n#define ENTITY_FRAME_FLAG_FIRE_WEAPON\t\t1.\n#define ENTITY_FRAME_FLAG_DROP_ITEM\t\t\t2.\n\n\n#define ENEMY_STATE_IDLE\t\t\t\t0.\n#define ENEMY_STATE_PAIN\t\t\t\t1.\n#define ENEMY_STATE_WALK_RANDOM\t\t\t2.\n#define ENEMY_STATE_WALK_TO_TARGET\t\t3.\n#define ENEMY_STATE_STAND\t\t\t\t4.\n#define ENEMY_STATE_FIRE\t\t\t\t5.\n#define ENEMY_STATE_DIE\t\t\t\t\t6.\n\n\n#define EVENT_HEALTH_BONUS \t1.\n#define EVENT_ARMOR_BONUS \t2.\n#define EVENT_SHOTGUN \t\t3.\n#define EVENT_STIMPACK\t\t4.\n#define EVENT_GREENARMOR\t5.\n#define EVENT_BLUEARMOR\t\t6.\n#define EVENT_MEDIKIT\t\t7.\n#define EVENT_DIED\t\t\t8.\n\n#define MESSAGE_NONE\t\t\t-1.\n#define MESSAGE_HEALTH_BONUS \t0.\n#define MESSAGE_ARMOR_BONUS \t1.\n#define MESSAGE_SHOTGUN \t\t2.\n#define MESSAGE_STIMPACK\t\t3.\n#define MESSAGE_GREENARMOR\t\t4.\n#define MESSAGE_BLUEARMOR\t\t5.\n#define MESSAGE_MEDIKIT\t\t\t6.\n#define MESSAGE_HUD_TEXT\t\t7.\n#define MESSAGE_CHOOSE_SKILL\t8.\n#define MESSAGE_SKILL_1\t\t\t9.\n#define MESSAGE_SKILL_2\t\t\t10.\n#define MESSAGE_SKILL_3\t\t\t11.\n#define MESSAGE_SKILL_4\t\t\t12.\n#define MESSAGE_SKILL_5\t\t\t13.\n#define MESSAGE_HANGAR\t\t\t14.\n#define MESSAGE_FINISHED\t\t15.\n#define MESSAGE_KILLS\t\t\t16.\n#define MESSAGE_ITEMS\t\t\t17.\n#define MESSAGE_SECRET\t\t\t18.\n#define MESSAGE_TIME\t\t\t19.\n#define MESSAGE_SELECT\t\t\t20.\n#define MESSAGE_COUNT\t\t\t21.\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Start of Font code\n\nconst vec3 _SPACE_ = vec3(0,0,5);\nconst vec3 _EXCLAMATION_ = vec3(49539,384,4);\nconst vec3 _QUOTE_ = vec3(2331,0,7);\nconst vec3 _HASH_ = vec3(167818,1311,7);\nconst vec3 _DOLLAR_ = vec3(508575,69524,7);\nconst vec3 _PERCENT_ = vec3(232984,4487,8);\nconst vec3 _AMPERSAND_ = vec3(249630,8095,8);\nconst vec3 _APOSTROPHE_ = vec3(259,0,4);\nconst vec3 _L_PAREN_ = vec3(115614,3847,7);\nconst vec3 _R_PAREN_ = vec3(462351,1948,7);\nconst vec3 _ASTERISK_ = vec3(509700,526,7);\nconst vec3 _PLUS_ = vec3(114944,2,5);\nconst vec3 _COMMA_ = vec3(0,33152,4);\nconst vec3 _MINUS_ = vec3(245760,0,6);\nconst vec3 _PERIOD_ = vec3(0,384,4);\nconst vec3 _SLASH_ = vec3(232984,391,7);\nconst vec3 _0_ = vec3(843678,3903,8);\nconst vec3 _1_ = vec3(99206,774,5);\nconst vec3 _2_ = vec3(1039935,8067,8);\nconst vec3 _3_ = vec3(1023007,4024,8);\nconst vec3 _4_ = vec3(511387,3096,7);\nconst vec3 _5_ = vec3(508319,3998,7);\nconst vec3 _6_ = vec3(1033150,7987,8);\nconst vec3 _7_ = vec3(793663,6192,8);\nconst vec3 _8_ = vec3(498111,8115,8);\nconst vec3 _9_ = vec3(1038751,4024,8);\nconst vec3 _COLON_ = vec3(3,384,4);\nconst vec3 _SEMICOLON_ = vec3(384,33152,4);\nconst vec3 _LESSTHAN_ = vec3(98816,66307,5);\nconst vec3 _EQUALS_ = vec3(114688,896,5);\nconst vec3 _GREATERTHAN_ = vec3(49280,16774,5);\nconst vec3 _QUESTION_MARK_ = vec3(925568,114751,8);\nconst vec3 _AT_ = vec3(1532350,65237,9);\nconst vec3 _A_ = vec3(1038782,6579,8);\nconst vec3 _B_ = vec3(515135,8123,8);\nconst vec3 _C_ = vec3(115646,7943,8);\nconst vec3 _D_ = vec3(842783,4027,8);\nconst vec3 _E_ = vec3(1034174,7951,8);\nconst vec3 _F_ = vec3(508863,387,8);\nconst vec3 _G_ = vec3(902078,7991,8);\nconst vec3 _H_ = vec3(1038771,6579,8);\nconst vec3 _I_ = vec3(49539,387,4);\nconst vec3 _J_ = vec3(792624,8120,8);\nconst vec3 _K_ = vec3(249267,6555,8);\nconst vec3 _L_ = vec3(49539,8071,8);\nconst vec3 _M_ = vec3(2096099,12779,9);\nconst vec3 _N_ = vec3(1039287,7615,8);\nconst vec3 _O_ = vec3(843678,3903,8);\nconst vec3 _P_ = vec3(1039423,387,8);\nconst vec3 _Q_ = vec3(843678,790335,8);\nconst vec3 _R_ = vec3(515135,6587,8);\nconst vec3 _S_ = vec3(508319,3992,7);\nconst vec3 _T_ = vec3(198207,1548,8);\nconst vec3 _U_ = vec3(842163,3903,8);\nconst vec3 _V_ = vec3(232859,526,7);\nconst vec3 _W_ = vec3(2094563,15359,9);\nconst vec3 _X_ = vec3(466807,15294,9);\nconst vec3 _Y_ = vec3(498099,1548,8);\nconst vec3 _Z_ = vec3(232991,3975,7);\nconst vec3 _L_SQUARE_BRACKET_ = vec3(49543,899,5);\nconst vec3 _BACKSLASH_ = vec3(230275,3100,7);\nconst vec3 _R_SQUARE_BRACKET_ = vec3(99079,902,5);\nconst vec3 _CARET_ = vec3(444164,0,7);\nconst vec3 _UNDERSCORE_ = vec3(0,1032192,8);\n\nfloat Font_DecodeBitmap( vec2 vCoord, vec3 vCharacter )\n{\n    vCoord = floor( vCoord );\n\n    float fRow = vCoord.y - 1.;\n    float fCol = vCoord.x - 1.;\n    \n    if ( fRow < 0. || fRow >= 6. ) return 0.0;\n    if ( fCol < 0. || fCol >= 7. ) return 0.0;\n    \n    float fRowBits = 0.;\n        \n   \tif ( fRow == 0. ) \t\t\tfRowBits = vCharacter.x;\n    else  if ( fRow == 1. ) \tfRowBits = vCharacter.x * ( 1. \/ 128. );\n    else  if ( fRow == 2. ) \tfRowBits = vCharacter.x * ( 1. \/ 16384. );\n    else  if ( fRow == 3. ) \tfRowBits = vCharacter.y;\n    else  if ( fRow == 4. ) \tfRowBits = vCharacter.y * ( 1. \/ 128. );\n    else \t\t\t\t\t\tfRowBits = vCharacter.y * ( 1. \/ 16384. );\n        \n    return mod( floor( fRowBits * pow( .5, fCol ) ), 2.0 );\n}\n\n\nstruct PrintState\n{\n    vec2 vTexCoord;\n    vec2 vOrigin;\n    vec2 vPos;\n    \n    vec3 vColor;\n    vec3 vOutline;\n};\n    \nvoid Print_MoveTo( inout PrintState printState, vec2 vPos )\n{\n    printState.vOrigin = printState.vTexCoord - vPos;\n    printState.vPos = printState.vOrigin;\n}\n\nvoid Print_Newline( inout PrintState printState )\n{\n    printState.vPos.x = printState.vOrigin.x;\n    printState.vPos.y -= 8.0;\n}\n\nvoid Print_Color( inout PrintState printState, vec3 vColor )\n{\n    printState.vColor = vColor;\n}\n\nvoid Print_Init( out PrintState printState, vec2 vTexCoord )\n{\n    printState.vTexCoord = vTexCoord;        \n    printState.vOrigin = vTexCoord;\n    printState.vPos = vTexCoord;\n    printState.vColor = vec3(1,0,0);\n    printState.vOutline = vec3(.3,0,0);\n    Print_MoveTo( printState, vec2(0) ); \n}\n\nvoid Print_Space( inout PrintState printState )\n{\n    printState.vPos.x -= 5.0;\n}\n\nbool Print_Test( inout PrintState printState, vec3 vCharacter, float fSpacing )\n{\n    if ( vCharacter.z == -1.0 )\n    {\n        Print_MoveTo( printState, vCharacter.xy );\n        return false;\n    }\n    \n    if ( printState.vPos.x < vCharacter.z )\n        return true;\n         \n\tprintState.vPos.x -= vCharacter.z + fSpacing;\n    return false;\n}\n\nvoid Print_Char( inout PrintState printState, inout vec3 vResult, vec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    if ( fBitmap > 0.0 ) vResult = printState.vColor;\n    \n    printState.vPos.x -= vCharacter.z - 1.;\n}\n\nvoid Print_HudChar( inout PrintState printState, inout vec3 vResult, vec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    float fShadow = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n\n    if ( fBitmap > 0.0 ) vResult = printState.vColor * 0.5 + 0.5 * (printState.vPos.y \/ 8.);\n    else if ( fShadow > 0.0 ) vResult *= 0.5;\n    \n    printState.vPos.x -= vCharacter.z;\n}\n\nvoid Print_FancyChar( inout PrintState printState, inout vec3 vResult, vec3 vCharacter )\n{\n    float fBitmapTL = Font_DecodeBitmap( printState.vPos - vec2(-1,-1), vCharacter );\n    float fBitmapTC = Font_DecodeBitmap( printState.vPos - vec2( 0,-1), vCharacter );\n    float fBitmapTR = Font_DecodeBitmap( printState.vPos - vec2( 1,-1), vCharacter );\n\n    float fBitmapCL = Font_DecodeBitmap( printState.vPos - vec2(-1, 0), vCharacter );\n    float fBitmapCC = Font_DecodeBitmap( printState.vPos - vec2( 0, 0), vCharacter );\n    float fBitmapCR = Font_DecodeBitmap( printState.vPos - vec2( 1, 0), vCharacter );\n    \n    float fBitmapBL = Font_DecodeBitmap( printState.vPos - vec2(-1, 1), vCharacter );\n    float fBitmapBC = Font_DecodeBitmap( printState.vPos - vec2( 0, 1), vCharacter );\n    float fBitmapBR = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n    \n    float fOutline \t= min( 1., fBitmapTL + fBitmapTC + fBitmapTR + fBitmapCL + fBitmapCR + fBitmapBL + fBitmapBC + fBitmapBR );    \n    float fShade = (fBitmapTL * .5 - fBitmapBR * .5 ) + 0.5;\n    \n    if ( fBitmapCC > 0.0 ) vResult = printState.vColor * (fShade * 0.25 + 0.75);\n    else\n    if ( fOutline > 0.0 ) vResult = printState.vOutline;\n    \n    printState.vPos.x -= vCharacter.z;\n}\n\n\/\/ End of font code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\nEntity g_playerEnt;\nGameState g_gameState;\n\nfloat hash2D(vec2 p)    \n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = Hash( fl );\n\tfloat h1 = Hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nvec3 Tex( vec2 vTexCoord )\n{\n    vec2 vSize = vec2(64.0);    \n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n    \n    vTexCoord = floor( vTexCoord );\n    \n\tfloat fRandom = fbm( vTexCoord, fPersistence );\n    \n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\treturn col;    \n}\n\nvoid VWipe( inout vec2 vPixel, float fFade, vec2 vSize )\n{\n    float fEffectTime = max( 0.0, fFade );\n    float fEffectOffset = max(fEffectTime - 1.0, 0.0) - Hash(floor(vPixel.x)) * 0.4;\n\n    fEffectOffset = clamp(fEffectOffset, 0.0, 1.0);\n    \t\n    vPixel.y += fEffectOffset * vSize.y;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raymarching\n\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.001;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n\nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}\n\nvec2 Segment_Internal( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat Segment( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment_Internal( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\n#define MAT_BG 0.0\n#define MAT_SHOTGUN 1.0\n#define MAT_PISTOL 2.0\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    vec3 vWeaponPos = vPos;\n    \n    if ( g_playerEnt.fHealth <= 0.0 )\n    {    \n        float fDeathFall = 0.0;\n\n        \/\/ Death\n        if( g_playerEnt.fHealth <= 0.0 )\n        {\n            fDeathFall = 1.0 - (g_playerEnt.fTimer \/ 1.5);\n        }\n\n    \tvWeaponPos.y += fDeathFall * 5.0;\n    }        \n    \n    \n    if ( g_playerEnt.fUseWeapon == 2.0 )\n    {\n\t    vWeaponPos += vec3(0.0, 0.0, 1.0) * pow( g_playerEnt.fTimer, 3.0) * 5.0 ;\n        \n        float fDist = Segment( vWeaponPos, vec3(0,-1.0,2.5), vec3(0, -5, 25), .2, 0.2 );\n        float fDist2 =  Segment( vWeaponPos, vec3(0, -4.5, 23), vec3(0, -4.5, 25), .1, 0.1 );\n        fDist = min( fDist, fDist2 );\n        return SceneResult( fDist, MAT_SHOTGUN, vec3(0.0) );    \n    }\n    \n    \/\/ pistol\n    vWeaponPos += vec3(0.0, 0.0, 1.0) * pow( g_playerEnt.fTimer, 3.0) * 10.0 ;\n    \n    float fDist = Segment( vWeaponPos, vec3(0,-0.8,0), vec3(0, -5, 20), .1, 0.1 );\n\treturn SceneResult( fDist, MAT_PISTOL, vec3(0.0) );    \n    \n    \/\/return SceneResult( length(vPos - vec3(0.0, 1.0, 5.0)) - 0.5, MAT_SHOTGUN, vec3(0.0) );\n}\n\nvec4 MuzzleFlash( vec2 vUV, vec2 vPos, vec2 vSize )\n{\n    vec4 vResult = vec4( 0.0 );\n    vec2 vLocalPos = vUV - vPos;\n    vLocalPos = vLocalPos \/ vSize;\n    float fDist = length( vLocalPos );\n    fDist += abs(vLocalPos.x) + abs(vLocalPos.y);\n\n    float fFactor = fDist * 5.0 + fbm( vLocalPos * 100., 0.8);\n\n    \/\/float fAmount = exp2( * fFactor );\n\n    if ( fFactor < 3.0)\n    {\n        fFactor = 1.0 - fFactor \/ 3.0;\n\n        fFactor = pow( 0.5 + fFactor, 5.0 );\n\n        vResult.rgb = vec3( fFactor, pow(fFactor, 2.0) * .4, pow(fFactor, 3.0) * .2) * 5.0;\n        vResult.a = 1.0;\n\n    }\n    \n    return vResult;\n}\n\nvec4 ViewmodelSprite( vec2 vUV, float fLightLevel )\n{\n    vec4 vResult = vec4( 0 );\n    \n    vec2 vBoundsMin = vec2(0);\n    vec2 vBoundsMax = vec2(1);\n    \n    if ( g_playerEnt.fUseWeapon == 2.0 )\n    {\n    \tvBoundsMin = vec2(0.4, 0.0);\n    \tvBoundsMax = vec2(0.6,0.25);\n    }\n    else\n    {\n    \tvBoundsMin = vec2(0.47, 0.0);\n    \tvBoundsMax = vec2(0.53,0.15);\n    }\n    \n    if ( all( greaterThanEqual( vUV, vBoundsMin ) ) &&\n         all( lessThan( vUV, vBoundsMax ) ) )\n    {       \n        vec3 vCameraPos = vec3(0.0, 0.0, 0.0);    \n        vec2 vWindowPos = vec2(vUV.x * 2.0 - 1.0, vUV.y * 2.0 - 1.0);\n        vec3 vCameraDir = normalize( vec3(vWindowPos, 3.0) - vCameraPos );\n\n        SceneResult sceneResult = Scene_Trace( vCameraPos, vCameraDir, 1000.0 );\n\n        if ( sceneResult.fDist < 400.0 )\n        {\n\n            vec3 vHitPos = vCameraPos + vCameraDir * sceneResult.fDist;\n\n            vec3 vNormal = Scene_GetNormal( vHitPos );\n\n            vec3 vAmbientLight = vec3(0.1);\n            vec3 vLightDir = normalize( vec3( 0.2, 0.3, 0.2 ) );\n            vec3 vLightColor = vec3(1.0);\n\n            float fShade = max( 0.0, dot( vNormal, vLightDir ) );\n\n            vec3 vDiffuseCol = vec3(.1);\n            float fSpecPow = 10.0;\n            float fSpecIntensity = 200.0;\n\n            if ( sceneResult.fObjectId == MAT_SHOTGUN )\n            {\n                vDiffuseCol = vec3(.1);\n                fSpecPow = 10.0;\n                fSpecIntensity = 200.0;        \n            }\n            else\n            if ( sceneResult.fObjectId == MAT_PISTOL )\n            {\n                vDiffuseCol = vec3(.2);\n                fSpecPow = 50.0;\n                fSpecIntensity = 20.0;        \n\n            }\n\n            vec3 vDiffuseLight = vAmbientLight + fShade * vLightColor;\n            vResult.rgb = vDiffuseCol * vDiffuseLight;\n\n            vec3 vRefl = reflect( vCameraDir, vNormal );\n            float fDot = max(0.0, dot( vRefl, vLightDir )) * fShade;\n            float fSpec = pow( fDot, fSpecPow );\n            vResult.rgb += fSpec * fSpecIntensity;\n\n            vResult.rgb = 1.0 - exp2( vResult.rgb * -2.0 );\n            vResult.rgb = pow( vResult.rgb, vec3(1.0 \/ 1.5) );\n            vResult.rgb = clamp( vResult.rgb, vec3(0.0), vec3(1.0) );\n            vResult.rgb *= fLightLevel;\n            vResult.rgb = clamp( vResult.rgb, vec3(0.0), vec3(1.0) );\n\n            vResult.a = 1.0;\n\n            return vResult;\n        }\n        else\n        {\n            \/\/ Bounds debug\n\t\t\t\/\/return vec4(1,0,0,1);            \n        }\n    }\n    \n    \/\/ muzzle flash sprite\n       \n    if(  g_playerEnt.fHealth > 0.0 )\n    {    \n        if ( g_playerEnt.fUseWeapon == 2.0 )\n        {\n       \t\tif ( g_playerEnt.fTimer > 0.9 )\n\t    \t{\n                vec4 vMuzzleFlash = MuzzleFlash( vUV, vec2(0.5, 0.2), vec2(0.5, 0.5) );\n                \n                if ( vMuzzleFlash.a > 0.0 )\n                {\n                    return vMuzzleFlash;\n                }\n            }\n        }\n        else\n        {\n       \t\tif ( g_playerEnt.fTimer > 0.45 )\n\t    \t{\n                vec4 vMuzzleFlash = MuzzleFlash( vUV, vec2(0.5, 0.12), vec2(0.25, 0.25) );\n                \n                if ( vMuzzleFlash.a > 0.0 )\n                {\n                    return vMuzzleFlash;\n                }\n            }\n        }\t            \n\t}\n    \n    return vResult;    \n}\n\n#define FONT_POS \tvec2(280,0)\n#define FONT_CHAR \tvec2(16,0)\n\n\nvec4 NumFont_Char( vec2 vTexCoord, float fDigit )\n{\n \tif ( fDigit < 0.0 )\n    \treturn vec4(0.0);\n    \n    vTexCoord = floor(vTexCoord * vec2(14.0, 16.0)) + 0.5 + FONT_POS;\n    vTexCoord += fDigit * FONT_CHAR;\n    \n    vec2 vScale = vec2(1.0) \/ iChannelResolution[2].xy;\n    \n    return texture2D( iChannel2, (vTexCoord - vec2( 0, 0) ) * vScale );\n    \/*\n    float fSample_TL = texture2D( iChannel0, (vTexCoord - vec2(-1, 1) ) * vScale ).a;\n    float fSample_TC = texture2D( iChannel0, (vTexCoord - vec2( 0, 1) ) * vScale ).a;\n    float fSample_TR = texture2D( iChannel0, (vTexCoord - vec2( 1, 1) ) * vScale ).a;\n    \n    float fSample_CL = texture2D( iChannel0, (vTexCoord - vec2(-1, 0) ) * vScale ).a;\n    float fSample_CC = texture2D( iChannel0, (vTexCoord - vec2( 0, 0) ) * vScale ).a;\n    float fSample_CR = texture2D( iChannel0, (vTexCoord - vec2( 1, 0) ) * vScale ).a;\n    float fSample_CS = texture2D( iChannel0, (vTexCoord - vec2( 2, 0) ) * vScale ).a;\n\n    float fSample_BL = texture2D( iChannel0, (vTexCoord - vec2(-1,-1) ) * vScale ).a;\n    float fSample_BC = texture2D( iChannel0, (vTexCoord - vec2( 0,-1) ) * vScale ).a;\n    float fSample_BR = texture2D( iChannel0, (vTexCoord - vec2( 1,-1) ) * vScale ).a;\n    float fSample_BS = texture2D( iChannel0, (vTexCoord - vec2( 2,-1) ) * vScale ).a;\n    \n    \n    float fSample_SC = texture2D( iChannel0, (vTexCoord - vec2( 0,-2) ) * vScale ).a;\n    float fSample_SR = texture2D( iChannel0, (vTexCoord - vec2( 1,-2) ) * vScale ).a;\n    float fSample_SS = texture2D( iChannel0, (vTexCoord - vec2( 2,-2) ) * vScale ).a;\n   \n    float fOutline = min( 1.0, \n\t\tfSample_TL + fSample_TC + fSample_TR +\n\t\tfSample_CL + fSample_CC + fSample_CR +\n\t\tfSample_BL + fSample_BC + fSample_BR );\n    \n    float fShadow = min( 1.0, \n\t\tfSample_CC + fSample_CR + fSample_CS +\n\t\tfSample_BC + fSample_BR + fSample_BS + \n\t\tfSample_SC + fSample_SR + fSample_SS);\n    \t\n    float fMain = fSample_CC;\n    \n    vec4 vResult = vec4(0.0);\n    \n#ifndef FULL_HUD    \n    return vec4(1, 0, 0, fMain);\n#endif \/\/ FULL_HUD    \n    float fAlpha = min( 1.0, fOutline + fMain + fShadow );\n    \n    float fShade = fSample_TL * 1.5 + fSample_BR * -1.5 + fSample_TC * 1.0 + fSample_CL * 1.0 \n        + fSample_BC * -1.0 + fSample_CR * -1.0;\n    \n    fShade = clamp( fShade * 0.25, 0.0, 1.0 );\n    \n    fShade = fShade * .3 + .7;\n    \n    vec3 vColor = vec3( .2 ); \/\/ drop shadow\n    \n    if ( fOutline > 0.0 )\n        vColor = vec3(.4, 0, 0); \/\/ outline\n\n    if ( fMain > 0.0 )\n        vColor = vec3(fShade, 0, 0); \/\/ main text\n            \n    vResult = vec4(vColor, fAlpha);\n    \n    return vResult;\n\t*\/\n}\n\nvec4 PrintHUDPercent(const in vec2 vStringUV, const in float fValue )\n{\n    float fMaxDigits = 3.0;\n    if ((vStringUV.y < 0.0) || (vStringUV.y >= 1.0)) return vec4(0.0);\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringUV.x);\n\tfloat fCharacter = -1.0;\n    \n\tif(fDigitIndex > (-0.0 - 1.01)) {\n\t\tif(fDigitIndex <= fBiggestIndex) {\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tfCharacter = 10.0; \/\/ Percent\n\t\t\t} else {\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharacter = floor(mod(kFix+fDigitValue, 10.0));\n\t\t\t}\t\t\n\t\t}\n\t}\n    \n    return NumFont_Char( fract(vStringUV), fCharacter );\n}\n\n\nvec4 GetHudText( vec2 vPos, float fHealth, float fArmor )\n{    \n    vPos = floor( vPos );\n\tvec4 vHealth = PrintHUDPercent( vec2( (vPos - vec2(33,12)) \/ vec2(14,16)), fHealth );\n    if ( vHealth.a > 0.0 )\n    \treturn vHealth;\n    \n\tvec4 vArmor = PrintHUDPercent( vec2( (vPos - vec2(164,12)) \/ vec2(14,16)), fArmor );\n    if ( vArmor.a > 0.0 )\n    \treturn vArmor;\n    \n    return vec4(0.0);\n}\n\n\nvec4 SampleScene( vec2 vPixelCoord, vec2 vResolution, float fLightLevel )\n{\n    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 32.0);\n    vec4 vResult = texture2D( iChannel3, (vScenePixelCoord + 0.5) \/ iChannelResolution[2].xy );\n    \n    vec2 vQuantizedUV = floor(vScenePixelCoord) * (1.0 \/ vResolution);\n    vec4 vViewmodelSprite = ViewmodelSprite( vQuantizedUV, fLightLevel );\n\n    vResult = mix ( vResult, vViewmodelSprite, vViewmodelSprite.a );\n    \n    if ( vScenePixelCoord.y < 1.0 )\n    {\n        return vec4((vec3(70.\/256.)), 1.);\n    }   \n    \n    return vResult;\n}\n\nvec3 DrawMap( vec2 vPixelCoord, vec2 vResolution )\n{\n    vec3 vResult = vec3(0.0);\n    vec2 vScenePixelCoord = floor(vPixelCoord) - vec2(0, 31.0);\n    \n    float fScale = 5.0;\n    \n    vec2 vPixelWorldPos = (vScenePixelCoord - vec2(160,100)) * fScale + g_playerEnt.vPos.xz;\n\n    MapInfo mapInfo = ReadMapInfo();\n    \n    \/\/if ( Key_IsToggled( KEY_TAB ) )\n    {\n        for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n        {\n            float fSectorId = float(iSectorIndex);\n\n            if ( fSectorId > mapInfo.fSectorCount )\n                break;\n\n            Sector sector = Map_ReadSector( fSectorId );\n            \n            \/*if ( Map_PointInSector( vPixelWorldPos, sector ) )\n            {\n                vResult = vec3(1,0,0);\n            }*\/\n            \n\n            for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n            {\n                float fSideDefIndex = float(iSideDefIndex);\n\n                SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n\n                if ( sideDef.fLength <= 0.0)\n                {\n                    break;\n                }\n                \n                vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );\n\n                float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );\n                fProj = clamp( fProj, 0.0, sideDef.fLength );\n                \n                vec2 vClosest = sideDef.vA + vSideDir * fProj;\n                float fDist = length( vClosest - vPixelWorldPos );\n                \n                if (fDist < fScale * .5 )\n                {\n                    if ( sideDef.fNextSector != SECTOR_NONE )\n                    {\n\t                    vResult = vec3(1,1,0);\n                    }\n                    else\n                    {\n\t                    vResult = vec3(1,0,0);\n                    }\n                }\n            }\t\t\t\n        }\n    }    \n    \n    return vResult;\n}\n\nfloat Relief( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    vPos = floor(vPos);\n    if ( (vPos.x == vMin.x ) && (vPos.y <= vMax.y && vPos.y >= vMin.y ) )\n    {\n\t    return 1.3;\n    }\n\n    if ( (vPos.y == vMax.y ) && (vPos.x <= vMax.x && vPos.x >= vMin.x ) )\n    {\n\t    return 1.4;\n    }\n        \n    if ( (vPos.x == vMax.x ) && (vPos.y <= vMax.y && vPos.y >= vMin.y ) )\n    {\n\t    return 0.4;\n    }\n\n    if ( (vPos.y == vMin.y ) && (vPos.x <= vMax.x && vPos.x >= vMin.x ) )\n    {\n\t    return 0.7;\n    }\n    \n    return 1.0;\n}\n\n#ifdef FULL_HUD\n\nvec3 GetMessageChar( float fMessage, float fChar )\n{\n\t#define MESSAGE_CHAR(X) if ( fChar == 0. ) return X; fChar--\n    \n    if ( fMessage == EVENT_HEALTH_BONUS ||\n       \tfMessage == EVENT_ARMOR_BONUS || \n       \tfMessage == EVENT_GREENARMOR || \n        fMessage == EVENT_BLUEARMOR ||\n       fMessage == EVENT_MEDIKIT)\n    {\n        MESSAGE_CHAR( _P_ );\n        MESSAGE_CHAR( _I_ );\n        MESSAGE_CHAR( _C_ );\n        MESSAGE_CHAR( _K_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _D_ );\n\n        MESSAGE_CHAR( _SPACE_ );\n\n        MESSAGE_CHAR( _U_ );\n        MESSAGE_CHAR( _P_ );\n\n        MESSAGE_CHAR( _SPACE_ );\n    }\n    else\n    if( fMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _Y_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _U_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n\n        MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _T_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n    }\n        \n    \n    if ( fMessage == EVENT_HEALTH_BONUS || fMessage == EVENT_ARMOR_BONUS || fMessage == EVENT_MEDIKIT)\n    {    \n        MESSAGE_CHAR( _A_ );\n        if ( fMessage == EVENT_ARMOR_BONUS )\n        {    \n\t        MESSAGE_CHAR( _N_ );\n        }\n        MESSAGE_CHAR( _SPACE_ );\n    }\n    else if ( fMessage == EVENT_GREENARMOR ||\n            fMessage == EVENT_BLUEARMOR || \n            fMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _E_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n    }\n\n    if ( fMessage == EVENT_BLUEARMOR )\n    {\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _A_ );\n    }\n    \n    if( fMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _S_ );\n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _U_ );\n        MESSAGE_CHAR( _N_ );\n        \n        MESSAGE_CHAR( _SPACE_ );\n    }\n    \n    if ( fMessage == EVENT_HEALTH_BONUS )\n    {    \n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _H_ );\n    }\n    else if ( fMessage == EVENT_ARMOR_BONUS || fMessage == EVENT_GREENARMOR || fMessage == EVENT_BLUEARMOR)\n    {    \n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _R_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _R_ );\n    }\n    else if ( fMessage == EVENT_MEDIKIT )\n    {    \n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _D_ );\n        MESSAGE_CHAR( _I_ );\n        MESSAGE_CHAR( _K_ );\n        MESSAGE_CHAR( _I_ );\n        MESSAGE_CHAR( _T_ );\n    }\n    \n    if ( fMessage == EVENT_HEALTH_BONUS || fMessage == EVENT_ARMOR_BONUS)\n    {    \n        MESSAGE_CHAR( _SPACE_ );\n        \n        MESSAGE_CHAR( _B_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _N_ );\n        MESSAGE_CHAR( _U_ );\n        MESSAGE_CHAR( _S_ );\n    }\n\n    if ( fMessage == EVENT_BLUEARMOR || fMessage == EVENT_SHOTGUN )\n    {\n        MESSAGE_CHAR( _EXCLAMATION_ );\n    }\n    else\n    {\n        MESSAGE_CHAR( _PERIOD_ );\n    }   \n    \n    return vec3(0.0);\n}\n\n\nvec3 GetHudTextChar( float fChar ) \n{\n\n\t#define HUD_TEXT_CHAR(X) if ( fChar == 0. ) return X; fChar--\n    \n    HUD_TEXT_CHAR( vec3(6,189, -1) ); \/\/ MOVE\n\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _O_ );\n\n    HUD_TEXT_CHAR( vec3(52,189, -1) ); \/\/ MOVE\n    \n    HUD_TEXT_CHAR( _H_ );\n    HUD_TEXT_CHAR( _E_ );\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _L_ );\n    HUD_TEXT_CHAR( _T_ );\n    HUD_TEXT_CHAR( _H_ );\n    \n    HUD_TEXT_CHAR( vec3(109,189, -1) ); \/\/ MOVE\n\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _R_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _S_ );\n    \n    HUD_TEXT_CHAR( vec3(187,189, -1) ); \/\/ MOVE\n\n    HUD_TEXT_CHAR( _A_ );\n    HUD_TEXT_CHAR( _R_ );\n    HUD_TEXT_CHAR( _M_ );\n    HUD_TEXT_CHAR( _O_ );\n    HUD_TEXT_CHAR( _R_ );\n\n    return vec3(0.0);\n}\n\n\nvoid PrintHudMessage( vec2 vTexCoord, float fMessage, inout vec3 vResult )\n{\n    if ( vTexCoord.y > 8.0 || vTexCoord.y < 0.0 || vTexCoord.x < 0.0 || vTexCoord.x > 240. )\n        return;     \n    \n    vec2 vUV = vec2( vTexCoord.x, vTexCoord.y );\n    vUV.y += fMessage * 8.0;\n    vUV.y = (iChannelResolution[0].y - 1.0) - vUV.y;\n    vUV = floor( vUV ) + 0.5;\n    vUV \/= iChannelResolution[0].xy;\n    vec4 vSample = texture2D(iChannel0, vUV);\n\tif( vSample.a > 0.0)\n\t{\n        vResult = vSample.rgb;\n\t}\n                    \n    \n                    \/*\n    \/\/ Message text\n    PrintState printState;\n    Print_Init( printState, vTexCoord );\n\n    \/\/ Fixed size font\n    \/\/float fCharIndex = floor( printState.vPos.x \/ 8. );\n    \/\/printState.vPos.x -= fCharIndex * 8.0;\n    \/\/vec3 vChar = GetMessageChar( fMessage, fCharIndex );\n    \n    vec3 vChar = _SPACE_;\n    for ( int i=0; i<32; i++)\n    {\n        vChar = GetMessageChar( fMessage, float(i) );\n        if ( Print_Test( printState, vChar, 0.0 ) )\n        {\n            break;\n        }\n        if ( vChar.z == 0. )\n            break;\n    }\n        \t\n    Print_FancyChar( printState, vResult, vChar );\n\t*\/\n}\n#endif \/\/ FULL_HUD\n\nvec4 GameImage( vec2 vUV, vec2 vResolution )\n{\n    vec4 vResult = vec4(0.0);\n\n    if ( any( lessThan( vUV, vec2(0.0) ) ) || any( greaterThanEqual( vUV, vec2(1,1) ) ) )\n    {\n        return vResult;\n    }\n    \n    vec2 vHudPixel = vUV * vResolution.xy;\n    vec2 vScenePixel = vUV * vResolution.xy;\n\n    g_playerEnt = Entity_Read( 0.0 );\n    Sector playerSector = Map_ReadSector( g_playerEnt.fSectorId );\n    \n\tg_gameState = GameState_Read();\n    \n    float fHudFade = 0.0;\n    float fGameFade = 10.0;\n    \n    if ( g_gameState.fMainState == MAIN_GAME_STATE_GAME_RUNNING )\n    {\n        fHudFade = 0.01 + g_gameState.fStateTimer;\n        fGameFade = 0.0;\n    }\n    if ( g_gameState.fMainState == MAIN_GAME_STATE_WIN )\n    {\n        fGameFade = 0.01 + g_gameState.fStateTimer;\n        fHudFade = 0.0;\n    }\n    \n    VWipe( vHudPixel, fHudFade, vResolution );\n    VWipe( vScenePixel, fGameFade, vResolution );       \n    \n    \n    vec3 vRenderImage;\n    \n#ifdef ALLOW_MAP    \n    if ( g_gameState.fMap > 0.0 )\n    {\n        \/\/vRenderImage = DrawMap( vScenePixel, vResolution );\n        \n        vec2 vScenePixelCoord = floor(vScenePixel);\n\n        float fScale = 10.0;\n        vec2 vPixelWorldPos = (vScenePixelCoord - vec2(160,100)) * fScale + g_playerEnt.vPos.xz;\n        \n        vec2 vMapUV = (vPixelWorldPos - vec2(1056, -3616)) \/ 10.0 + vec2(200, 150);\n        vMapUV += vec2(0, 32.0);\n        \n        vRenderImage = texture2D( iChannel1, (floor(vMapUV) + 0.5) \/ iChannelResolution[1].xy ).rgb;\n    }        \n    else\n#endif \/\/ ALLOW_MAP        \n    {\n \t\tvRenderImage = SampleScene( vScenePixel, vResolution, playerSector.fLightLevel ).rgb;        \n    }\n    \n    if ( vScenePixel.y <= 32.0 )\n    {\n        vec4 vHudText = GetHudText( vScenePixel, g_playerEnt.fHealth, g_playerEnt.fArmor );\n\n\t\tvec2 vNoiseScale = vec2(500.0, 300.0);        \n        float fNoisePer = 0.8;\n        if ( vHudText.a > 0.0 )\n        {\n            vNoiseScale = vec2(600.0); \n            fNoisePer = 0.5;\n        }\n\n        float fNoise = fbm( vUV * vNoiseScale, fNoisePer );\n        fNoise = fNoise * 0.5 + 0.5;\n        \n        if ( vHudText.a > 0.0 )\n        {\n            vRenderImage = vHudText.rgb * fNoise;\n        }\n    \telse\n        {\n            vRenderImage = vec3(fNoise * fNoise * 0.65 );\n        }    \n        \n#ifdef FULL_HUD\n        \/\/ Main relief\n        vRenderImage *= Relief( vScenePixel, vec2(0, 0), vec2(46, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(48, 0), vec2(104, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(106, 0), vec2(142, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(178, 0), vec2(235, 31));\n        vRenderImage *= Relief( vScenePixel, vec2(249, 0), vec2(319, 31));\n        \n        \/\/ weapon avail\n        vRenderImage *= Relief( vScenePixel, vec2(107, 200 - 179), vec2(117, 200 - 171));\n        vRenderImage *= Relief( vScenePixel, vec2(119, 200 - 179), vec2(129, 200 - 171));\n        vRenderImage *= Relief( vScenePixel, vec2(131, 200 - 179), vec2(141, 200 - 171));\n        \n        vRenderImage *= Relief( vScenePixel, vec2(107, 200 - 189), vec2(117, 200 - 181));\n        vRenderImage *= Relief( vScenePixel, vec2(119, 200 - 189), vec2(129, 200 - 181));\n        vRenderImage *= Relief( vScenePixel, vec2(131, 200 - 189), vec2(141, 200 - 181));\n\n        \/\/ decoration\n        vRenderImage *= Relief( vScenePixel, vec2(237, 200 - 179), vec2(247, 200 - 171));\n        vRenderImage *= Relief( vScenePixel, vec2(237, 200 - 189), vec2(247, 200 - 181));\n        vRenderImage *= Relief( vScenePixel, vec2(237, 200 - 199), vec2(247, 200 - 191));\n        \n        vRenderImage *= Relief( vScenePixel, vec2(143, 0), vec2(177, 31));\n        \n        if ( all( greaterThanEqual( vScenePixel, vec2(144,1) ) ) &&\n            all( lessThan( vScenePixel, vec2(177,31) ) ) )\n        {\n            vRenderImage = vec3(0.0);\n        }\n#endif \/\/ FULL_HUD\n            \n#ifdef FULL_HUD   \n        \n        PrintHudMessage( vec2(vScenePixel.x, (vResolution.y - 1.) - (vScenePixel.y + 189.)), MESSAGE_HUD_TEXT, vRenderImage );\n        \n        PrintState printState;\n        Print_Init( printState, vec2(vScenePixel.x, (vResolution.y - 1.) - vScenePixel.y) );        \n\n        \n        \/\/ HUD text AMMO, HEALTH, ARMS, ARMOR\n\/*\n        Print_Color( printState, vec3(.9 ) );\n        vec3 vChar = _SPACE_;\n        for ( int i=0; i<24; i++)\n        {\n            vChar = GetHudTextChar( float(i) );\n            if ( Print_Test( printState, vChar, 0.0 ) )\n            {\n                break;\n            }\n            if ( vChar.z == 0. )\n                break;\n        }\n\n        Print_HudChar( printState, vRenderImage, vChar );        \n*\/\n        \/\/ Arms numbers\n        Print_Color( printState, vec3(.8,.8,0 ) );        \n        Print_MoveTo( printState, vec2(109,170) );\n        Print_Char( printState, vRenderImage, _2_ );\n\n        if( g_playerEnt.fHaveShotgun <= 0.0 )\n        {\n\t\t\tPrint_Color( printState, vec3(.25 ) );        \n        }\n        \n        Print_MoveTo( printState, vec2(120,170) );\n        Print_Char( printState, vRenderImage, _3_ );\n        Print_Color( printState, vec3(.25 ) );        \n        Print_MoveTo( printState, vec2(132,170) );\n        Print_Char( printState, vRenderImage, _4_ );\n\n        Print_MoveTo( printState, vec2(109,179) );\n        Print_Char( printState, vRenderImage, _5_ );\n        Print_MoveTo( printState, vec2(120,179) );\n        Print_Char( printState, vRenderImage, _6_ );\n        Print_MoveTo( printState, vec2(132,179) );\n        Print_Char( printState, vRenderImage, _7_ );\n#endif \/\/ FULL_HUD        \n    }    \n    \n\tfloat fEffectAmount = clamp( abs(g_gameState.fHudFx), 0.0, 1.0 );\n            \n    if (g_gameState.fHudFx > 0.0) \n    {\n        vRenderImage.rgb = mix( vRenderImage.rgb, vec3( 0.5, 1, 0.6), fEffectAmount * 0.75 );\n    }\n\n    if (g_gameState.fHudFx < 0.0) \n    {\n        vRenderImage.rgb = mix( vRenderImage.rgb, vec3( 1, 0, 0), fEffectAmount * 0.75 );\n    }\n    \n#ifdef FULL_HUD    \n#ifdef HUD_MESSAGES\n    if ( g_gameState.fMessageTimer > 0.0 )\n    {\n        if (g_gameState.fMessage >= 0.0 )\n        {\n        \tPrintHudMessage( vec2(vScenePixel.x, (vResolution.y) - vScenePixel.y), g_gameState.fMessage, vRenderImage );\n        }\n    }\n#endif \/\/ HUD_MESSAGES    \n#endif \/\/ FULL_HUD    \n    \n    \n    vec3 vFrontendImage = vec3(0.0);\n    \n    if ( vHudPixel.y > 0.0 )\n    {\n        vFrontendImage = Tex( vHudPixel );\n        vec2 vHudTextCoord = vec2(vHudPixel.x, (vResolution.y) - vHudPixel.y);\n\n        if ( g_gameState.fMainState == MAIN_GAME_STATE_WIN )\n        {\n            float fScale = 0.5;\n            vec2 vPos = vec2(58,8);\n\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_HANGAR, vFrontendImage );        \n            vPos.y += 10.0;\n            vPos.x = 56.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_FINISHED, vFrontendImage );        \n\n        }\n\n        \/*\n        if ( g_gameState.fMainState == MAIN_GAME_STATE_SKILL_SELECT\n           || g_gameState.fMainState == MAIN_GAME_STATE_INIT_LEVEL\n           || g_gameState.fMainState == MAIN_GAME_STATE_GAME_RUNNING )\n        {            \n            float fScale = 0.8;\n            vec2 vPos = vec2(32,32);\n\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_CHOOSE_SKILL, vFrontendImage );        \n\n            vPos.x += 32.0;\n            vPos.y += 24.0;\n\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_1, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_2, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_3, vFrontendImage );        \n            PrintHudMessage( (vHudTextCoord * fScale - vPos + vec2(16.0, 0) ), MESSAGE_SELECT, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_4, vFrontendImage );        \n            vPos.y += 16.0;\n            PrintHudMessage( (vHudTextCoord * fScale - vPos ), MESSAGE_SKILL_5, vFrontendImage );        \n            vPos.y += 16.0;       \t\t        \n        }\n\t\t*\/\n    }\n    \n    \n    vec2 vHudUV = vHudPixel \/ vResolution;\n    vec2 vSceneUV = vScenePixel \/ vResolution;\n    if ( fHudFade > fGameFade )\n    {\n        vResult.rgb = vRenderImage;\n\n        if ( vHudUV.y < 1.0 )\n        {\n            vResult.rgb = vFrontendImage;    \n        }\n    }\n    else\n    {\n        vResult.rgb = vFrontendImage;\n\n        if ( vSceneUV.y < 1.0 )\n        {\n\t        vResult.rgb = vRenderImage;\n        }\n    }\n    \n    if ( g_gameState.fMainState == MAIN_GAME_STATE_BOOT  ) \n    {\n        vResult.rgb = vec3( 0, 0, 0 );\n    }\n\n    \/\/vResult *= 0.5 + 0.5 * mod(mod(floor(vScenePixel.x), 2.0) + mod(floor(vScenePixel.y), 2.0), 2.0);\n    \n\treturn vResult;    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    vec2 vUV = fragCoord \/ iResolution.xy;\n    \n    vec2 vResolution = min( iResolution.xy, vec2( 320.0, 200.0 ) );\n    \/\/vec2 vAspect = iResolution.xy;\n    vec2 vAspect = vec2( 4, 3 );\n    \n    vec2 vWindowUV = vUV;\n    float fXScale = (iResolution.x \/ iResolution.y) * (vAspect.y \/ vAspect.x);;\n    \n    vWindowUV.x = vWindowUV.x * fXScale + (1.0 - fXScale) * 0.5;\n    \n    \n\/\/ Full screen\n#if 0\n    vWindowUV = vUV;\n#endif  \n    \n\/\/ 1 : 1\n#if 0\n    vWindowUV = vUV * iResolution.xy \/ vResolution.xy;\n#endif    \n    \n    \n#ifdef SHOW_MAP_DATA\n    fragColor = texture2D( iChannel0, vUV); return;\n#endif \/\/ SHOW_MAP_DATA    \n\n    \/\/fragColor = texture2D( iChannel1, vUV * 0.25 ); return;\n    \n#ifdef SHOW_SPRITES\n    fragColor = texture2D( iChannel2, vUV); return;\n#endif \/\/ SHOW_SPRITES\n        \n    \/\/fragColor = texture2D( iChannel2, vUV); return;\n    \/\/fragColor = texture2D( iChannel2, vUV * vec2(600,400) \/ iResolution.xy); return;\n      \n    fragColor = GameImage( vWindowUV, vResolution );\n    \n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    fragColor = Quantize(fragColor.rgb, 32.0);\n    #endif\n    \n    if ( false )\n    {\n\t   vec4 vSample = texture2D( iChannel2, vUV * 0.5 + vec2(0.0, 0) );\n    \tfragColor.rgb = mix( fragColor.rgb, vSample.rgb, vSample.a );\n    }\n}","name":"Image","description":"","type":"image"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":4265,"src":"https:\/\/soundcloud.com\/plasma3\/doom-remix-at-dooms-gate-level-1-theme-e1m1","ctype":"musicstream","channel":3,"sampler":{"filter":"linear","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":257,"channel":0}],"code":"#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define FAR_CLIP 1000000.0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Util\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 Quantize( const in vec3 col, float fLevels )\n{\n\treturn floor( col * fLevels + 0.5 ) * (1.0 \/ fLevels);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    return vA.x * vB.y - vA.y * vB.x;\n}\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid SetFlag( inout float fBits, float fFlag )\n{\n    \/\/ TODO: flag mask logic \n    fBits = fFlag;\n}\n\n\nbool FlagSet( float fBits, float fFlag )\n{\n    return fract( floor( fBits \/ fFlag ) * 0.5 ) >= 0.5;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nconst float KEY_1 = \t49.5\/256.0;\nconst float KEY_2 = \t50.5\/256.0;\nconst float KEY_3 = \t51.5\/256.0;\nconst float KEY_ENTER = 13.5\/256.0;\nconst float KEY_SHIFT = 16.5\/256.0;\nconst float KEY_CTRL  = 17.5\/256.0;\nconst float KEY_ALT   = 18.5\/256.0;\nconst float KEY_TAB\t  = 9.5\/256.0;\n\nbool Key_IsPressed(float key)\n{\n    return texture2D( iChannel3, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool Key_IsToggled(float key)\n{\n    return texture2D( iChannel3, vec2(key, 1.0) ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Packing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat BytePack2( vec2 val )\n{ \n    return dot( floor(val), vec2(1, 256) );\n}\n\nfloat BytePack2( float x, float y )\n{\n    return BytePack2( vec2( x, y ) );\n}\n\nvec2 ByteUnpack2( float x )\n{\n    return mod( floor(vec2(x) \/ vec2(1, 256)), 256. );\n}\n\nfloat BytePack3( vec3 val )\n{ \n    return dot( floor(val), vec3(1, 256, 65536) );\n}\n\nfloat BytePack3( float x, float y, float z )\n{\n    return BytePack3( vec3( x, y, z ) );\n}\n\nvec3 ByteUnpack3( float x )\n{\n    return mod( floor(vec3(x) \/ vec3(1, 256, 65536)), 256. );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( sampler, vUV, -100.0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in vec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nvec4 ReadMapData( vec2 address )\n{\n    return LoadVec4( MAP_CHANNEL, address );\n}\n    \nvec4 ReadStateData( vec2 address )\n{\n    return LoadVec4( STATE_CHANNEL, address );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Game State\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MAIN_GAME_STATE_BOOT\t\t\t0.\n#define MAIN_GAME_STATE_SKILL_SELECT\t1.\n#define MAIN_GAME_STATE_INIT_LEVEL\t\t2.\n#define MAIN_GAME_STATE_GAME_RUNNING\t3.\n#define MAIN_GAME_STATE_WIN\t\t\t\t4.\n\nstruct GameState\n{\n    float fMainState;\n    float fStateTimer;\n    float fSkill;\n    float fGameTime;\n    \n    vec4 vPrevMouse;\n    \n    float fMap;\n    float fHudFx;\n    \n    float fMessage;\n    float fMessageTimer;\n};\n\nvoid GameState_Reset( out GameState gameState )\n{\n    gameState.fMainState = MAIN_GAME_STATE_BOOT;\n\tgameState.fSkill = 0.;\n    gameState.fGameTime = 0.;\n    gameState.fStateTimer = 0.;\n    \n    gameState.vPrevMouse = iMouse;\n    \n    gameState.fMap = 0.0;\n    gameState.fHudFx = 0.0;\n    \n    gameState.fMessage = -1.0;\n    gameState.fMessageTimer = 0.0;\n}\n\nGameState GameState_Read()\n{\n    GameState gameState;\n    \n    vec2 vAddress = vec2( 0 );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    gameState.fMainState = vData0.x;\n    gameState.fSkill = vData0.y;\n    gameState.fGameTime = vData0.z;\n    gameState.fStateTimer = vData0.w;    \n\n    gameState.vPrevMouse = vData1;\n    \n    gameState.fMap = vData2.x;\n    gameState.fHudFx = vData2.y;\n\n    gameState.fMessage = vData2.z;\n    gameState.fMessageTimer = vData2.w;\n    \n    return gameState;\n}\n\nvoid GameState_Store( GameState gameState, inout vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 vData0 = vec4( gameState.fMainState, gameState.fSkill, gameState.fGameTime, gameState.fStateTimer );    \n\n    vec4 vData1 = vec4( gameState.vPrevMouse );    \n\n    vec4 vData2 = vec4( gameState.fMap, gameState.fHudFx, gameState.fMessage, gameState.fMessageTimer );    \n\n    vec2 vAddress = vec2( 0 );\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.x++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Map Data\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n#define MAX_SECTOR_COUNT 96\n#define MAX_SIDEDEF_COUNT 32\n\n#define SECTOR_NONE -1.\n\nstruct MapInfo\n{\n    float fSectorCount;\n};\n    \nMapInfo ReadMapInfo()\n{\n    MapInfo mapInfo;\n    \n    vec4 vData = ReadMapData( vec2(0.0, 0.0) );\n    \n    mapInfo.fSectorCount = vData.x;\n    \n    return mapInfo;\n}\n\nstruct Sector\n{\n    float fSectorId;\n    float fLightLevel;\n\n    float fFloorHeight;\n    float fCeilingHeight;\n\n    float fFloorTexture;\n    float fCeilingTexture;\n};\n    \nvec2 GetSectorAddress( float fSectorId )\n{\n    return vec2(0.0, 1.0 + fSectorId );\n}\n\nvec2 GetSideDefAddress( float fSectorId, float fSideDefIndex )\n{\n    return vec2(2.0 + fSideDefIndex * 3.0, 1.0 + fSectorId );\n}\n    \nSector Map_ReadSector( float fSectorId )\n{\n    Sector sector;\n    \n    sector.fSectorId = fSectorId;\n    \n    vec2 vAddress = GetSectorAddress( fSectorId );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n\n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sector.fLightLevel = vData0.x;\n\n    sector.fFloorHeight = vData1.x;\n    sector.fCeilingHeight = vData1.y;\n    sector.fFloorTexture = vData1.z;\n    sector.fCeilingTexture = vData1.w;\n    \n    return sector;\n}\n\nstruct SideDef\n{\n    vec2 vA;\n    vec2 vB;\n    float fLength;\n    \n    float fNextSector;\n    \n    float fLightLevel;\n    \n    float fUpperTexture;\n    float fMiddleTexture;\n    float fLowerTexture;    \n    \n    float fFlags;\n};\n\nSideDef Map_ReadSideDefInfo( float fSectorId, float fSideDefIndex )\n{\n    SideDef sideDef;\n    \n    vec2 vAddress = GetSideDefAddress( fSectorId, fSideDefIndex );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;                       \n\n    sideDef.vA = vData0.xy;\n    sideDef.vB = vData0.zw;\n    \n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sideDef.fLength = vData1.x;\n    sideDef.fLightLevel = vData1.y;    \n    sideDef.fMiddleTexture = vData1.z;\n    sideDef.fNextSector = vData1.w;\n    \n    vec4 vData2 = ReadMapData(vAddress);\n    sideDef.fLowerTexture = vData2.x;\n    sideDef.fUpperTexture = vData2.y;\n    sideDef.fFlags = vData2.z;\n    \n    return sideDef;\n}\n\n\/\/ Return:\n\/\/   ray t value\n\/\/   sidedef u value\n\/\/   edge crossing direction\nvec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )\n{\n    vec2 vEdgeDir = sideDef.vB - sideDef.vA;\n    vec2 vOA = sideDef.vA - vRayPos;\n    float fDenom = Cross2d( vRayDir, vEdgeDir );\n    float fRcpDenom = 1.0 \/ fDenom;\n    \n    vec3 vHitTUD;\n    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;\n    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;\n    vHitTUD.z = fDenom;\n    \n    return vHitTUD;    \n}\n\nbool Map_ValidSectorId( MapInfo mapInfo, float fSectorId )\n{\n    return ( fSectorId >= 0.0 && fSectorId < mapInfo.fSectorCount );\n}\n\nbool Map_PointInSector( vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n    {\n        float fSideDefIndex = float(iSideDefIndex);\n        \n        SideDef sideDef = Map_ReadSideDefInfo( sector.fSectorId, fSideDefIndex );                        \n        \n        if ( sideDef.fLength <= 0.0)\n        {\n            break;\n        }\n\n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( MapInfo mapInfo, vec2 vPos, float fSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, fSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( fSectorId );\n\n    return Map_PointInSector( vPos, sector );\n}\n\nfloat Map_SeekSector( MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    {\n        float fSectorId = float(iSectorIndex);\n        \n        if ( !Map_ValidSectorId( mapInfo, fSectorId ) )\n        {\n            break;\n        }\n\n        if ( Map_PointInSector( mapInfo, vPos, fSectorId ) )\n        {\n            return fSectorId;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout float fSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapInfo, vPos, fSectorId ) )\n    {\n        float fNewSectorId = Map_SeekSector( mapInfo, vPos );\n        \n        if ( fNewSectorId != SECTOR_NONE )\n        {\n        \tfSectorId = fNewSectorId;\n        }                \n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct TraceResult\n{\n    float fDist;\n    vec3 vTexture; \/\/ UV \/ TexureId during trace. Resolved to RGB for sprite rendering\n  \tfloat fLightLevel;\n    float fSector;\n};\n\nstruct TraceSectorState\n{\n    float fEnterDist;\n    float fExitY;\n    float fNextSector;\n    bool bNoUpper;\n};\n\nvoid TraceSideDef( vec3 vRayOrigin, vec3 vRayDir, inout TraceResult result, inout TraceSectorState sectorState, Sector sector, SideDef sideDef )\n{    \n\tvec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vRayOrigin.xz, vRayDir.xz );\n    float fHitT = vHitTUD.x;\n    float fHitU = vHitTUD.y;\n    float fDenom = vHitTUD.z;\n\n    if( \n        \/\/ We hit the edge between the endpoints\n        (fHitU >= 0.0) && (fHitU < 1.0) &&\n        \/\/ Hit point is further than sector entrance distance\n        (fHitT > sectorState.fEnterDist) && \n        \/\/ Track closest hit\n        (fHitT < result.fDist) && \n        \/\/ Ignore faces entering sector\n        (fDenom < 0.0)\n      )\n    {\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        sectorState.fExitY = fHitY;\n        result.fDist = fHitT;\n        \n        if( (sectorState.fExitY > sector.fFloorHeight) )                \n        {\n            sectorState.fNextSector = SECTOR_NONE;\n            if( sideDef.fNextSector == SECTOR_NONE && sideDef.fMiddleTexture != 0.0 && (sectorState.fExitY < sector.fCeilingHeight ) )\n            {\n                result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY);\n                result.vTexture.z = sideDef.fMiddleTexture;\n                result.fLightLevel = sideDef.fLightLevel;\n                sectorState.bNoUpper = false;\n            }\n            else\n            {\n                Sector nextSector = Map_ReadSector( sideDef.fNextSector );\n                                \n\t\t        bool bNoUpper = mod(sideDef.fFlags, 2.0) != 0.0;\n\n\t            if (sectorState.fExitY < sector.fCeilingHeight || bNoUpper )\n                {                                    \n                    if( nextSector.fFloorHeight > sector.fFloorHeight && fHitY > sector.fFloorHeight && fHitY < nextSector.fFloorHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fFloorHeight);\n                        result.vTexture.z = sideDef.fLowerTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }            \n                    else\n                    if( sideDef.fUpperTexture != 0.0 && nextSector.fCeilingHeight < sector.fCeilingHeight && fHitY < sector.fCeilingHeight && fHitY > nextSector.fCeilingHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fCeilingHeight);\n                        result.vTexture.z = sideDef.fUpperTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }\n                    else\n                    {\n                        sectorState.bNoUpper = bNoUpper;\n                        sectorState.fNextSector = sideDef.fNextSector;                          \n                    }\n                }\n            }\n        }\n    }\n}\n\nTraceResult Map_Trace( MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, float fSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.fSector = SECTOR_NONE;\n    \n    for(int iSectorIndex=0; iSectorIndex<20; iSectorIndex++)\n    {\n        if ( fSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( fSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.fNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.fSector = fSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n        {\n            float fSideDefIndex = float(iSideDefIndex);\n            \n            SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n            \n            if ( sideDef.fLength <= 0.0)\n            {\n\t\t\t\tbreak;\n            }\n\n            TraceSideDef( vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.vTexture.z = sector.fFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.vTexture.z = sector.fCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }        \n\n        fSectorId = sectorState.fNextSector;\n    }\n    \n    if ( result.vTexture.z == 1.0 )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Entity Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ENTITY_TYPE_NONE -1.\n\nstruct Entity\n{\n    float fId;\n    \n    float fType;\n    float fSubType;\n    float fSectorId;    \n\n    vec3 vPos;\n    float fYaw;\n    float fPitch;\n    \n    vec3 vVel;\n    float fYawVel;\n    \n    float fHealth;\n    float fArmor;    \n    \n    float fUseWeapon;    \n    float fHaveShotgun;\n    \n    float fTookDamage; \/\/ For HUD damage indicator\n    float fEvent; \/\/ Message event for UI \"Picked up an armor bonus\" etc.\n    \n    float fTimer; \/\/ Weapon reload for player, think timer for AI\n    float fTarget; \/\/ AI nemesis and also used for player aim up \/ down \n    float fFrameFlags;\n};\n    \n#define ENTITY_DATA_YPOS 8.\n#define ENTITY_DATA_SIZE 4.\n\n#define ENTITY_MAX_COUNT 128.\n    \n#define ENTITY_NONE -1.\n    \nfloat Entity_GetOutputId( vec2 fragCoord )\n{\n    if (\n           fragCoord.y < ENTITY_DATA_YPOS\n        || fragCoord.y >= (ENTITY_DATA_YPOS + ENTITY_DATA_SIZE)\n        || fragCoord.x >= ENTITY_MAX_COUNT\n       )\n    {\n        return ENTITY_NONE;        \n    }\n\n    return floor(fragCoord.x);\n}\n\nbool Entity_IdValid( float fEntityId )\n{\n    return ( fEntityId >= 0. && fEntityId < ENTITY_MAX_COUNT );\n}\n\nvoid Entity_Clear( inout Entity entity )\n{\n    entity.fType = ENTITY_TYPE_NONE;\n    entity.vPos = vec3(0);\n    entity.fSectorId = SECTOR_NONE;\n    entity.fYaw = 0.0;\n    entity.vVel = vec3(0);\n    entity.fYawVel = 0.0;\n    entity.fPitch = 0.0;\n    entity.fHealth = 0.0;\n    entity.fArmor = 0.0;\n    entity.fTimer = 0.0;\n    entity.fTarget = ENTITY_NONE;\n    entity.fFrameFlags = 0.0;    \n    entity.fUseWeapon = 1.;\n    entity.fHaveShotgun = 0.;\n    entity.fTookDamage = 0.;\n    entity.fEvent = 0.;\n}\n\nEntity Entity_Read( float fEntityId )\n{\n    Entity entity;\n    \n    entity.fId = fEntityId;\n    \n    vec2 vAddress = vec2( fEntityId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vec3 vUnpacked0x = ByteUnpack3( vData0.x ) - 1.;\n    vAddress.y++;\n    \n    \n    entity.fType = vUnpacked0x.x;\n    entity.fSubType = vUnpacked0x.y;\n    entity.fSectorId = vUnpacked0x.z;\n    \n    entity.fFrameFlags = vData0.y;\n    \n    entity.fTarget = vData0.z;\n    entity.fTimer = vData0.w;\n    \n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vPos = vData1.xyz;\n    entity.fYaw = vData1.w;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vVel = vData2.xyz;\n    entity.fYawVel = vData2.w;\n\n    vec4 vData3 = ReadStateData( vAddress );\n    vec2 vUnpacked3x = ByteUnpack2(vData3.x);\n    vec2 vUnpacked3y = ByteUnpack2(vData3.y);\n    vec2 vUnpacked3z = ByteUnpack2(vData3.z) -1.;\n    vAddress.y++;\n    \n    entity.fHealth = vUnpacked3x.x;\n    entity.fArmor = vUnpacked3x.y;\n    float fPackedWeaponInfo = vData3.y;\n    entity.fUseWeapon = vUnpacked3y.x;\n    entity.fHaveShotgun = vUnpacked3y.y;\n    entity.fTookDamage = vUnpacked3z.x;\n    entity.fEvent = vUnpacked3z.y;\n    entity.fPitch = vData3.w;\n    \n    return entity;\n}\n\nvoid Entity_Store( Entity entity, inout vec4 fragColor, in vec2 fragCoord )\n{\n    if ( !Entity_IdValid( entity.fId ) ) \n        return;\n\n    float fPacked0 = BytePack3( vec3(entity.fType, entity.fSubType, entity.fSectorId ) + 1. );\n\n    entity.fHealth = floor( clamp( entity.fHealth, 0.0, 255.0 ) );\n    entity.fArmor = floor( clamp( entity.fArmor, 0.0, 255.0 ) );\n    float fPackedHealthAndArmor = BytePack2( vec2( entity.fHealth, entity.fArmor ) ); \n\tfloat fPackedWeaponInfo = BytePack2( vec2( entity.fUseWeapon, entity.fHaveShotgun ) );\n\tfloat fPackedEvents = BytePack2( vec2( entity.fTookDamage, entity.fEvent ) + 1. );\n    \n    vec2 vAddress = vec2( entity.fId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = vec4( fPacked0, entity.fFrameFlags, entity.fTarget, entity.fTimer );    \n    vec4 vData1 = vec4( entity.vPos, entity.fYaw );\n    vec4 vData2 = vec4( entity.vVel, entity.fYawVel );\n    vec4 vData3 = vec4( fPackedHealthAndArmor, fPackedWeaponInfo, fPackedEvents, entity.fPitch );\n\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData3, fragColor, fragCoord );\n    vAddress.y++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Weapon Defs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define WEAPON_TYPE_PISTOL\t\t0.\n#define WEAPON_TYPE_SHOTGUN\t\t1.\n#define WEAPON_TYPE_FIREBALL\t2.\n\nstruct WeaponDef\n{\n    float fWeaponType;\n    float fReloadTime;\n    float fProjectileCount;\n    float fBaseDamagePerProjectile;\n    float fRandomDamagePerProjectile;\n    float fSpread;\n};\n\nWeaponDef Weapon_GetDef( float fWeaponType, bool bEnemy )\n{\n    WeaponDef weaponDef;\n\n    if ( fWeaponType == WEAPON_TYPE_SHOTGUN )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_SHOTGUN;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = bEnemy ? 3.0 : 7.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = radians(4.0);\n    }\n    else\n    if ( fWeaponType == WEAPON_TYPE_FIREBALL )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_FIREBALL;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = 5.0;\n        weaponDef.fRandomDamagePerProjectile = 0.0;\n        weaponDef.fSpread = radians(0.0);\n    }\n    else\n    {\n        \/\/ Pistol\n        weaponDef.fWeaponType = WEAPON_TYPE_PISTOL;\n        weaponDef.fReloadTime = 0.5;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = bEnemy ? radians(4.0) : 0.0;\n    }\n    \n    return weaponDef;\n}\n    \n#define ENTITY_TYPE_PLAYER \t0.\n\n#define ENTITY_TYPE_BARREL \t1.\n#define ENTITY_SUB_TYPE_BARREL_INACTIVE\t\t\t0.\n#define ENTITY_SUB_TYPE_BARREL_EXPLODING\t\t1.\n#define ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE\t\t2.\n\n#define ENTITY_TYPE_ITEM \t2.\n#define ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS \t0.\n#define ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS \t1.\n#define ENTITY_SUB_TYPE_ITEM_SHOTGUN \t\t2.\n#define ENTITY_SUB_TYPE_ITEM_STIMPACK\t\t3.\n#define ENTITY_SUB_TYPE_ITEM_GREENARMOR\t\t4.\n#define ENTITY_SUB_TYPE_ITEM_BLUEARMOR\t\t5.\n#define ENTITY_SUB_TYPE_ITEM_MEDIKIT\t\t6.\n\n#define ENTITY_TYPE_DECORATION 3.\n#define ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS\t\t\t0.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER\t\t\t1.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT\t\t2.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_IMP\t\t\t\t3.\n#define ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR\t4.\n#define ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP\t\t\t5.\n\n#define ENTITY_TYPE_ENEMY\t4.\n#define ENTITY_SUB_TYPE_ENEMY_TROOPER \t\t0.\n#define ENTITY_SUB_TYPE_ENEMY_IMP \t\t\t1.\n#define ENTITY_SUB_TYPE_ENEMY_SERGEANT \t\t2.\n\n#define ENTITY_TYPE_BULLET 5.\n#define\tENTITY_SUB_TYPE_BULLET_WALL\t\t\t0.\n#define\tENTITY_SUB_TYPE_BULLET_FLESH\t\t1.\n\n#define ENTITY_TYPE_DOOR 6.\n\n#define ENTITY_TYPE_PLATFORM 7.\n\n#define ENTITY_TYPE_FIREBALL 8.\n#define ENTITY_SUB_TYPE_FIREBALL 0.\n#define ENTITY_SUB_TYPE_FIREBALL_IMPACT 1.\n\n\n#define ENTITY_FRAME_FLAG_FIRE_WEAPON\t\t1.\n#define ENTITY_FRAME_FLAG_DROP_ITEM\t\t\t2.\n\n\n#define ENEMY_STATE_IDLE\t\t\t\t0.\n#define ENEMY_STATE_PAIN\t\t\t\t1.\n#define ENEMY_STATE_WALK_RANDOM\t\t\t2.\n#define ENEMY_STATE_WALK_TO_TARGET\t\t3.\n#define ENEMY_STATE_STAND\t\t\t\t4.\n#define ENEMY_STATE_FIRE\t\t\t\t5.\n#define ENEMY_STATE_DIE\t\t\t\t\t6.\n\n\n#define EVENT_HEALTH_BONUS \t1.\n#define EVENT_ARMOR_BONUS \t2.\n#define EVENT_SHOTGUN \t\t3.\n#define EVENT_STIMPACK\t\t4.\n#define EVENT_GREENARMOR\t5.\n#define EVENT_BLUEARMOR\t\t6.\n#define EVENT_MEDIKIT\t\t7.\n#define EVENT_DIED\t\t\t8.\n\n#define MESSAGE_NONE\t\t\t-1.\n#define MESSAGE_HEALTH_BONUS \t0.\n#define MESSAGE_ARMOR_BONUS \t1.\n#define MESSAGE_SHOTGUN \t\t2.\n#define MESSAGE_STIMPACK\t\t3.\n#define MESSAGE_GREENARMOR\t\t4.\n#define MESSAGE_BLUEARMOR\t\t5.\n#define MESSAGE_MEDIKIT\t\t\t6.\n#define MESSAGE_HUD_TEXT\t\t7.\n#define MESSAGE_CHOOSE_SKILL\t8.\n#define MESSAGE_SKILL_1\t\t\t9.\n#define MESSAGE_SKILL_2\t\t\t10.\n#define MESSAGE_SKILL_3\t\t\t11.\n#define MESSAGE_SKILL_4\t\t\t12.\n#define MESSAGE_SKILL_5\t\t\t13.\n#define MESSAGE_HANGAR\t\t\t14.\n#define MESSAGE_FINISHED\t\t15.\n#define MESSAGE_KILLS\t\t\t16.\n#define MESSAGE_ITEMS\t\t\t17.\n#define MESSAGE_SECRET\t\t\t18.\n#define MESSAGE_TIME\t\t\t19.\n#define MESSAGE_SELECT\t\t\t20.\n#define MESSAGE_COUNT\t\t\t21.\n\n\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define FONT_POS \tvec2(280,0)\n#define FONT_CHAR \tvec2(16,0)\n\nfloat NumFont_Rect( vec2 vPos, vec2 bl, vec2 tr )\n{\n\tif ( all( greaterThanEqual( vPos, bl ) ) &&\n        all( lessThanEqual( vPos, tr ) ) )\n    {\n        return 1.0;\n    }\n        \n    return 0.0;\n}     \n\n\nfloat NumFont_Pixel( vec2 vPos, vec2 vPixel )\n{\n    return NumFont_Rect( vPos, vPixel, vPixel );\n}\n\nfloat NumFont_Circle( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 2), vec2(10,12) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(8,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 4), vec2(11,10) ));\n    \n    return fResult;\n}\n\nfloat NumFont_Zero( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(6, 4), vec2(6,10) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(5, 5), vec2(7,9) ) );\n\n    fResult = min( fResult, 1.0 - fHole );    \n\n    return fResult;\n}\n\nfloat NumFont_One( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    \/\/fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(8,13), fOutline ));\n    \/\/fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(3, 2), vec2(3,4), fOutline ));\n    \/\/fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 3), vec2(2,4), fOutline ));\n    \/\/fResult = max( fResult, NumFont_Pixel( vTexCoord, vec2(1, 4), fOutline ));\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(6, 1), vec2(10,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(5, 2), vec2(5,4) ));\n    fResult = max( fResult, NumFont_Pixel( vTexCoord, vec2(3, 4) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 3), vec2(4,4.1) ));\n    \n\n    return fResult;\n}\n\nfloat NumFont_Two( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 1), vec2(9,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(3, 6), vec2(9,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 8), vec2(4,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 11), vec2(10,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 7), vec2(10,7) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 3), vec2(11,6) ));\n    fResult = max( fResult, NumFont_Pixel( vTexCoord, vec2(10, 2) ) );\n\n    return fResult;\n}\n\nfloat NumFont_Three( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(8,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(-1, 4), vec2(7,5) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 9), vec2(7,10) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 6), vec2(3,8) ));\n    \n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Four( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(4,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 1), vec2(11,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 6), vec2(11,8) ));\n\n    return fResult;\n}\n\nfloat NumFont_Five( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(10,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(3,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 6), vec2(9,8) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 7), vec2(10,12) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 8), vec2(11,11) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 11), vec2(9,13) ));\n    \n    return fResult;\n}\n\nfloat NumFont_Six( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(4, 1), vec2(11,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(5, 9), vec2(8,10) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(5, 4), vec2(17,5) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(10, 6), vec2(17,6) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(10, 13), vec2(17,13) ));\n\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Seven( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(11,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(8, 4), vec2(11,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(9, -1), vec2(17,1) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(11, -1), vec2(17,3) ));\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Eight( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(2, 1), vec2(10,13) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 2), vec2(11,12) ));\n    \n    float fHole = NumFont_Rect( vTexCoord, vec2(5, 4), vec2(7,5) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(5, 9), vec2(7,10) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 6), vec2(1,8) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(11, 6), vec2(17,8) ));\n    fHole = max( fHole, NumFont_Pixel( vTexCoord, vec2(2, 7) ));\n    fHole = max( fHole, NumFont_Pixel( vTexCoord, vec2(10, 7) ));\n\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Nine( vec2 vTexCoord )\n{\n    float fResult = NumFont_Circle( vTexCoord );\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 3), vec2(9,13) ));\n\n    float fHole = NumFont_Rect( vTexCoord, vec2(5, 4), vec2(7,5) );\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 9), vec2(7,10) ));\n    fHole = max( fHole, NumFont_Rect( vTexCoord, vec2(-1, 8), vec2(3,8) ));\n    fHole = max( fHole, NumFont_Pixel( vTexCoord, vec2(-1, 7) ));\n\n    fResult = min( fResult, 1.0 - fHole );    \n    \n    return fResult;\n}\n\nfloat NumFont_Percent( vec2 vTexCoord )\n{\n    float fResult = 0.0;\n    \n    vec2 vClosestRectMin;\n    vClosestRectMin.x = clamp( vTexCoord.x, 1.0, 11.0 );\n    vClosestRectMin.y = 12.0 - vClosestRectMin.x;\n    \n    vec2 vClosestRectMax = vClosestRectMin + vec2(0,3); \n    \n    vClosestRectMax.y = min( vClosestRectMax.y, 13.0 );\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vClosestRectMin, vClosestRectMax ));\n    \n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(1, 1), vec2(3,3) ));\n    fResult = max( fResult, NumFont_Rect( vTexCoord, vec2(9, 11), vec2(11,13) ));\n    \n    return fResult;\n}\n\nfloat NumFont_BinChar( vec2 vTexCoord, float fDigit )\n{\n    vTexCoord.y = 15. - vTexCoord.y;\n    vTexCoord = floor(vTexCoord);\n    if ( fDigit == 0.0 )\n    {\n\t\treturn NumFont_Zero( vTexCoord );\n    }\n    else\n    if ( fDigit == 1.0 )\n    {\n\t\treturn NumFont_One( vTexCoord );\n    }\n    else\n    if ( fDigit == 2.0 )\n    {\n\t\treturn NumFont_Two( vTexCoord );\n    }\n    else\n    if ( fDigit == 3.0 )\n    {\n\t\treturn NumFont_Three( vTexCoord );\n    }\n    else\n    if ( fDigit == 4.0 )\n    {\n\t\treturn NumFont_Four( vTexCoord );\n    }\n    else\n    if ( fDigit == 5.0 )\n    {\n\t\treturn NumFont_Five( vTexCoord );\n    }\n    else\n    if ( fDigit == 6.0 )\n    {\n\t\treturn NumFont_Six( vTexCoord );\n    }\n    else\n    if ( fDigit == 7.0 )\n    {\n\t\treturn NumFont_Seven( vTexCoord );\n    }\n    else\n    if ( fDigit == 8.0 )\n    {\n\t\treturn NumFont_Eight( vTexCoord );\n    }\n    else\n    if ( fDigit == 9.0 )\n    {\n\t\treturn NumFont_Nine( vTexCoord );\n    }\n    else\n    if ( fDigit == 10.0 )\n    {\n\t\treturn NumFont_Percent( vTexCoord );\n    }\n        \n    return 0.0;\n}\n\n\nvec4 NumFont_Char( vec2 vTexCoord, float fDigit )\n{\n    float fOutline = 0.0;\n    float f00 = NumFont_BinChar( vTexCoord + vec2(-1,-1), fDigit );\n    float f10 = NumFont_BinChar( vTexCoord + vec2( 0,-1), fDigit );\n    float f20 = NumFont_BinChar( vTexCoord + vec2( 1,-1), fDigit );\n        \n    float f01 = NumFont_BinChar( vTexCoord + vec2(-1, 0), fDigit );\n    float f11 = NumFont_BinChar( vTexCoord + vec2( 0, 0), fDigit );\n    float f21 = NumFont_BinChar( vTexCoord + vec2( 1, 0), fDigit );\n        \n    float f02 = NumFont_BinChar( vTexCoord + vec2(-1, 1), fDigit );\n    float f12 = NumFont_BinChar( vTexCoord + vec2( 0, 1), fDigit );\n    float f22 = NumFont_BinChar( vTexCoord + vec2( 1, 1), fDigit );\n        \n    float fn1 = NumFont_BinChar( vTexCoord + vec2(-2, 0), fDigit );\n    float fn2 = NumFont_BinChar( vTexCoord + vec2(-2, 1), fDigit );\n    \n    float fn3 = NumFont_BinChar( vTexCoord + vec2(-2, 2), fDigit );\n    float f03 = NumFont_BinChar( vTexCoord + vec2(-1, 2), fDigit );\n    float f13 = NumFont_BinChar( vTexCoord + vec2( 0, 2), fDigit );\n        \n    float fOutlineI = min( 1.0, f00 + f10 + f20 + f01 + f11 + f21 + f02 + f12 + f22 );\n    float fShadow = min( 1.0, fn1 + f01 + f21 + fn2 + f02 + f12 + fn3 + f03 + f13 );\n\n    float nx = f00 * -1.0 + f20 * 1.0\n             + f01 * -2.0 + f21 * 2.0\n         \t + f02 * -1.0 + f22 * 1.0;\n        \n    float ny = f00 * -1.0 + f02 * 1.0\n             + f10 * -2.0 + f12 * 2.0\n         \t + f20 * -1.0 + f22 * 1.0;\n    \n    vec3 n = normalize( vec3( nx, ny, 0.1 ) );\n    \n    vec3 vLight = normalize( vec3( 0.5, -1.0, 0.5 ) );\n    \n    float NdotL = dot( n, vLight ) * 0.25 + 0.75;\n    NdotL = sqrt(NdotL);\n    \n    if ( (fOutlineI + fShadow) <= 0.0 )\n    {\n        return vec4(0.0);\n    }\n\n    vec4 vResult = vec4(1.0);\n    \n    if ( fShadow > 0.0 )\n    {\n        vResult.xyz = vec3(0.2);\n    }\n\n    if ( fOutlineI > 0.0 )\n    {\n\t    vec3 vDiff = vec3(0.5,0,0);\n        \n        if ( f11 > 0.0 )\n        {\n            vDiff = vec3(1,0,0) * NdotL;\n        }\n        vResult.rgb = vDiff;\n    }\n    \n    return vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Start of Font code\n\nconst vec3 _SPACE_ = vec3(0,0,5);\nconst vec3 _EXCLAMATION_ = vec3(49539,384,4);\nconst vec3 _QUOTE_ = vec3(2331,0,7);\nconst vec3 _HASH_ = vec3(167818,1311,7);\nconst vec3 _DOLLAR_ = vec3(508575,69524,7);\nconst vec3 _PERCENT_ = vec3(232984,4487,8);\nconst vec3 _AMPERSAND_ = vec3(249630,8095,8);\nconst vec3 _APOSTROPHE_ = vec3(259,0,4);\nconst vec3 _L_PAREN_ = vec3(115614,3847,7);\nconst vec3 _R_PAREN_ = vec3(462351,1948,7);\nconst vec3 _ASTERISK_ = vec3(509700,526,7);\nconst vec3 _PLUS_ = vec3(114944,2,5);\nconst vec3 _COMMA_ = vec3(0,33152,4);\nconst vec3 _MINUS_ = vec3(245760,0,6);\nconst vec3 _PERIOD_ = vec3(0,384,4);\nconst vec3 _SLASH_ = vec3(232984,391,7);\nconst vec3 _0_ = vec3(843678,3903,8);\nconst vec3 _1_ = vec3(99206,774,5);\nconst vec3 _2_ = vec3(1039935,8067,8);\nconst vec3 _3_ = vec3(1023007,4024,8);\nconst vec3 _4_ = vec3(511387,3096,7);\nconst vec3 _5_ = vec3(508319,3998,7);\nconst vec3 _6_ = vec3(1033150,7987,8);\nconst vec3 _7_ = vec3(793663,6192,8);\nconst vec3 _8_ = vec3(498111,8115,8);\nconst vec3 _9_ = vec3(1038751,4024,8);\nconst vec3 _COLON_ = vec3(3,384,4);\nconst vec3 _SEMICOLON_ = vec3(384,33152,4);\nconst vec3 _LESSTHAN_ = vec3(98816,66307,5);\nconst vec3 _EQUALS_ = vec3(114688,896,5);\nconst vec3 _GREATERTHAN_ = vec3(49280,16774,5);\nconst vec3 _QUESTION_MARK_ = vec3(925568,114751,8);\nconst vec3 _AT_ = vec3(1532350,65237,9);\nconst vec3 _A_ = vec3(1038782,6579,8);\nconst vec3 _B_ = vec3(515135,8123,8);\nconst vec3 _C_ = vec3(115646,7943,8);\nconst vec3 _D_ = vec3(842783,4027,8);\nconst vec3 _E_ = vec3(1034174,7951,8);\nconst vec3 _F_ = vec3(508863,387,8);\nconst vec3 _G_ = vec3(902078,7991,8);\nconst vec3 _H_ = vec3(1038771,6579,8);\nconst vec3 _I_ = vec3(49539,387,4);\nconst vec3 _J_ = vec3(792624,8120,8);\nconst vec3 _K_ = vec3(249267,6555,8);\nconst vec3 _L_ = vec3(49539,8071,8);\nconst vec3 _M_ = vec3(2096099,12779,9);\nconst vec3 _N_ = vec3(1039287,7615,8);\nconst vec3 _O_ = vec3(843678,3903,8);\nconst vec3 _P_ = vec3(1039423,387,8);\nconst vec3 _Q_ = vec3(843678,790335,8);\nconst vec3 _R_ = vec3(515135,6587,8);\nconst vec3 _S_ = vec3(508319,3992,7);\nconst vec3 _T_ = vec3(198207,1548,8);\nconst vec3 _U_ = vec3(842163,3903,8);\nconst vec3 _V_ = vec3(232859,526,7);\nconst vec3 _W_ = vec3(2094563,15359,9);\nconst vec3 _X_ = vec3(466807,15294,9);\nconst vec3 _Y_ = vec3(498099,1548,8);\nconst vec3 _Z_ = vec3(232991,3975,7);\nconst vec3 _L_SQUARE_BRACKET_ = vec3(49543,899,5);\nconst vec3 _BACKSLASH_ = vec3(230275,3100,7);\nconst vec3 _R_SQUARE_BRACKET_ = vec3(99079,902,5);\nconst vec3 _CARET_ = vec3(444164,0,7);\nconst vec3 _UNDERSCORE_ = vec3(0,1032192,8);\n\nfloat Font_DecodeBitmap( vec2 vCoord, vec3 vCharacter )\n{\n    vCoord = floor( vCoord );\n\n    float fRow = vCoord.y - 1.;\n    float fCol = vCoord.x - 1.;\n    \n    if ( fRow < 0. || fRow >= 6. ) return 0.0;\n    if ( fCol < 0. || fCol >= 7. ) return 0.0;\n    \n    float fRowBits = 0.;\n        \n   \tif ( fRow == 0. ) \t\t\tfRowBits = vCharacter.x;\n    else  if ( fRow == 1. ) \tfRowBits = vCharacter.x * ( 1. \/ 128. );\n    else  if ( fRow == 2. ) \tfRowBits = vCharacter.x * ( 1. \/ 16384. );\n    else  if ( fRow == 3. ) \tfRowBits = vCharacter.y;\n    else  if ( fRow == 4. ) \tfRowBits = vCharacter.y * ( 1. \/ 128. );\n    else \t\t\t\t\t\tfRowBits = vCharacter.y * ( 1. \/ 16384. );\n        \n    return mod( floor( fRowBits * pow( .5, fCol ) ), 2.0 );\n}\n\n\nstruct PrintState\n{\n    vec2 vTexCoord;\n    vec2 vOrigin;\n    vec2 vPos;\n    \n    vec3 vColor;\n    vec3 vOutline;\n};\n    \nvoid Print_MoveTo( inout PrintState printState, vec2 vPos )\n{\n    printState.vOrigin = printState.vTexCoord - vPos;\n    printState.vPos = printState.vOrigin;\n}\n\nvoid Print_Newline( inout PrintState printState )\n{\n    printState.vPos.x = printState.vOrigin.x;\n    printState.vPos.y -= 8.0;\n}\n\nvoid Print_Color( inout PrintState printState, vec3 vColor )\n{\n    printState.vColor = vColor;\n}\n\nvoid Print_Init( out PrintState printState, vec2 vTexCoord )\n{\n    printState.vTexCoord = vTexCoord;        \n    printState.vOrigin = vTexCoord;\n    printState.vPos = vTexCoord;\n    printState.vColor = vec3(1,0,0);\n    printState.vOutline = vec3(.3,0,0);\n    Print_MoveTo( printState, vec2(0) ); \n}\n\nvoid Print_Space( inout PrintState printState )\n{\n    printState.vPos.x -= 5.0;\n}\n\nbool Print_Test( inout PrintState printState, vec3 vCharacter, float fSpacing )\n{\n    if ( vCharacter.z == -1.0 )\n    {\n        Print_MoveTo( printState, vCharacter.xy );\n        return false;\n    }\n    \n    if ( printState.vPos.x < vCharacter.z )\n        return true;\n         \n\tprintState.vPos.x -= vCharacter.z + fSpacing;\n    return false;\n}\n\nvoid Print_Char( inout PrintState printState, inout vec3 vResult, vec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    if ( fBitmap > 0.0 ) vResult = printState.vColor;\n    \n    printState.vPos.x -= vCharacter.z - 1.;\n}\n\nvoid Print_HudChar( inout PrintState printState, inout vec3 vResult, vec3 vCharacter )\n{\n    float fBitmap = Font_DecodeBitmap( printState.vPos, vCharacter );\n    float fShadow = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n\n    if ( fBitmap > 0.0 ) vResult = printState.vColor * 0.5 + 0.5 * (printState.vPos.y \/ 8.);\n    else if ( fShadow > 0.0 ) vResult = vec3(0.1);\n    \n    printState.vPos.x -= vCharacter.z;\n}\n\nvoid Print_FancyChar( inout PrintState printState, inout vec3 vResult, vec3 vCharacter )\n{\n    float fBitmapTL = Font_DecodeBitmap( printState.vPos - vec2(-1,-1), vCharacter );\n    float fBitmapTC = Font_DecodeBitmap( printState.vPos - vec2( 0,-1), vCharacter );\n    float fBitmapTR = Font_DecodeBitmap( printState.vPos - vec2( 1,-1), vCharacter );\n\n    float fBitmapCL = Font_DecodeBitmap( printState.vPos - vec2(-1, 0), vCharacter );\n    float fBitmapCC = Font_DecodeBitmap( printState.vPos - vec2( 0, 0), vCharacter );\n    float fBitmapCR = Font_DecodeBitmap( printState.vPos - vec2( 1, 0), vCharacter );\n    \n    float fBitmapBL = Font_DecodeBitmap( printState.vPos - vec2(-1, 1), vCharacter );\n    float fBitmapBC = Font_DecodeBitmap( printState.vPos - vec2( 0, 1), vCharacter );\n    float fBitmapBR = Font_DecodeBitmap( printState.vPos - vec2( 1, 1), vCharacter );\n    \n    float fOutline \t= min( 1., fBitmapTL + fBitmapTC + fBitmapTR + fBitmapCL + fBitmapCR + fBitmapBL + fBitmapBC + fBitmapBR );    \n    float fShade = (fBitmapTL * .5 - fBitmapBR * .5 ) + 0.5;\n    \n    if ( fBitmapCC > 0.0 ) vResult = printState.vColor * (fShade * 0.25 + 0.75);\n    else\n    if ( fOutline > 0.0 ) vResult = printState.vOutline;\n    \n    printState.vPos.x -= vCharacter.z;\n}\n\n\/\/ End of font code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n#define MESSAGE_NONE\t\t\t-1.\n#define MESSAGE_HEALTH_BONUS \t0.\n#define MESSAGE_ARMOR_BONUS \t1.\n#define MESSAGE_SHOTGUN \t\t2.\n#define MESSAGE_STIMPACK\t\t3.\n#define MESSAGE_GREENARMOR\t\t4.\n#define MESSAGE_BLUEARMOR\t\t5.\n#define MESSAGE_MEDIKIT\t\t\t6.\n#define MESSAGE_HUD_TEXT\t\t7.\n#define MESSAGE_CHOOSE_SKILL\t8.\n#define MESSAGE_SKILL_1\t\t\t9.\n#define MESSAGE_SKILL_2\t\t\t10.\n#define MESSAGE_SKILL_3\t\t\t11.\n#define MESSAGE_SKILL_4\t\t\t12.\n#define MESSAGE_SKILL_5\t\t\t13.\n#define MESSAGE_HANGAR\t\t\t14.\n#define MESSAGE_FINISHED\t\t15.\n#define MESSAGE_KILLS\t\t\t16.\n#define MESSAGE_ITEMS\t\t\t17.\n#define MESSAGE_SECRET\t\t\t18.\n#define MESSAGE_TIME\t\t\t19.\n#define MESSAGE_SELECT\t\t\t20.\n#define MESSAGE_COUNT\t\t\t21.\n\nvec3 GetMessageChar( float fMessage, float fChar )\n{\n\t#define MESSAGE_CHAR(X) if ( fChar == 0. ) return X; fChar--\n    \n    if (fMessage == MESSAGE_HUD_TEXT)\n    {\n        MESSAGE_CHAR( vec3(6,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _O_ );\n\n        MESSAGE_CHAR( vec3(52,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _H_ );\n\n        MESSAGE_CHAR( vec3(109,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _R_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _S_ );\n\n        MESSAGE_CHAR( vec3(187,0, -1) ); \/\/ MOVE\n\n        MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _R_ );\n        MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _R_ );        \n    }\n    else\n    if (fMessage == MESSAGE_CHOOSE_SKILL )\n    {\n        MESSAGE_CHAR( _C_ ); MESSAGE_CHAR( _H_ );MESSAGE_CHAR( _O_ ); MESSAGE_CHAR( _O_ ); MESSAGE_CHAR( _S_ ); MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _S_ ); MESSAGE_CHAR( _K_ );MESSAGE_CHAR( _I_ ); MESSAGE_CHAR( _L_ ); MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _L_ ); MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _V_ ); MESSAGE_CHAR( _E_ ); MESSAGE_CHAR( _L_ );\n        MESSAGE_CHAR( _COLON_ );\n    }\n    else\n    if (fMessage == MESSAGE_SKILL_1 )\n    {\n        MESSAGE_CHAR( _I_ ); MESSAGE_CHAR( _APOSTROPHE_ );MESSAGE_CHAR( _M_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _Y_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _U_ ); MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _G_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _D_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (fMessage == MESSAGE_SKILL_2 )\n    {\n        MESSAGE_CHAR( _H_ ); MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _Y_ );\n        MESSAGE_CHAR( _COMMA_ );MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _O_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _R_ ); MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _U_ ); MESSAGE_CHAR( _G_ ); MESSAGE_CHAR( _H_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (fMessage == MESSAGE_SKILL_3 )\n    {\n        MESSAGE_CHAR( _H_ ); MESSAGE_CHAR( _U_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _T_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _SPACE_ );\n        MESSAGE_CHAR( _P_ ); MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _E_ ); MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _Y_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (fMessage == MESSAGE_SKILL_4 )\n    {\n        MESSAGE_CHAR( _U_ ); MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _T_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _A_ );\n        MESSAGE_CHAR( _MINUS_ );\n        MESSAGE_CHAR( _V_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _O_ );MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _N_ );MESSAGE_CHAR( _C_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _PERIOD_ );\n    }\n    else\n    if (fMessage == MESSAGE_SKILL_5 )\n    {\n        MESSAGE_CHAR( _N_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _G_ );MESSAGE_CHAR( _H_ );MESSAGE_CHAR( _T_ );MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _A_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _E_ );\n        MESSAGE_CHAR( _EXCLAMATION_ );\n    }\n    else\n    if (fMessage == MESSAGE_HANGAR )\n    {\n        MESSAGE_CHAR( _H_ ); MESSAGE_CHAR( _A_ );MESSAGE_CHAR( _N_ );MESSAGE_CHAR( _G_ );MESSAGE_CHAR( _A_ );MESSAGE_CHAR( _R_ );\n    }\n    else\n    if (fMessage == MESSAGE_FINISHED )\n    {\n        MESSAGE_CHAR( _F_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _N_ );MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _S_ );MESSAGE_CHAR( _H_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _D_ );\n    }\n    else\n    if (fMessage == MESSAGE_KILLS )\n    {\n        MESSAGE_CHAR( _K_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _L_ );MESSAGE_CHAR( _S_ );\n    }\n    else\n    if (fMessage == MESSAGE_ITEMS )\n    {\n        MESSAGE_CHAR( _I_ ); MESSAGE_CHAR( _T_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _S_ );\n    }\n    else\n    if (fMessage == MESSAGE_SECRET )\n    {\n        MESSAGE_CHAR( _S_ ); MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _C_ );MESSAGE_CHAR( _R_ );MESSAGE_CHAR( _E_ );MESSAGE_CHAR( _T_ );\n    }\n    else\n    if (fMessage == MESSAGE_TIME )\n    {\n        MESSAGE_CHAR( _T_ ); MESSAGE_CHAR( _I_ );MESSAGE_CHAR( _M_ );MESSAGE_CHAR( _E_ );\n    }\n    else\n    if (fMessage == MESSAGE_SELECT )\n    {\n        MESSAGE_CHAR( _ASTERISK_ );\n    }\n    else\n    {    \n        if ( fMessage == MESSAGE_HEALTH_BONUS ||\n            fMessage == MESSAGE_ARMOR_BONUS || \n            fMessage == MESSAGE_GREENARMOR || \n            fMessage == MESSAGE_BLUEARMOR ||\n            fMessage == MESSAGE_STIMPACK ||\n           fMessage == MESSAGE_MEDIKIT)\n        {\n            MESSAGE_CHAR( _P_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _C_ );\n            MESSAGE_CHAR( _K_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _D_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n\n            MESSAGE_CHAR( _U_ );\n            MESSAGE_CHAR( _P_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n        }\n        else\n        if( fMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _Y_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _U_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n\n            MESSAGE_CHAR( _G_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _T_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n        }\n\n\n        if ( fMessage == MESSAGE_HEALTH_BONUS || fMessage == MESSAGE_ARMOR_BONUS || fMessage == MESSAGE_STIMPACK || fMessage == MESSAGE_MEDIKIT)\n        {    \n            MESSAGE_CHAR( _A_ );\n            if ( fMessage == MESSAGE_ARMOR_BONUS )\n            {    \n                MESSAGE_CHAR( _N_ );\n            }\n            MESSAGE_CHAR( _SPACE_ );\n        }\n        else if ( fMessage == MESSAGE_GREENARMOR ||\n                fMessage == MESSAGE_BLUEARMOR || \n                fMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _H_ );\n            MESSAGE_CHAR( _E_ );\n\n            MESSAGE_CHAR( _SPACE_ );\n        }\n\n        if ( fMessage == MESSAGE_BLUEARMOR )\n        {\n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _G_ );\n            MESSAGE_CHAR( _A_ );\n        }\n\n        if( fMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _S_ );\n            MESSAGE_CHAR( _H_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _G_ );\n            MESSAGE_CHAR( _U_ );\n            MESSAGE_CHAR( _N_ );\n        }\n\n        if ( fMessage == MESSAGE_HEALTH_BONUS )\n        {    \n            MESSAGE_CHAR( _H_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _A_ );\n            MESSAGE_CHAR( _L_ );\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _H_ );\n        }\n        else if ( fMessage == MESSAGE_ARMOR_BONUS || fMessage == MESSAGE_GREENARMOR || fMessage == MESSAGE_BLUEARMOR)\n        {    \n            MESSAGE_CHAR( _A_ );\n            MESSAGE_CHAR( _R_ );\n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _R_ );\n        }\n        else if ( fMessage == MESSAGE_MEDIKIT )\n        {    \n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _E_ );\n            MESSAGE_CHAR( _D_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _K_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _T_ );\n        }\n        else if ( fMessage == MESSAGE_STIMPACK )\n        {\n            MESSAGE_CHAR( _S_ );\n            MESSAGE_CHAR( _T_ );\n            MESSAGE_CHAR( _I_ );\n            MESSAGE_CHAR( _M_ );\n            MESSAGE_CHAR( _P_ );\n            MESSAGE_CHAR( _A_ );\n            MESSAGE_CHAR( _C_ );\n            MESSAGE_CHAR( _K_ );\n        }\n\n        if ( fMessage == MESSAGE_HEALTH_BONUS || fMessage == MESSAGE_ARMOR_BONUS)\n        {    \n            MESSAGE_CHAR( _SPACE_ );\n\n            MESSAGE_CHAR( _B_ );\n            MESSAGE_CHAR( _O_ );\n            MESSAGE_CHAR( _N_ );\n            MESSAGE_CHAR( _U_ );\n            MESSAGE_CHAR( _S_ );\n        }\n\n        if ( fMessage == MESSAGE_BLUEARMOR || fMessage == MESSAGE_SHOTGUN )\n        {\n            MESSAGE_CHAR( _EXCLAMATION_ );\n        }\n        else\n        {\n            MESSAGE_CHAR( _PERIOD_ );\n        }   \n    }\n    \n    return vec3(0.0);\n}\n\nvoid PrintHudMessage( vec2 vTexCoord, float fMessage, inout vec3 vResult )\n{\n    if ( vTexCoord.y > 8.0 )\n        return;\n\n    if ( fMessage >= MESSAGE_COUNT )\n        return;\n    \n    \/\/ Message text\n    PrintState printState;\n    Print_Init( printState, vTexCoord );\n\n    \/\/ Fixed size font\n    \/\/float fCharIndex = floor( printState.vPos.x \/ 8. );\n    \/\/printState.vPos.x -= fCharIndex * 8.0;\n    \/\/vec3 vChar = GetMessageChar( fMessage, fCharIndex );\n    \n    vec3 vChar = _SPACE_;\n    for ( int i=0; i<26; i++)\n    {\n        vChar = GetMessageChar( fMessage, float(i) );\n        if ( Print_Test( printState, vChar, 0.0 ) )\n        {\n            break;\n        }\n        if ( vChar.z == 0. )\n            break;\n    }\n        \n    if ( fMessage == MESSAGE_HUD_TEXT || fMessage == MESSAGE_HANGAR )\n    {\n\t\tPrint_Color( printState, vec3(1. ) );        \n    \tPrint_HudChar( printState, vResult, vChar );\n    }\n    else\n    {\n    \tPrint_FancyChar( printState, vResult, vChar );\n    }\n}\n\n\/\/ Constant Data\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Declaration Macros\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define DATA_DECL() \t\t\tvec4 dVal; vec2 dAddr;\n#define DATA_BEGIN( COLOR )\t\tdVal = COLOR\n#define BEGIN_BLOCK( ADDR )dAddr = floor(fragCoord)-ADDR;\n#define BEGIN_ROW(X) \t\tif(dAddr.y == float(X)) {\n#define END_ROW() \t\t} else\n#define END_BLOCK()\t\t{}\n#define DATA_END()\t\t\t\tdVal\n#define DATA( COL, X, Y, Z, W ) \t\tif ( dAddr.x == float(COL) ) dVal = vec4( X, Y, Z, W );\n#define DATA1( COL, X ) \t\t\t\tDATA( COL, X, 0, 0, 0 )\n#define DATA2( COL, X, Y ) \t\t\tDATA( COL, X, Y, 0, 0 )\n#define DATA3( COL, X, Y, Z ) \t\tDATA( COL, X, Y, Z, 0 )\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ENTITY_TYPE_PLAYER \t0.\n\n#define ENTITY_TYPE_BARREL \t1.\n#define ENTITY_SUB_TYPE_BARREL_INACTIVE\t\t\t0.\n#define ENTITY_SUB_TYPE_BARREL_EXPLODING\t\t1.\n#define ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE\t\t2.\n\n#define ENTITY_TYPE_ITEM \t2.\n#define ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS \t0.\n#define ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS \t1.\n#define ENTITY_SUB_TYPE_ITEM_SHOTGUN \t\t2.\n#define ENTITY_SUB_TYPE_ITEM_STIMPACK\t\t3.\n#define ENTITY_SUB_TYPE_ITEM_GREENARMOR\t\t4.\n#define ENTITY_SUB_TYPE_ITEM_BLUEARMOR\t\t5.\n#define ENTITY_SUB_TYPE_ITEM_MEDIKIT\t\t6.\n\n#define ENTITY_TYPE_DECORATION 3.\n#define ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS\t\t\t0.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER\t\t\t1.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT\t\t2.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_IMP\t\t\t\t3.\n#define ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR\t4.\n#define ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP\t\t\t5.\n\n#define ENTITY_TYPE_ENEMY\t4.\n#define ENTITY_SUB_TYPE_ENEMY_TROOPER \t\t0.\n#define ENTITY_SUB_TYPE_ENEMY_IMP \t\t\t1.\n#define ENTITY_SUB_TYPE_ENEMY_SERGEANT \t\t2.\n\n#define ENTITY_TYPE_BULLET 5.\n#define\tENTITY_SUB_TYPE_BULLET_WALL\t\t\t0.\n#define\tENTITY_SUB_TYPE_BULLET_FLESH\t\t1.\n\n#define ENTITY_TYPE_DOOR 6.\n\n#define ENTITY_TYPE_PLATFORM 7.\n\n#define ENTITY_TYPE_FIREBALL 8.\n\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\n#define GRID_POS \t\tvec2(244,32)\n#define GRID_SIZE \t\tvec2(256,256)\n#define GRID_WORLD_MIN\tvec2(-780,-4900)\n#define GRID_WORLD_MAX\tvec2(3820,-2060)\n\nbool LineInGridCell( vec2 vA, vec2 vB, vec2 vGridCellMin, vec2 vGridCellMax )\n{\n    vec2 vAB = vB - vA;\n    \n    \/\/ Check if box crosses line\n\n    float fCross0 = Cross2d( vAB, vec2(vGridCellMin.x, vGridCellMin.y) - vA );\n    float fCross1 = Cross2d( vAB, vec2(vGridCellMax.x, vGridCellMin.y) - vA );\n    float fCross2 = Cross2d( vAB, vec2(vGridCellMin.x, vGridCellMax.y) - vA );\n    float fCross3 = Cross2d( vAB, vec2(vGridCellMax.x, vGridCellMax.y) - vA );\n       \n    if ( fCross0 < 0.0 && fCross1 < 0.0 && fCross2 < 0.0 && fCross3 < 0.0 )\n        return false;\n\n    if ( fCross0 > 0.0 && fCross1 > 0.0 && fCross2 > 0.0 && fCross3 > 0.0 )\n        return false;\n           \n    \/\/ Check if line projection crosses box\n\n    vec2 vLineMin = min( vA, vB );\n    vec2 vLineMax = max( vA, vB );\n\n    if ( vLineMin.x > vGridCellMax.x ) return false;\n    if ( vLineMin.y > vGridCellMax.y ) return false;\n    if ( vLineMax.x < vGridCellMin.x ) return false;\n    if ( vLineMax.y < vGridCellMin.y ) return false;\n    \n    return true;\n}\n\nbool Map_SectorInGridCell( MapInfo mapInfo, vec2 vGridCellMin, vec2 vGridCellMax, float fSectorId )\n{\n    Sector sector;\n    \n    sector = Map_ReadSector( fSectorId );\n    \n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n    {\n        float fSideDefIndex = float(iSideDefIndex);\n        \n        SideDef sideDef = Map_ReadSideDefInfo( sector.fSectorId, fSideDefIndex );                        \n        \n        if ( sideDef.fLength <= 0.0)\n        {\n            break;\n        }\n\n        if ( LineInGridCell( sideDef.vA, sideDef.vB, vGridCellMin, vGridCellMax ) )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvec4 GetGridData( vec2 vGridCellWorldMin, vec2 vGridCellWorldMax )\n{\n    MapInfo mapInfo = ReadMapInfo();\n    \n    int sectorCount = 0;\n    float gridSectors[8];\n        \n\tgridSectors[0] = -1.;\n    gridSectors[1] = -1.;\n    gridSectors[2] = -1.;\n    gridSectors[3] = -1.;\n    gridSectors[4] = -1.;\n    gridSectors[5] = -1.;\n    gridSectors[6] = -1.;\n    gridSectors[7] = -1.;\n    \n    \/\/gridSectors[0] = Map_SeekSector( mapInfo, vGridCellWorldMin ); \n    \n\tint foundIndex = 0;\n    for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    {\n        float fSectorId = float(iSectorIndex);\n        \n        if ( !Map_ValidSectorId( mapInfo, fSectorId ) )\n        {\n            break;\n        }\n\n        if ( foundIndex > 7 )\n        {\n            break;\n        }\n        \n        if ( Map_SectorInGridCell( mapInfo, vGridCellWorldMin, vGridCellWorldMax, fSectorId ) )\n        {\n            if ( foundIndex == 0 ) gridSectors[0] = fSectorId;\n            if ( foundIndex == 1 ) gridSectors[1] = fSectorId;\n            if ( foundIndex == 2 ) gridSectors[2] = fSectorId;\n            if ( foundIndex == 3 ) gridSectors[3] = fSectorId;\n            if ( foundIndex == 4 ) gridSectors[4] = fSectorId;\n            if ( foundIndex == 5 ) gridSectors[5] = fSectorId;\n            if ( foundIndex == 6 ) gridSectors[6] = fSectorId;\n            if ( foundIndex == 7 ) gridSectors[7] = fSectorId;\n            foundIndex++;\n        }        \n    }\n    \n\n    vec4 gridDataPacked;\n    gridDataPacked.x = BytePack2( vec2( gridSectors[0], gridSectors[1] ) + 1. );\n    gridDataPacked.y = BytePack2( vec2( gridSectors[2], gridSectors[3] ) + 1. );\n    gridDataPacked.z = BytePack2( vec2( gridSectors[4], gridSectors[5] ) + 1. );\n    gridDataPacked.w = BytePack2( vec2( gridSectors[6], gridSectors[7] ) + 1. );\n    \n    return gridDataPacked;\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vFontCoord = floor( fragCoord - FONT_POS );\n    vec2 vFontMax = 10. * FONT_CHAR;\n    bool isBigFont = ( vFontCoord.x >= 0.0 && vFontCoord.y >= 0.0 && vFontCoord.x < (vFontMax.x + 16.0) && vFontCoord.y < (vFontMax.y + 16.0) );\n\n    bool isMapData = all( lessThanEqual( fragCoord, vec2( 148, 100 ) ) );\n    \n    vec2 vMessageUV = vec2(fragCoord.x, (iResolution.y - 1.) - fragCoord.y);\n    float fMessageIndex = floor(vMessageUV.y \/ 8.0);\n    bool isMessage = (fMessageIndex < MESSAGE_COUNT) && vMessageUV.x < 240.;\n    \n    vec2 vGridCoord = floor( fragCoord - GRID_POS );\n    bool isGridData = ( vGridCoord.x >= 0.0 && vGridCoord.y >= 0.0 && vGridCoord.x < GRID_SIZE.x && vGridCoord.y < GRID_SIZE.y );\n    \n    if ( !isMapData && !isBigFont && !isMessage && !isGridData) \n    {\n    \tdiscard;\n    }\n            \n    fragColor = vec4(0.0,0.0,0.0,0.0);\n        \n    bool bReuseData = false;\n    if ( iFrame > 1 )\n    {\n\t    \/\/ Check Resolution\n        vec4 info = texture2D( iChannel0, vec2(0.0, 0.0));\n        if ( (info.y == iResolution.x) && (info.z == iResolution.y) )\n        {\n            bReuseData = true;\n        }\n    }\n\n\tif ( bReuseData )\n    {\n        fragColor = texture2D( iChannel0, fragCoord\/iResolution.xy );\n        \n        \/\/fragColor.r = sin(iGlobalTime * 10.0) *0.5 + 0.5; \/\/ flash the cache\n    }\n    else\n    {\n        float fLt = 1.0;\n\n        \/\/ Light level adjustment to East-West and North-South walls\n        const float kC = (1.0 \/ 16.0);\n\n        float fRandomLight = 1.0;\n\n\t    if( isBigFont )\n    \t{\n            float fFontDigit = floor( vFontCoord.x \/ 16.0);\n            vec2 vFontPixel = floor( vFontCoord.xy );\n            vFontPixel.x = mod( vFontPixel.x, 16.0 );\n            float fValue = NumFont_BinChar( vFontPixel, fFontDigit );\n            \/\/float fValue = NumFont_Char( vFontPixel, fFontDigit );            \n            fragColor =  vec4( fValue );\t        \n            return;\n        }\n        \n        if ( isMessage )\n        {\n            vMessageUV.y = mod(vMessageUV.y, 8.0);\n    \t\tPrintHudMessage( vMessageUV, fMessageIndex, fragColor.rgb );\t\n            fragColor.a = fragColor.r > 0. ? 1.0 : 0.0;\n            return;\n        }                  \n\n        if ( isGridData )\n        {\n            vec2 vGridCellWorldMin = GRID_WORLD_MIN + (vGridCoord \/ GRID_SIZE) * (GRID_WORLD_MAX - GRID_WORLD_MIN);\n            vec2 vGridCellWorldMax = GRID_WORLD_MIN + ((vGridCoord + 1.) \/ GRID_SIZE) * (GRID_WORLD_MAX - GRID_WORLD_MIN);\n            \n            float fSize = 16.0;\n            \n            vec4 gridData = GetGridData(vGridCellWorldMin - fSize, vGridCellWorldMax + fSize);\n            \n            fragColor = gridData;\n            return;\n        }\n        \n        DATA_DECL();\n        DATA_BEGIN( fragColor );\n\n\t\t\/\/ Textures\n\t\t#define TEX_X 0.0\n\t\t#define TEX_F_SKY1 1.0\n\t\t#define TEX_NUKAGE3 2.0\n\t\t#define TEX_FLOOR7_1 3.0\n\t\t#define TEX_FLOOR4_8 4.0\n\t\t#define TEX_CEIL5_1 5.0\n\t\t#define TEX_FLAT5_5 6.0\n\t\t#define TEX_FLAT20 7.0\n\t\t#define TEX_FLOOR5_1 8.0\n\t\t#define TEX_CEIL5_2 9.0\n\t\t#define TEX_CEIL3_5 10.0\n\t\t#define TEX_TLITE6_5 11.0\n\t\t#define TEX_FLAT14 12.0\n\t\t#define TEX_FLAT18 13.0\n\t\t#define TEX_TLITE6_4 14.0\n\t\t#define TEX_FLOOR7_2 15.0\n\t\t#define TEX_STEP2 16.0\n\t\t#define TEX_TLITE6_1 17.0\n\t\t#define TEX_FLOOR1_1 18.0\n\t\t#define TEX_FLOOR5_2 19.0\n\t\t#define TEX_FLOOR6_2 20.0\n\t\t#define TEX_FLAT23 21.0\n\t\t#define TEX_TLITE6_6 22.0\n\t\t#define TEX_DOOR3 23.0\n\t\t#define TEX_LITE3 24.0\n\t\t#define TEX_STARTAN3 25.0\n\t\t#define TEX_BROWN1 26.0\n\t\t#define TEX_DOORSTOP 27.0\n\t\t#define TEX_COMPUTE2 28.0\n\t\t#define TEX_STEP6 29.0\n\t\t#define TEX_BROWN144 30.0\n\t\t#define TEX_SUPPORT2 31.0\n\t\t#define TEX_STARG3 32.0\n\t\t#define TEX_DOORTRAK 33.0\n\t\t#define TEX_SLADWALL 34.0\n\t\t#define TEX_TEKWALL4 35.0\n\t\t#define TEX_SW1COMP 36.0\n\t\t#define TEX_BIGDOOR2 37.0\n\t\t#define TEX_STARGR1 38.0\n\t\t#define TEX_BROWNGRN 39.0\n\t\t#define TEX_NUKE24 40.0\n\t\t#define TEX_BROWN96 41.0\n\t\t#define TEX_BRNBIGR 42.0\n\t\t#define TEX_BRNBIGL 43.0\n\t\t#define TEX_BRNBIGC 44.0\n\t\t#define TEX_STARTAN1 45.0\n\t\t#define TEX_EXITDOOR 46.0\n\t\t#define TEX_SW1STRTN 47.0\n\t\t#define TEX_BIGDOOR4 48.0\n\t\t#define TEX_EXITSIGN 49.0\n\t\t#define TEX_TEKWALL1 50.0\n\t\t#define TEX_COMPTALL 51.0\n\t\t#define TEX_COMPSPAN 52.0\n\t\t#define TEX_PLANET1 53.0\n\t\t#define TEX_COMPTILE 54.0\n\t\t#define TEX_STEP1 55.0\n\t\t#define TEX_COMPUTE3 56.0\n\n\t\t\/\/ Map\n\t\tBEGIN_BLOCK(vec2(0, 0));\n\t\tBEGIN_ROW(0);\tDATA(0, 88,iResolution.x, iResolution.y,0);\tEND_ROW();\n\t\t\n\t\t\/\/ Sectors\n\n\t\t\/\/ Sector Data 0\n\t\tBEGIN_ROW(1);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -80,216,TEX_NUKAGE3,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1520,-3168,1672,-3104); \tDATA(3, 164,0.,TEX_X,1); \t\tDATA3(4, TEX_BROWN144,TEX_X,1);\n\tDATA(5, 1672,-3104,1896,-3104); \tDATA(6, 224,0.-kC,TEX_X,1); \t\tDATA3(7, TEX_BROWN144,TEX_X,1);\n\tDATA(8, 1896,-3104,2040,-3144); \tDATA(9, 149,0.,TEX_X,1); \t\tDATA3(10, TEX_BROWN144,TEX_X,1);\n\tDATA(11, 2040,-3144,2128,-3272); \tDATA(12, 155,0.,TEX_X,1); \t\tDATA3(13, TEX_BROWN144,TEX_X,1);\n\tDATA(14, 2128,-3272,2064,-3408); \tDATA(15, 150,0.,TEX_X,1); \t\tDATA3(16, TEX_BROWN144,TEX_X,1);\n\tDATA(17, 2064,-3408,1784,-3448); \tDATA(18, 282,0.,TEX_X,1); \t\tDATA3(19, TEX_BROWN144,TEX_X,1);\n\tDATA(20, 1784,-3448,1544,-3384); \tDATA(21, 248,0.,TEX_X,1); \t\tDATA3(22, TEX_BROWN144,TEX_X,1);\n\tDATA(23, 1544,-3384,1520,-3168); \tDATA(24, 217,0.,TEX_X,1); \t\tDATA3(25, TEX_BROWN144,TEX_X,1);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 1\n\t\tBEGIN_ROW(2);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -56,216,TEX_FLOOR7_1,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1376,-3200,1376,-3104); \tDATA(3, 96,0.+kC,TEX_X,5); \t\tDATA3(4, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(5, 1376,-3360,1376,-3264); \tDATA(6, 96,0.+kC,TEX_X,3); \t\tDATA3(7, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(8, 1376,-3264,1376,-3200); \tDATA(9, 64,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1376,-3104,1376,-2944); \tDATA(12, 160,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 1376,-2944,1472,-2880); \tDATA(15, 115,0.,TEX_STARTAN3,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 1856,-2880,1920,-2920); \tDATA(18, 75,0.,TEX_X,2); \t\tDATA3(19, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(20, 1672,-3104,1520,-3168); \tDATA(21, 164,0.,TEX_X,0); \t\tDATA3(22, TEX_X,TEX_X,1);\n\tDATA(23, 1896,-3104,1672,-3104); \tDATA(24, 224,0.-kC,TEX_X,0); \t\tDATA3(25, TEX_X,TEX_X,1);\n\tDATA(26, 2040,-3144,1896,-3104); \tDATA(27, 149,0.,TEX_X,0); \t\tDATA3(28, TEX_X,TEX_X,1);\n\tDATA(29, 2128,-3272,2040,-3144); \tDATA(30, 155,0.,TEX_X,0); \t\tDATA3(31, TEX_X,TEX_X,1);\n\tDATA(32, 2064,-3408,2128,-3272); \tDATA(33, 150,0.,TEX_X,0); \t\tDATA3(34, TEX_X,TEX_X,1);\n\tDATA(35, 1784,-3448,2064,-3408); \tDATA(36, 282,0.,TEX_X,0); \t\tDATA3(37, TEX_X,TEX_X,1);\n\tDATA(38, 1544,-3384,1784,-3448); \tDATA(39, 248,0.,TEX_X,0); \t\tDATA3(40, TEX_X,TEX_X,1);\n\tDATA(41, 1520,-3168,1544,-3384); \tDATA(42, 217,0.,TEX_X,0); \t\tDATA3(43, TEX_X,TEX_X,1);\n\tDATA(44, 2736,-3360,2736,-3648); \tDATA(45, 288,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(46, TEX_X,TEX_X,2);\n\tDATA(47, 2736,-3648,2240,-3648); \tDATA(48, 496,0.-kC,TEX_X,63); \t\tDATA3(49, TEX_STARTAN3,TEX_X,1);\n\tDATA(50, 2240,-3648,1984,-3648); \tDATA(51, 256,0.-kC,TEX_X,12); \t\tDATA3(52, TEX_STARTAN3,TEX_X,1);\n\tDATA(53, 1984,-3648,1376,-3648); \tDATA(54, 608,0.-kC,TEX_X,11); \t\tDATA3(55, TEX_STARTAN3,TEX_X,1);\n\tDATA(56, 2240,-2920,2272,-3008); \tDATA(57, 93,0.,TEX_STARTAN3,-1); \t\tDATA3(58, TEX_X,TEX_X,2);\n\tDATA(59, 2272,-3008,2432,-3112); \tDATA(60, 190,0.,TEX_STARTAN3,-1); \t\tDATA3(61, TEX_X,TEX_X,2);\n\tDATA(62, 2432,-3112,2736,-3112); \tDATA(63, 304,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(64, TEX_X,TEX_X,2);\n\tDATA(65, 2736,-3112,2736,-3360); \tDATA(66, 248,0.+kC,TEX_X,62); \t\tDATA3(67, TEX_STARTAN3,TEX_STARTAN3,2);\n\tDATA(68, 1376,-3648,1376,-3520); \tDATA(69, 128,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(70, TEX_X,TEX_X,2);\n\tDATA(71, 1376,-3392,1376,-3360); \tDATA(72, 32,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(73, TEX_X,TEX_X,2);\n\tDATA(74, 1376,-3520,1376,-3392); \tDATA(75, 128,0.+kC,TEX_X,4); \t\tDATA3(76, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(77, 1472,-2880,1664,-2880); \tDATA(78, 192,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(79, TEX_X,TEX_X,2);\n\tDATA(80, 1664,-2880,1856,-2880); \tDATA(81, 192,0.-kC,TEX_X,2); \t\tDATA3(82, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(83, 1920,-2920,2176,-2920); \tDATA(84, 256,0.-kC,TEX_X,2); \t\tDATA3(85, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(86, 2176,-2920,2240,-2920); \tDATA(87, 64,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(88, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 2\n\t\tBEGIN_ROW(3);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,0,TEX_FLOOR4_8,TEX_CEIL5_1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1920,-2920,1856,-2880); \tDATA(3, 75,0.,TEX_X,1); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 1664,-2816,2176,-2816); \tDATA(6, 512,0.-kC,TEX_X,14); \t\tDATA3(7, TEX_COMPUTE3,TEX_COMPUTE3,0);\n\tDATA(8, 1856,-2880,1664,-2880); \tDATA(9, 192,0.-kC,TEX_X,1); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2176,-2920,1920,-2920); \tDATA(12, 256,0.-kC,TEX_X,1); \t\tDATA3(13, TEX_X,TEX_X,0);\n\tDATA(14, 2176,-2816,2176,-2920); \tDATA(15, 104,0.+kC,TEX_DOORSTOP,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 1664,-2880,1664,-2816); \tDATA(18, 64,0.+kC,TEX_DOORSTOP,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 3\n\t\tBEGIN_ROW(4);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 8,192,TEX_FLAT5_5,TEX_FLAT5_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1344,-3360,1344,-3264); \tDATA(3, 96,0.+kC,TEX_X,27); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1376,-3264,1376,-3360); \tDATA(6, 96,0.+kC,TEX_X,1); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 1344,-3264,1376,-3264); \tDATA(9, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1376,-3360,1344,-3360); \tDATA(12, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 4\n\t\tBEGIN_ROW(5);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 0,0,TEX_FLOOR4_8,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1344,-3520,1344,-3392); \tDATA(3, 128,0.+kC,TEX_X,29); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 1344,-3392,1376,-3392); \tDATA(6, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1376,-3520,1344,-3520); \tDATA(9, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1376,-3392,1376,-3520); \tDATA(12, 128,0.+kC,TEX_X,1); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 5\n\t\tBEGIN_ROW(6);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 8,192,TEX_FLAT5_5,TEX_FLAT5_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1344,-3200,1344,-3104); \tDATA(3, 96,0.+kC,TEX_X,27); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1376,-3104,1376,-3200); \tDATA(6, 96,0.+kC,TEX_X,1); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 1376,-3200,1344,-3200); \tDATA(9, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1344,-3104,1376,-3104); \tDATA(12, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 6\n\t\tBEGIN_ROW(7);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -136,-40,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2240,-4096,2112,-4032); \tDATA(3, 143,0.,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2048,-3904,2176,-3904); \tDATA(6, 128,0.-kC,TEX_X,7); \t\tDATA3(7, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(8, 2240,-3968,2240,-4096); \tDATA(9, 128,0.+kC,TEX_X,79); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2176,-3904,2176,-3920); \tDATA(12, 16,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2176,-3920,2240,-3968); \tDATA(15, 80,0.,TEX_BROWN1,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2112,-4032,2048,-3920); \tDATA(18, 128,0.,TEX_BROWN1,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 2048,-3920,2048,-3904); \tDATA(21, 16,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 7\n\t\tBEGIN_ROW(8);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -120,16,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2048,-3904,2048,-3872); \tDATA(3, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2176,-3872,2176,-3904); \tDATA(6, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2048,-3872,2176,-3872); \tDATA(9, 128,0.-kC,TEX_X,8); \t\tDATA3(10, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(11, 2176,-3904,2048,-3904); \tDATA(12, 128,0.-kC,TEX_X,6); \t\tDATA3(13, TEX_X,TEX_BROWN1,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 8\n\t\tBEGIN_ROW(9);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -104,16,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2048,-3872,2048,-3840); \tDATA(3, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2176,-3840,2176,-3872); \tDATA(6, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2048,-3840,2176,-3840); \tDATA(9, 128,0.-kC,TEX_X,9); \t\tDATA3(10, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(11, 2176,-3872,2048,-3872); \tDATA(12, 128,0.-kC,TEX_X,7); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 9\n\t\tBEGIN_ROW(10);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -88,16,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2176,-3808,2176,-3840); \tDATA(3, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2048,-3840,2048,-3808); \tDATA(6, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2048,-3808,2176,-3808); \tDATA(9, 128,0.-kC,TEX_X,10); \t\tDATA3(10, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(11, 2176,-3840,2048,-3840); \tDATA(12, 128,0.-kC,TEX_X,8); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 10\n\t\tBEGIN_ROW(11);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -72,16,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2176,-3776,2176,-3808); \tDATA(3, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2048,-3808,2048,-3776); \tDATA(6, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2048,-3776,2176,-3776); \tDATA(9, 128,0.-kC,TEX_X,13); \t\tDATA3(10, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(11, 2176,-3808,2048,-3808); \tDATA(12, 128,0.-kC,TEX_X,9); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 11\n\t\tBEGIN_ROW(12);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -56,24,TEX_FLOOR7_1,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1528,-3680,1376,-3648); \tDATA(3, 155,0.,TEX_BROWN144,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1672,-3744,1528,-3680); \tDATA(6, 157,0.,TEX_BROWN144,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1984,-3776,1672,-3744); \tDATA(9, 313,0.,TEX_BROWN144,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1376,-3648,1984,-3648); \tDATA(12, 608,0.-kC,TEX_X,1); \t\tDATA3(13, TEX_X,TEX_X,1);\n\tDATA(14, 1984,-3648,1984,-3776); \tDATA(15, 128,0.+kC,TEX_X,12); \t\tDATA3(16, TEX_STARTAN3,TEX_X,1);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 12\n\t\tBEGIN_ROW(13);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -56,64,TEX_FLOOR7_1,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2240,-3776,2208,-3680); \tDATA(3, 101,0.,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2208,-3680,2176,-3680); \tDATA(6, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2016,-3680,1984,-3776); \tDATA(9, 101,0.,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2048,-3680,2016,-3680); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2176,-3680,2048,-3680); \tDATA(15, 128,0.-kC,TEX_X,13); \t\tDATA3(16, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(17, 1984,-3648,2240,-3648); \tDATA(18, 256,0.-kC,TEX_X,1); \t\tDATA3(19, TEX_X,TEX_X,1);\n\tDATA(20, 1984,-3776,1984,-3648); \tDATA(21, 128,0.+kC,TEX_X,11); \t\tDATA3(22, TEX_X,TEX_X,1);\n\tDATA(23, 2240,-3648,2240,-3776); \tDATA(24, 128,0.+kC,TEX_X,63); \t\tDATA3(25, TEX_X,TEX_X,1);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 13\n\t\tBEGIN_ROW(14);\n\t\tDATA1(0, 0.690);\n\t\tDATA(1, -56,16,TEX_FLOOR7_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2048,-3680,2176,-3680); \tDATA(3, 128,0.-kC,TEX_X,12); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 2176,-3776,2048,-3776); \tDATA(6, 128,0.-kC,TEX_X,10); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2176,-3680,2176,-3704); \tDATA(9, 24,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2176,-3704,2176,-3776); \tDATA(12, 72,0.+kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2048,-3776,2048,-3704); \tDATA(15, 72,0.+kC,TEX_BROWN1,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2048,-3704,2048,-3680); \tDATA(18, 24,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 14\n\t\tBEGIN_ROW(15);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 32,88,TEX_FLOOR4_8,TEX_CEIL5_1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2176,-2752,2176,-2816); \tDATA(3, 64,0.+kC,TEX_LITE3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1664,-2752,2176,-2752); \tDATA(6, 512,0.-kC,TEX_X,15); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2176,-2816,1664,-2816); \tDATA(9, 512,0.-kC,TEX_X,2); \t\tDATA3(10, TEX_COMPUTE3,TEX_COMPUTE3,0);\n\tDATA(11, 1664,-2816,1664,-2752); \tDATA(12, 64,0.+kC,TEX_X,23); \t\tDATA3(13, TEX_COMPSPAN,TEX_COMPTALL,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 15\n\t\tBEGIN_ROW(16);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, 0,224,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1664,-2368,1664,-2112); \tDATA(3, 256,0.+kC,TEX_X,21); \t\tDATA3(4, TEX_COMPSPAN,TEX_COMPTALL,0);\n\tDATA(5, 1664,-2112,2496,-2112); \tDATA(6, 832,0.-kC,TEX_X,21); \t\tDATA3(7, TEX_COMPSPAN,TEX_COMPTALL,0);\n\tDATA(8, 2496,-2112,2496,-2496); \tDATA(9, 384,0.+kC,TEX_X,21); \t\tDATA3(10, TEX_COMPSPAN,TEX_COMPTALL,0);\n\tDATA(11, 2176,-2752,1664,-2752); \tDATA(12, 512,0.-kC,TEX_X,14); \t\tDATA3(13, TEX_COMPSPAN,TEX_COMPTALL,0);\n\tDATA(14, 2496,-2688,2496,-2752); \tDATA(15, 64,0.+kC,TEX_STARGR1,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 1664,-2560,1664,-2432); \tDATA(18, 128,0.+kC,TEX_X,22); \t\tDATA3(19, TEX_X,TEX_STARGR1,0);\n\tDATA(20, 2496,-2560,2496,-2688); \tDATA(21, 128,0.+kC,TEX_X,61); \t\tDATA3(22, TEX_X,TEX_STARGR1,0);\n\tDATA(23, 1664,-2624,1664,-2600); \tDATA(24, 24,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 1664,-2600,1664,-2560); \tDATA(27, 40,0.+kC,TEX_STARGR1,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 1664,-2432,1664,-2392); \tDATA(30, 40,0.+kC,TEX_STARGR1,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, 1664,-2392,1664,-2368); \tDATA(33, 24,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(34, TEX_X,TEX_X,2);\n\tDATA(35, 2496,-2496,2496,-2520); \tDATA(36, 24,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(37, TEX_X,TEX_X,2);\n\tDATA(38, 2496,-2520,2496,-2560); \tDATA(39, 40,0.+kC,TEX_STARGR1,-1); \t\tDATA3(40, TEX_X,TEX_X,2);\n\tDATA(41, 2496,-2752,2200,-2752); \tDATA(42, 296,0.-kC,TEX_STARGR1,-1); \t\tDATA3(43, TEX_X,TEX_X,2);\n\tDATA(44, 2200,-2752,2176,-2752); \tDATA(45, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(46, TEX_X,TEX_X,2);\n\tDATA(47, 2112,-2592,2336,-2592); \tDATA(48, 224,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(49, TEX_X,TEX_X,2);\n\tDATA(50, 2336,-2592,2336,-2272); \tDATA(51, 320,0.+kC,TEX_COMPTILE,-1); \t\tDATA3(52, TEX_X,TEX_X,2);\n\tDATA(53, 2336,-2272,2112,-2272); \tDATA(54, 224,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(55, TEX_X,TEX_X,2);\n\tDATA(56, 2112,-2272,2112,-2304); \tDATA(57, 32,0.+kC,TEX_COMPTILE,-1); \t\tDATA3(58, TEX_X,TEX_X,2);\n\tDATA(59, 2112,-2304,2144,-2304); \tDATA(60, 32,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(61, TEX_X,TEX_X,2);\n\tDATA(62, 2144,-2560,2112,-2560); \tDATA(63, 32,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(64, TEX_X,TEX_X,2);\n\tDATA(65, 2112,-2560,2112,-2592); \tDATA(66, 32,0.+kC,TEX_COMPTILE,-1); \t\tDATA3(67, TEX_X,TEX_X,2);\n\tDATA(68, 2144,-2304,2144,-2560); \tDATA(69, 256,0.+kC,TEX_X,20); \t\tDATA3(70, TEX_STEP1,TEX_COMPTILE,0);\n\tDATA(71, 1992,-2552,1784,-2552); \tDATA(72, 208,0.-kC,TEX_X,18); \t\tDATA3(73, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(74, 1784,-2552,1784,-2632); \tDATA(75, 80,0.+kC,TEX_X,18); \t\tDATA3(76, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(77, 1784,-2632,1992,-2632); \tDATA(78, 208,0.-kC,TEX_X,18); \t\tDATA3(79, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(80, 1992,-2632,1992,-2552); \tDATA(81, 80,0.+kC,TEX_X,18); \t\tDATA3(82, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(83, 1784,-2312,1992,-2312); \tDATA(84, 208,0.-kC,TEX_X,16); \t\tDATA3(85, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(86, 1992,-2312,1992,-2232); \tDATA(87, 80,0.+kC,TEX_X,16); \t\tDATA3(88, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(89, 1992,-2232,1784,-2232); \tDATA(90, 208,0.-kC,TEX_X,16); \t\tDATA3(91, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(92, 1784,-2232,1784,-2312); \tDATA(93, 80,0.+kC,TEX_X,16); \t\tDATA3(94, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(95, 1664,-2752,1664,-2624); \tDATA(96, 128,0.+kC,TEX_X,23); \t\tDATA3(97, TEX_COMPSPAN,TEX_COMPTALL,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 16\n\t\tBEGIN_ROW(17);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,224,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1984,-2304,1984,-2240); \tDATA(3, 64,0.+kC,TEX_X,17); \t\tDATA3(4, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(5, 1984,-2240,1792,-2240); \tDATA(6, 192,0.-kC,TEX_X,17); \t\tDATA3(7, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(8, 1792,-2240,1792,-2304); \tDATA(9, 64,0.+kC,TEX_X,17); \t\tDATA3(10, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(11, 1792,-2304,1984,-2304); \tDATA(12, 192,0.-kC,TEX_X,17); \t\tDATA3(13, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(14, 1992,-2312,1784,-2312); \tDATA(15, 208,0.-kC,TEX_X,15); \t\tDATA3(16, TEX_X,TEX_X,0);\n\tDATA(17, 1992,-2232,1992,-2312); \tDATA(18, 80,0.+kC,TEX_X,15); \t\tDATA3(19, TEX_X,TEX_X,0);\n\tDATA(20, 1784,-2232,1992,-2232); \tDATA(21, 208,0.-kC,TEX_X,15); \t\tDATA3(22, TEX_X,TEX_X,0);\n\tDATA(23, 1784,-2312,1784,-2232); \tDATA(24, 80,0.+kC,TEX_X,15); \t\tDATA3(25, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 17\n\t\tBEGIN_ROW(18);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,96,TEX_FLOOR4_8,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1984,-2240,1984,-2304); \tDATA(3, 64,0.+kC,TEX_X,16); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 1792,-2240,1984,-2240); \tDATA(6, 192,0.-kC,TEX_X,16); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 1792,-2304,1792,-2240); \tDATA(9, 64,0.+kC,TEX_X,16); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 1984,-2304,1792,-2304); \tDATA(12, 192,0.-kC,TEX_X,16); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 18\n\t\tBEGIN_ROW(19);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,224,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1984,-2624,1984,-2560); \tDATA(3, 64,0.+kC,TEX_X,19); \t\tDATA3(4, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(5, 1984,-2560,1792,-2560); \tDATA(6, 192,0.-kC,TEX_X,19); \t\tDATA3(7, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(8, 1792,-2560,1792,-2624); \tDATA(9, 64,0.+kC,TEX_X,19); \t\tDATA3(10, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(11, 1792,-2624,1984,-2624); \tDATA(12, 192,0.-kC,TEX_X,19); \t\tDATA3(13, TEX_STARGR1,TEX_PLANET1,0);\n\tDATA(14, 1784,-2552,1992,-2552); \tDATA(15, 208,0.-kC,TEX_X,15); \t\tDATA3(16, TEX_X,TEX_X,0);\n\tDATA(17, 1784,-2632,1784,-2552); \tDATA(18, 80,0.+kC,TEX_X,15); \t\tDATA3(19, TEX_X,TEX_X,0);\n\tDATA(20, 1992,-2632,1784,-2632); \tDATA(21, 208,0.-kC,TEX_X,15); \t\tDATA3(22, TEX_X,TEX_X,0);\n\tDATA(23, 1992,-2552,1992,-2632); \tDATA(24, 80,0.+kC,TEX_X,15); \t\tDATA3(25, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 19\n\t\tBEGIN_ROW(20);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,96,TEX_FLOOR4_8,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1984,-2560,1984,-2624); \tDATA(3, 64,0.+kC,TEX_X,18); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 1792,-2560,1984,-2560); \tDATA(6, 192,0.-kC,TEX_X,18); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 1792,-2624,1792,-2560); \tDATA(9, 64,0.+kC,TEX_X,18); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 1984,-2624,1792,-2624); \tDATA(12, 192,0.-kC,TEX_X,18); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 20\n\t\tBEGIN_ROW(21);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 8,152,TEX_FLAT14,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2144,-2304,2176,-2304); \tDATA(3, 32,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2176,-2560,2144,-2560); \tDATA(6, 32,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2144,-2560,2144,-2304); \tDATA(9, 256,0.+kC,TEX_X,15); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2176,-2304,2176,-2560); \tDATA(12, 256,0.+kC,TEX_X,59); \t\tDATA3(13, TEX_STEP1,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 21\n\t\tBEGIN_ROW(22);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 32,88,TEX_FLAT18,TEX_CEIL5_1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1664,-2368,1600,-2368); \tDATA(3, 64,0.-kC,TEX_LITE3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1600,-2368,1600,-2112); \tDATA(6, 256,0.+kC,TEX_COMPUTE2,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2560,-2112,2560,-2496); \tDATA(9, 384,0.+kC,TEX_COMPUTE2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2560,-2496,2496,-2496); \tDATA(12, 64,0.-kC,TEX_LITE3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 1600,-2048,1664,-2048); \tDATA(15, 64,0.-kC,TEX_LITE3,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 1664,-2048,2496,-2048); \tDATA(18, 832,0.-kC,TEX_COMPUTE2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 2496,-2048,2560,-2048); \tDATA(21, 64,0.-kC,TEX_LITE3,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 2560,-2048,2560,-2112); \tDATA(24, 64,0.+kC,TEX_LITE3,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 1600,-2112,1600,-2048); \tDATA(27, 64,0.+kC,TEX_LITE3,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 1664,-2112,1664,-2368); \tDATA(30, 256,0.+kC,TEX_X,15); \t\tDATA3(31, TEX_X,TEX_X,0);\n\tDATA(32, 2496,-2112,1664,-2112); \tDATA(33, 832,0.-kC,TEX_X,15); \t\tDATA3(34, TEX_X,TEX_X,0);\n\tDATA(35, 2496,-2496,2496,-2112); \tDATA(36, 384,0.+kC,TEX_X,15); \t\tDATA3(37, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 22\n\t\tBEGIN_ROW(23);\n\t\tDATA1(0, 0.627);\n\t\tDATA(1, 0,72,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1552,-2560,1552,-2432); \tDATA(3, 128,0.+kC,TEX_X,26); \t\tDATA3(4, TEX_X,TEX_BIGDOOR2,0);\n\tDATA(5, 1664,-2560,1552,-2560); \tDATA(6, 112,0.-kC,TEX_STARGR1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1552,-2432,1664,-2432); \tDATA(9, 112,0.-kC,TEX_STARGR1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1664,-2432,1664,-2560); \tDATA(12, 128,0.+kC,TEX_X,15); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 23\n\t\tBEGIN_ROW(24);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 32,88,TEX_FLAT18,TEX_CEIL5_1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1600,-2624,1664,-2624); \tDATA(3, 64,0.-kC,TEX_LITE3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1664,-2816,1600,-2816); \tDATA(6, 64,0.-kC,TEX_LITE3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1600,-2816,1600,-2752); \tDATA(9, 64,0.+kC,TEX_LITE3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1600,-2752,1600,-2624); \tDATA(12, 128,0.+kC,TEX_COMPUTE2,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 1664,-2752,1664,-2816); \tDATA(15, 64,0.+kC,TEX_X,14); \t\tDATA3(16, TEX_X,TEX_X,0);\n\tDATA(17, 1664,-2624,1664,-2752); \tDATA(18, 128,0.+kC,TEX_X,15); \t\tDATA3(19, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 24\n\t\tBEGIN_ROW(25);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 0,144,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1216,-2880,1248,-2528); \tDATA(3, 353,0.,TEX_STARTAN3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1384,-2592,1344,-2880); \tDATA(6, 290,0.,TEX_STARTAN3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1472,-2560,1384,-2592); \tDATA(9, 93,0.,TEX_STARTAN3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1248,-2528,1472,-2432); \tDATA(12, 243,0.,TEX_STARTAN3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 1344,-2880,1216,-2880); \tDATA(15, 128,0.-kC,TEX_X,29); \t\tDATA3(16, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(17, 1472,-2432,1472,-2560); \tDATA(18, 128,0.+kC,TEX_X,25); \t\tDATA3(19, TEX_STEP6,TEX_STARTAN3,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 25\n\t\tBEGIN_ROW(26);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,88,TEX_FLOOR4_8,TEX_TLITE6_4);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1472,-2560,1472,-2432); \tDATA(3, 128,0.+kC,TEX_X,24); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 1536,-2432,1536,-2560); \tDATA(6, 128,0.+kC,TEX_X,26); \t\tDATA3(7, TEX_X,TEX_BIGDOOR2,0);\n\tDATA(8, 1536,-2560,1472,-2560); \tDATA(9, 64,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1472,-2432,1536,-2432); \tDATA(12, 64,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 26\n\t\tBEGIN_ROW(27);\n\t\tDATA1(0, 0.816);\n\t\tDATA(1, 0,0,TEX_FLOOR4_8,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1536,-2560,1536,-2432); \tDATA(3, 128,0.+kC,TEX_X,25); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 1552,-2432,1552,-2560); \tDATA(6, 128,0.+kC,TEX_X,22); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 1536,-2432,1552,-2432); \tDATA(9, 16,0.-kC,TEX_DOORTRAK,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1552,-2560,1536,-2560); \tDATA(12, 16,0.-kC,TEX_DOORTRAK,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 27\n\t\tBEGIN_ROW(28);\n\t\tDATA1(0, 0.878);\n\t\tDATA(1, -16,200,TEX_FLAT14,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1216,-3392,1216,-3360); \tDATA(3, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1216,-3360,1184,-3360); \tDATA(6, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1184,-3104,1216,-3104); \tDATA(9, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1216,-3104,1216,-3072); \tDATA(12, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 1344,-3264,1344,-3360); \tDATA(15, 96,0.+kC,TEX_X,3); \t\tDATA3(16, TEX_STARTAN3,TEX_STARTAN3,2);\n\tDATA(17, 1344,-3200,1344,-3264); \tDATA(18, 64,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 1344,-3104,1344,-3200); \tDATA(21, 96,0.+kC,TEX_X,5); \t\tDATA3(22, TEX_STARTAN3,TEX_STARTAN3,2);\n\tDATA(23, 1344,-3360,1216,-3392); \tDATA(24, 131,0.,TEX_X,29); \t\tDATA3(25, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(26, 1216,-3072,1344,-3104); \tDATA(27, 131,0.,TEX_X,29); \t\tDATA3(28, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(29, 928,-3104,1184,-3104); \tDATA(30, 256,0.-kC,TEX_X,28); \t\tDATA3(31, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(32, 1184,-3360,928,-3360); \tDATA(33, 256,0.-kC,TEX_X,28); \t\tDATA3(34, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(35, 928,-3360,928,-3104); \tDATA(36, 256,0.+kC,TEX_X,28); \t\tDATA3(37, TEX_STEP6,TEX_STARTAN3,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 28\n\t\tBEGIN_ROW(29);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, -8,120,TEX_FLAT14,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 928,-3392,928,-3360); \tDATA(3, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 928,-3360,896,-3360); \tDATA(6, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1184,-3360,1184,-3392); \tDATA(9, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 896,-3104,928,-3104); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 928,-3104,928,-3072); \tDATA(15, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 1184,-3072,1184,-3104); \tDATA(18, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 1184,-3392,928,-3392); \tDATA(21, 256,0.-kC,TEX_X,29); \t\tDATA3(22, TEX_STEP6,TEX_COMPUTE2,0);\n\tDATA(23, 1184,-3104,928,-3104); \tDATA(24, 256,0.-kC,TEX_X,27); \t\tDATA3(25, TEX_X,TEX_X,0);\n\tDATA(26, 928,-3360,1184,-3360); \tDATA(27, 256,0.-kC,TEX_X,27); \t\tDATA3(28, TEX_X,TEX_X,0);\n\tDATA(29, 928,-3104,928,-3360); \tDATA(30, 256,0.+kC,TEX_X,27); \t\tDATA3(31, TEX_X,TEX_X,0);\n\tDATA(32, 896,-3360,896,-3104); \tDATA(33, 256,0.+kC,TEX_X,29); \t\tDATA3(34, TEX_STEP6,TEX_COMPUTE2,0);\n\tDATA(35, 928,-3072,1184,-3072); \tDATA(36, 256,0.-kC,TEX_X,29); \t\tDATA3(37, TEX_STEP6,TEX_COMPUTE2,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 29\n\t\tBEGIN_ROW(30);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 0,72,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1152,-3648,1088,-3648); \tDATA(3, 64,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1024,-3648,960,-3648); \tDATA(6, 64,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1280,-3552,1152,-3648); \tDATA(9, 160,0.,TEX_STARTAN3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 960,-3648,832,-3552); \tDATA(12, 160,0.,TEX_STARTAN3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 1344,-3552,1280,-3552); \tDATA(15, 64,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 832,-3552,704,-3552); \tDATA(18, 128,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 896,-3392,928,-3392); \tDATA(21, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 896,-3360,896,-3392); \tDATA(24, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 1184,-3392,1216,-3392); \tDATA(27, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 896,-3072,896,-3104); \tDATA(30, 32,0.+kC,TEX_BROWN1,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, 928,-3072,896,-3072); \tDATA(33, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(34, TEX_X,TEX_X,2);\n\tDATA(35, 1216,-3072,1184,-3072); \tDATA(36, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(37, TEX_X,TEX_X,2);\n\tDATA(38, 1344,-2880,1344,-3104); \tDATA(39, 224,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(40, TEX_X,TEX_X,2);\n\tDATA(41, 928,-3392,1184,-3392); \tDATA(42, 256,0.-kC,TEX_X,28); \t\tDATA3(43, TEX_X,TEX_X,0);\n\tDATA(44, 1216,-3392,1344,-3360); \tDATA(45, 131,0.,TEX_X,27); \t\tDATA3(46, TEX_X,TEX_X,0);\n\tDATA(47, 1344,-3104,1216,-3072); \tDATA(48, 131,0.,TEX_X,27); \t\tDATA3(49, TEX_X,TEX_X,0);\n\tDATA(50, 704,-2944,832,-2944); \tDATA(51, 128,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(52, TEX_X,TEX_X,2);\n\tDATA(53, 832,-2944,968,-2880); \tDATA(54, 150,0.,TEX_STARTAN3,-1); \t\tDATA3(55, TEX_X,TEX_X,2);\n\tDATA(56, 968,-2880,1216,-2880); \tDATA(57, 248,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(58, TEX_X,TEX_X,2);\n\tDATA(59, 1088,-3648,1024,-3648); \tDATA(60, 64,0.-kC,TEX_X,30); \t\tDATA3(61, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(62, 896,-3104,896,-3360); \tDATA(63, 256,0.+kC,TEX_X,28); \t\tDATA3(64, TEX_X,TEX_X,0);\n\tDATA(65, 1184,-3072,928,-3072); \tDATA(66, 256,0.-kC,TEX_X,28); \t\tDATA3(67, TEX_X,TEX_X,0);\n\tDATA(68, 704,-3552,704,-3360); \tDATA(69, 192,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(70, TEX_X,TEX_X,2);\n\tDATA(71, 704,-3104,704,-2944); \tDATA(72, 160,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(73, TEX_X,TEX_X,2);\n\tDATA(74, 704,-3360,704,-3104); \tDATA(75, 256,0.+kC,TEX_X,31); \t\tDATA3(76, TEX_X,TEX_X,0);\n\tDATA(77, 1216,-2880,1344,-2880); \tDATA(78, 128,0.-kC,TEX_X,24); \t\tDATA3(79, TEX_X,TEX_X,0);\n\tDATA(80, 1344,-3360,1344,-3392); \tDATA(81, 32,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(82, TEX_X,TEX_X,2);\n\tDATA(83, 1344,-3520,1344,-3552); \tDATA(84, 32,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(85, TEX_X,TEX_X,2);\n\tDATA(86, 1344,-3392,1344,-3520); \tDATA(87, 128,0.+kC,TEX_X,4); \t\tDATA3(88, TEX_STARTAN3,TEX_STARTAN3,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 30\n\t\tBEGIN_ROW(31);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,72,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 1088,-3680,1024,-3680); \tDATA(3, 64,0.-kC,TEX_DOOR3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 1024,-3680,1024,-3648); \tDATA(6, 32,0.+kC,TEX_LITE3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 1088,-3648,1088,-3680); \tDATA(9, 32,0.+kC,TEX_LITE3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 1024,-3648,1088,-3648); \tDATA(12, 64,0.-kC,TEX_X,29); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 31\n\t\tBEGIN_ROW(32);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -8,120,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 704,-3104,704,-3360); \tDATA(3, 256,0.+kC,TEX_X,29); \t\tDATA3(4, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(5, 512,-3328,512,-3304); \tDATA(6, 24,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 512,-3160,512,-3136); \tDATA(9, 24,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 512,-3136,680,-3104); \tDATA(12, 171,0.,TEX_STARTAN3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 680,-3104,704,-3104); \tDATA(15, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 704,-3360,680,-3360); \tDATA(18, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 680,-3360,512,-3328); \tDATA(21, 171,0.,TEX_STARTAN3,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 496,-3304,496,-3160); \tDATA(24, 144,0.+kC,TEX_X,32); \t\tDATA3(25, TEX_X,TEX_X,0);\n\tDATA(26, 512,-3304,496,-3304); \tDATA(27, 16,0.-kC,TEX_DOORTRAK,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 496,-3160,512,-3160); \tDATA(30, 16,0.-kC,TEX_DOORTRAK,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 32\n\t\tBEGIN_ROW(33);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -8,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 496,-3160,496,-3304); \tDATA(3, 144,0.+kC,TEX_X,31); \t\tDATA3(4, TEX_X,TEX_STARG3,0);\n\tDATA(5, 496,-3304,496,-3328); \tDATA(6, 24,0.+kC,TEX_STARG3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 496,-3328,448,-3456); \tDATA(9, 136,0.,TEX_STARG3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 448,-3456,128,-3456); \tDATA(12, 320,0.-kC,TEX_STARG3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 128,-3008,448,-3008); \tDATA(15, 320,0.-kC,TEX_STARG3,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 496,-3136,496,-3160); \tDATA(18, 24,0.+kC,TEX_STARG3,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 448,-3008,496,-3136); \tDATA(21, 136,0.,TEX_STARG3,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 128,-3264,160,-3264); \tDATA(24, 32,0.-kC,TEX_X,48); \t\tDATA3(25, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(26, 160,-3264,192,-3264); \tDATA(27, 32,0.-kC,TEX_X,39); \t\tDATA3(28, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(29, 192,-3264,224,-3264); \tDATA(30, 32,0.-kC,TEX_X,38); \t\tDATA3(31, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(32, 224,-3264,256,-3264); \tDATA(33, 32,0.-kC,TEX_X,37); \t\tDATA3(34, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(35, 256,-3264,288,-3264); \tDATA(36, 32,0.-kC,TEX_X,34); \t\tDATA3(37, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(38, 288,-3264,320,-3264); \tDATA(39, 32,0.-kC,TEX_X,33); \t\tDATA3(40, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(41, 320,-3264,320,-3200); \tDATA(42, 64,0.+kC,TEX_X,33); \t\tDATA3(43, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(44, 320,-3200,288,-3200); \tDATA(45, 32,0.-kC,TEX_X,33); \t\tDATA3(46, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(47, 288,-3200,256,-3200); \tDATA(48, 32,0.-kC,TEX_X,34); \t\tDATA3(49, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(50, 256,-3200,224,-3200); \tDATA(51, 32,0.-kC,TEX_X,37); \t\tDATA3(52, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(53, 224,-3200,192,-3200); \tDATA(54, 32,0.-kC,TEX_X,38); \t\tDATA3(55, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(56, 192,-3200,160,-3200); \tDATA(57, 32,0.-kC,TEX_X,39); \t\tDATA3(58, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(59, 160,-3200,128,-3200); \tDATA(60, 32,0.-kC,TEX_X,48); \t\tDATA3(61, TEX_SLADWALL,TEX_STARTAN3,0);\n\tDATA(62, 128,-3200,64,-3072); \tDATA(63, 143,0.,TEX_X,47); \t\tDATA3(64, TEX_STARG3,TEX_STARG3,0);\n\tDATA(65, 64,-3072,128,-3008); \tDATA(66, 90,0.,TEX_STARG3,-1); \t\tDATA3(67, TEX_X,TEX_X,2);\n\tDATA(68, 128,-3456,64,-3392); \tDATA(69, 90,0.,TEX_STARG3,-1); \t\tDATA3(70, TEX_X,TEX_X,2);\n\tDATA(71, 64,-3392,128,-3264); \tDATA(72, 143,0.,TEX_X,47); \t\tDATA3(73, TEX_STARG3,TEX_STARG3,0);\n\tDATA(74, 256,-3136,320,-3136); \tDATA(75, 64,0.-kC,TEX_X,36); \t\tDATA3(76, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\tDATA(77, 320,-3136,320,-3072); \tDATA(78, 64,0.+kC,TEX_X,36); \t\tDATA3(79, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\tDATA(80, 320,-3072,256,-3072); \tDATA(81, 64,0.-kC,TEX_X,36); \t\tDATA3(82, TEX_SW1COMP,TEX_TEKWALL4,0);\n\tDATA(83, 256,-3072,256,-3136); \tDATA(84, 64,0.+kC,TEX_X,36); \t\tDATA3(85, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\tDATA(86, 256,-3392,320,-3392); \tDATA(87, 64,0.-kC,TEX_X,35); \t\tDATA3(88, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\tDATA(89, 320,-3392,320,-3328); \tDATA(90, 64,0.+kC,TEX_X,35); \t\tDATA3(91, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\tDATA(92, 320,-3328,256,-3328); \tDATA(93, 64,0.-kC,TEX_X,35); \t\tDATA3(94, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\tDATA(95, 256,-3328,256,-3392); \tDATA(96, 64,0.+kC,TEX_X,35); \t\tDATA3(97, TEX_TEKWALL4,TEX_TEKWALL4,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 33\n\t\tBEGIN_ROW(34);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 8,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 320,-3264,288,-3264); \tDATA(3, 32,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 320,-3200,320,-3264); \tDATA(6, 64,0.+kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 288,-3200,320,-3200); \tDATA(9, 32,0.-kC,TEX_X,32); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 288,-3264,288,-3200); \tDATA(12, 64,0.+kC,TEX_X,34); \t\tDATA3(13, TEX_STEP6,TEX_STARTAN3,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 34\n\t\tBEGIN_ROW(35);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 24,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 288,-3264,256,-3264); \tDATA(3, 32,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 256,-3200,288,-3200); \tDATA(6, 32,0.-kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 256,-3264,256,-3200); \tDATA(9, 64,0.+kC,TEX_X,37); \t\tDATA3(10, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(11, 288,-3200,288,-3264); \tDATA(12, 64,0.+kC,TEX_X,33); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 35\n\t\tBEGIN_ROW(36);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 40,184,TEX_STEP2,TEX_TLITE6_1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 320,-3392,256,-3392); \tDATA(3, 64,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 320,-3328,320,-3392); \tDATA(6, 64,0.+kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 256,-3328,320,-3328); \tDATA(9, 64,0.-kC,TEX_X,32); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 256,-3392,256,-3328); \tDATA(12, 64,0.+kC,TEX_X,32); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 36\n\t\tBEGIN_ROW(37);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 40,184,TEX_STEP2,TEX_TLITE6_1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 320,-3136,256,-3136); \tDATA(3, 64,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 320,-3072,320,-3136); \tDATA(6, 64,0.+kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 256,-3072,320,-3072); \tDATA(9, 64,0.-kC,TEX_X,32); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 256,-3136,256,-3072); \tDATA(12, 64,0.+kC,TEX_X,32); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 37\n\t\tBEGIN_ROW(38);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 40,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 256,-3264,224,-3264); \tDATA(3, 32,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 224,-3200,256,-3200); \tDATA(6, 32,0.-kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 224,-3264,224,-3200); \tDATA(9, 64,0.+kC,TEX_X,38); \t\tDATA3(10, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(11, 256,-3200,256,-3264); \tDATA(12, 64,0.+kC,TEX_X,34); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 38\n\t\tBEGIN_ROW(39);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 56,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 224,-3264,192,-3264); \tDATA(3, 32,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 192,-3200,224,-3200); \tDATA(6, 32,0.-kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 192,-3264,192,-3200); \tDATA(9, 64,0.+kC,TEX_X,39); \t\tDATA3(10, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(11, 224,-3200,224,-3264); \tDATA(12, 64,0.+kC,TEX_X,37); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 39\n\t\tBEGIN_ROW(40);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 72,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 192,-3264,160,-3264); \tDATA(3, 32,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 160,-3200,192,-3200); \tDATA(6, 32,0.-kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 160,-3264,160,-3200); \tDATA(9, 64,0.+kC,TEX_X,48); \t\tDATA3(10, TEX_STEP6,TEX_STARTAN3,0);\n\tDATA(11, 192,-3200,192,-3264); \tDATA(12, 64,0.+kC,TEX_X,38); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 40\n\t\tBEGIN_ROW(41);\n\t\tDATA1(0, 0.878);\n\t\tDATA(1, 0,128,TEX_FLOOR7_1,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 64,-3648,-640,-3648); \tDATA(3, 704,0.-kC,TEX_BROWN144,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, -640,-3648,-768,-3520); \tDATA(6, 181,0.,TEX_BROWN144,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, -768,-3520,-768,-2944); \tDATA(9, 576,0.+kC,TEX_BROWN144,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, -768,-2944,-640,-2816); \tDATA(12, 181,0.,TEX_BROWN144,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, -640,-2816,64,-2816); \tDATA(15, 704,0.-kC,TEX_BROWN144,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, -640,-3520,64,-3648); \tDATA(18, 715,0.,TEX_X,42); \t\tDATA3(19, TEX_X,TEX_X,1);\n\tDATA(20, -640,-2944,-640,-3520); \tDATA(21, 576,0.+kC,TEX_X,42); \t\tDATA3(22, TEX_X,TEX_X,1);\n\tDATA(23, 64,-2816,-640,-2944); \tDATA(24, 715,0.,TEX_X,42); \t\tDATA3(25, TEX_X,TEX_X,1);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 41\n\t\tBEGIN_ROW(42);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, 104,264,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, -256,-3328,-320,-3296); \tDATA(3, 71,0.,TEX_STARTAN3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, -320,-3168,-256,-3136); \tDATA(6, 71,0.,TEX_STARTAN3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, -64,-3136,-64,-3328); \tDATA(9, 192,0.+kC,TEX_X,47); \t\tDATA3(10, TEX_STARG3,TEX_STARG3,0);\n\tDATA(11, -128,-3328,-256,-3328); \tDATA(12, 128,0.-kC,TEX_X,46); \t\tDATA3(13, TEX_STARTAN3,TEX_STARTAN3,2);\n\tDATA(14, -256,-3136,-128,-3136); \tDATA(15, 128,0.-kC,TEX_X,43); \t\tDATA3(16, TEX_STARTAN3,TEX_STARTAN3,2);\n\tDATA(17, -320,-3296,-320,-3168); \tDATA(18, 128,0.+kC,TEX_X,45); \t\tDATA3(19, TEX_STARTAN3,TEX_STARTAN3,2);\n\tDATA(20, -128,-3136,-88,-3136); \tDATA(21, 40,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, -88,-3136,-64,-3136); \tDATA(24, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, -64,-3328,-88,-3328); \tDATA(27, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, -88,-3328,-128,-3328); \tDATA(30, 40,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, -240,-3264,-208,-3264); \tDATA(33, 32,0.-kC,TEX_X,44); \t\tDATA3(34, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(35, -208,-3264,-192,-3248); \tDATA(36, 22,0.,TEX_X,44); \t\tDATA3(37, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(38, -192,-3248,-192,-3216); \tDATA(39, 32,0.+kC,TEX_X,44); \t\tDATA3(40, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(41, -192,-3216,-208,-3200); \tDATA(42, 22,0.,TEX_X,44); \t\tDATA3(43, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(44, -208,-3200,-240,-3200); \tDATA(45, 32,0.-kC,TEX_X,44); \t\tDATA3(46, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(47, -240,-3200,-256,-3216); \tDATA(48, 22,0.,TEX_X,44); \t\tDATA3(49, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(50, -256,-3216,-256,-3248); \tDATA(51, 32,0.+kC,TEX_X,44); \t\tDATA3(52, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\tDATA(53, -256,-3248,-240,-3264); \tDATA(54, 22,0.,TEX_X,44); \t\tDATA3(55, TEX_TEKWALL1,TEX_TEKWALL1,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 42\n\t\tBEGIN_ROW(43);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 0,264,TEX_FLOOR7_1,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, -256,-3120,-336,-3120); \tDATA(3, 80,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, -336,-3120,-336,-3168); \tDATA(6, 48,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, -336,-3296,-336,-3344); \tDATA(9, 48,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, -336,-3344,-256,-3344); \tDATA(12, 80,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, -128,-3344,-96,-3344); \tDATA(15, 32,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, -96,-3344,64,-3520); \tDATA(18, 237,0.,TEX_STARTAN3,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, -96,-3120,-128,-3120); \tDATA(21, 32,0.-kC,TEX_STARTAN3,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 64,-2944,-96,-3120); \tDATA(24, 237,0.,TEX_STARTAN3,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, -256,-3344,-128,-3344); \tDATA(27, 128,0.-kC,TEX_X,46); \t\tDATA3(28, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(29, -128,-3120,-256,-3120); \tDATA(30, 128,0.-kC,TEX_X,43); \t\tDATA3(31, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(32, -336,-3168,-336,-3296); \tDATA(33, 128,0.+kC,TEX_X,45); \t\tDATA3(34, TEX_STARTAN3,TEX_STARTAN3,0);\n\tDATA(35, 64,-2816,64,-2944); \tDATA(36, 128,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(37, TEX_X,TEX_X,2);\n\tDATA(38, 64,-3520,64,-3648); \tDATA(39, 128,0.+kC,TEX_STARTAN3,-1); \t\tDATA3(40, TEX_X,TEX_X,2);\n\tDATA(41, 64,-3648,-640,-3520); \tDATA(42, 715,0.,TEX_X,40); \t\tDATA3(43, TEX_STARG3,TEX_X,1);\n\tDATA(44, -640,-3520,-640,-2944); \tDATA(45, 576,0.+kC,TEX_X,40); \t\tDATA3(46, TEX_STARG3,TEX_X,1);\n\tDATA(47, -640,-2944,64,-2816); \tDATA(48, 715,0.,TEX_X,40); \t\tDATA3(49, TEX_STARG3,TEX_X,1);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 43\n\t\tBEGIN_ROW(44);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 136,240,TEX_FLAT20,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, -128,-3120,-128,-3136); \tDATA(3, 16,0.+kC,TEX_DOORSTOP,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, -256,-3136,-256,-3120); \tDATA(6, 16,0.+kC,TEX_DOORSTOP,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, -128,-3136,-256,-3136); \tDATA(9, 128,0.-kC,TEX_X,41); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, -256,-3120,-128,-3120); \tDATA(12, 128,0.-kC,TEX_X,42); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 44\n\t\tBEGIN_ROW(45);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, 128,264,TEX_FLOOR1_1,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, -208,-3264,-240,-3264); \tDATA(3, 32,0.-kC,TEX_X,41); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, -192,-3248,-208,-3264); \tDATA(6, 22,0.,TEX_X,41); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, -192,-3216,-192,-3248); \tDATA(9, 32,0.+kC,TEX_X,41); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, -208,-3200,-192,-3216); \tDATA(12, 22,0.,TEX_X,41); \t\tDATA3(13, TEX_X,TEX_X,0);\n\tDATA(14, -240,-3200,-208,-3200); \tDATA(15, 32,0.-kC,TEX_X,41); \t\tDATA3(16, TEX_X,TEX_X,0);\n\tDATA(17, -256,-3216,-240,-3200); \tDATA(18, 22,0.,TEX_X,41); \t\tDATA3(19, TEX_X,TEX_X,0);\n\tDATA(20, -256,-3248,-256,-3216); \tDATA(21, 32,0.+kC,TEX_X,41); \t\tDATA3(22, TEX_X,TEX_X,0);\n\tDATA(23, -240,-3264,-256,-3248); \tDATA(24, 22,0.,TEX_X,41); \t\tDATA3(25, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 45\n\t\tBEGIN_ROW(46);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 136,240,TEX_FLAT20,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, -320,-3296,-336,-3296); \tDATA(3, 16,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, -336,-3168,-320,-3168); \tDATA(6, 16,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, -320,-3168,-320,-3296); \tDATA(9, 128,0.+kC,TEX_X,41); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, -336,-3296,-336,-3168); \tDATA(12, 128,0.+kC,TEX_X,42); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 46\n\t\tBEGIN_ROW(47);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 136,240,TEX_FLAT20,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, -256,-3344,-256,-3328); \tDATA(3, 16,0.+kC,TEX_DOORSTOP,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, -128,-3328,-128,-3344); \tDATA(6, 16,0.+kC,TEX_DOORSTOP,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, -256,-3328,-128,-3328); \tDATA(9, 128,0.-kC,TEX_X,41); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, -128,-3344,-256,-3344); \tDATA(12, 128,0.-kC,TEX_X,42); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 47\n\t\tBEGIN_ROW(48);\n\t\tDATA1(0, 0.690);\n\t\tDATA(1, 104,192,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 128,-3200,128,-3264); \tDATA(3, 64,0.+kC,TEX_X,48); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 64,-3072,128,-3200); \tDATA(6, 143,0.,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 128,-3264,64,-3392); \tDATA(9, 143,0.,TEX_X,32); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 64,-3392,48,-3392); \tDATA(12, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 48,-3392,-64,-3328); \tDATA(15, 128,0.,TEX_STARG3,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, -64,-3136,48,-3072); \tDATA(18, 128,0.,TEX_STARG3,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 48,-3072,64,-3072); \tDATA(21, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, -64,-3328,-64,-3136); \tDATA(24, 192,0.+kC,TEX_X,41); \t\tDATA3(25, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 48\n\t\tBEGIN_ROW(49);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, 88,224,TEX_FLOOR4_8,TEX_FLOOR7_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 160,-3264,128,-3264); \tDATA(3, 32,0.-kC,TEX_X,32); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 128,-3200,160,-3200); \tDATA(6, 32,0.-kC,TEX_X,32); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 160,-3200,160,-3264); \tDATA(9, 64,0.+kC,TEX_X,39); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 128,-3264,128,-3200); \tDATA(12, 64,0.+kC,TEX_X,47); \t\tDATA3(13, TEX_STARG3,TEX_STARG3,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 49\n\t\tBEGIN_ROW(50);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, -24,176,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2880,-2912,2880,-2880); \tDATA(3, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2752,-3048,2752,-2912); \tDATA(6, 136,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2752,-2784,2944,-2656); \tDATA(9, 230,0.,TEX_X,50); \t\tDATA3(10, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(11, 3048,-2880,2752,-3048); \tDATA(12, 340,0.,TEX_X,56); \t\tDATA3(13, TEX_X,TEX_X,0);\n\tDATA(14, 2880,-2880,2752,-2800); \tDATA(15, 150,0.,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2752,-2800,2752,-2784); \tDATA(18, 16,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 2944,-2656,2960,-2656); \tDATA(21, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 2960,-2656,3048,-2880); \tDATA(24, 240,0.,TEX_BROWNGRN,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 2752,-2912,2880,-2912); \tDATA(27, 128,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 50\n\t\tBEGIN_ROW(51);\n\t\tDATA1(0, 0.627);\n\t\tDATA(1, -16,72,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2752,-2784,2624,-2784); \tDATA(3, 128,0.-kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2752,-2560,2944,-2656); \tDATA(6, 214,0.,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2944,-2656,2752,-2784); \tDATA(9, 230,0.,TEX_X,49); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2624,-2784,2752,-2560); \tDATA(12, 257,0.,TEX_X,61); \t\tDATA3(13, TEX_BROWN1,TEX_BROWN1,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 51\n\t\tBEGIN_ROW(52);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, -48,176,TEX_NUKAGE3,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2752,-3584,2752,-3360); \tDATA(3, 224,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2752,-3360,2944,-3536); \tDATA(6, 260,0.,TEX_X,57); \t\tDATA3(7, TEX_NUKE24,TEX_X,0);\n\tDATA(8, 2944,-3536,2752,-3584); \tDATA(9, 197,0.,TEX_X,52); \t\tDATA3(10, TEX_NUKE24,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 52\n\t\tBEGIN_ROW(53);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, -24,176,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2944,-3648,2752,-3584); \tDATA(3, 202,0.,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3072,-3648,3072,-4000); \tDATA(6, 352,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2944,-3776,2944,-3648); \tDATA(9, 128,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2944,-3536,3072,-3648); \tDATA(12, 170,0.,TEX_X,56); \t\tDATA3(13, TEX_NUKE24,TEX_X,0);\n\tDATA(14, 2752,-3584,2944,-3536); \tDATA(15, 197,0.,TEX_X,51); \t\tDATA3(16, TEX_X,TEX_X,0);\n\tDATA(17, 2944,-3904,2944,-3776); \tDATA(18, 128,0.+kC,TEX_X,83); \t\tDATA3(19, TEX_BROWN96,TEX_BROWN96,0);\n\tDATA(20, 2944,-4000,2944,-3904); \tDATA(21, 96,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 3072,-4000,2944,-4000); \tDATA(24, 128,0.-kC,TEX_X,82); \t\tDATA3(25, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 53\n\t\tBEGIN_ROW(54);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, -48,176,TEX_NUKAGE3,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3136,-3072,3304,-3040); \tDATA(3, 171,0.,TEX_X,56); \t\tDATA3(4, TEX_NUKE24,TEX_X,0);\n\tDATA(5, 3280,-3320,2984,-3200); \tDATA(6, 319,0.,TEX_X,56); \t\tDATA3(7, TEX_NUKE24,TEX_X,0);\n\tDATA(8, 2984,-3200,3136,-3072); \tDATA(9, 198,0.,TEX_X,56); \t\tDATA3(10, TEX_NUKE24,TEX_X,0);\n\tDATA(11, 3104,-3552,3280,-3320); \tDATA(12, 291,0.,TEX_X,56); \t\tDATA3(13, TEX_NUKE24,TEX_X,0);\n\tDATA(14, 3264,-3616,3104,-3552); \tDATA(15, 172,0.,TEX_X,56); \t\tDATA3(16, TEX_NUKE24,TEX_X,0);\n\tDATA(17, 3352,-3568,3264,-3616); \tDATA(18, 100,0.,TEX_BROWNGRN,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 3472,-3432,3408,-3432); \tDATA(21, 64,0.-kC,TEX_X,55); \t\tDATA3(22, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(23, 3408,-3432,3312,-3496); \tDATA(24, 115,0.,TEX_X,55); \t\tDATA3(25, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(26, 3312,-3496,3352,-3568); \tDATA(27, 82,0.,TEX_X,55); \t\tDATA3(28, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(29, 3400,-3152,3472,-3432); \tDATA(30, 289,0.,TEX_BROWNGRN,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, 3304,-3040,3400,-3152); \tDATA(33, 147,0.,TEX_BROWNGRN,58); \t\tDATA3(34, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 54\n\t\tBEGIN_ROW(55);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -48,104,TEX_FLOOR4_8,TEX_FLOOR6_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3352,-3568,3448,-3520); \tDATA(3, 107,0.,TEX_X,55); \t\tDATA3(4, TEX_BROWNGRN,TEX_X,0);\n\tDATA(5, 3520,-3904,3328,-3968); \tDATA(6, 202,0.,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3328,-3744,3360,-3648); \tDATA(9, 101,0.,TEX_BROWNGRN,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3328,-3968,3328,-3744); \tDATA(12, 224,0.+kC,TEX_X,86); \t\tDATA3(13, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(14, 3448,-3520,3472,-3520); \tDATA(15, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3472,-3520,3520,-3584); \tDATA(18, 80,0.,TEX_BROWNGRN,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 3360,-3648,3352,-3592); \tDATA(21, 56,0.,TEX_BROWNGRN,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 3352,-3592,3352,-3568); \tDATA(24, 24,0.+kC,TEX_SUPPORT2,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 3520,-3584,3520,-3840); \tDATA(27, 256,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 3520,-3840,3520,-3904); \tDATA(30, 64,0.+kC,TEX_X,87); \t\tDATA3(31, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 55\n\t\tBEGIN_ROW(56);\n\t\tDATA1(0, 0.627);\n\t\tDATA(1, 96,176,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3408,-3432,3472,-3432); \tDATA(3, 64,0.-kC,TEX_X,53); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 3312,-3496,3408,-3432); \tDATA(6, 115,0.,TEX_X,53); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 3352,-3568,3312,-3496); \tDATA(9, 82,0.,TEX_X,53); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 3472,-3432,3448,-3520); \tDATA(12, 91,0.,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3448,-3520,3352,-3568); \tDATA(15, 107,0.,TEX_X,54); \t\tDATA3(16, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 56\n\t\tBEGIN_ROW(57);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, -24,176,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3048,-2880,3048,-2944); \tDATA(3, 64,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3048,-2944,3304,-3040); \tDATA(6, 273,0.,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3304,-3040,3136,-3072); \tDATA(9, 171,0.,TEX_X,53); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2944,-3536,3112,-3360); \tDATA(12, 243,0.,TEX_X,57); \t\tDATA3(13, TEX_X,TEX_X,0);\n\tDATA(14, 3112,-3360,2816,-3232); \tDATA(15, 322,0.,TEX_X,57); \t\tDATA3(16, TEX_X,TEX_X,0);\n\tDATA(17, 2984,-3200,3280,-3320); \tDATA(18, 319,0.,TEX_X,53); \t\tDATA3(19, TEX_X,TEX_X,0);\n\tDATA(20, 2816,-3232,2976,-3072); \tDATA(21, 226,0.,TEX_X,57); \t\tDATA3(22, TEX_X,TEX_X,0);\n\tDATA(23, 3136,-3072,2984,-3200); \tDATA(24, 198,0.,TEX_X,53); \t\tDATA3(25, TEX_X,TEX_X,0);\n\tDATA(26, 3264,-3616,3072,-3648); \tDATA(27, 194,0.,TEX_BROWNGRN,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 3072,-3648,2944,-3536); \tDATA(30, 170,0.,TEX_X,52); \t\tDATA3(31, TEX_X,TEX_X,0);\n\tDATA(32, 2752,-3048,3048,-2880); \tDATA(33, 340,0.,TEX_X,49); \t\tDATA3(34, TEX_NUKE24,TEX_X,0);\n\tDATA(35, 3280,-3320,3104,-3552); \tDATA(36, 291,0.,TEX_X,53); \t\tDATA3(37, TEX_X,TEX_X,0);\n\tDATA(38, 3104,-3552,3264,-3616); \tDATA(39, 172,0.,TEX_X,53); \t\tDATA3(40, TEX_X,TEX_X,0);\n\tDATA(41, 2976,-3072,2752,-3048); \tDATA(42, 225,0.,TEX_X,57); \t\tDATA3(43, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 57\n\t\tBEGIN_ROW(58);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, -48,176,TEX_NUKAGE3,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3112,-3360,2944,-3536); \tDATA(3, 243,0.,TEX_X,56); \t\tDATA3(4, TEX_NUKE24,TEX_X,0);\n\tDATA(5, 2816,-3232,3112,-3360); \tDATA(6, 322,0.,TEX_X,56); \t\tDATA3(7, TEX_NUKE24,TEX_X,0);\n\tDATA(8, 2976,-3072,2816,-3232); \tDATA(9, 226,0.,TEX_X,56); \t\tDATA3(10, TEX_NUKE24,TEX_X,0);\n\tDATA(11, 2944,-3536,2752,-3360); \tDATA(12, 260,0.,TEX_X,51); \t\tDATA3(13, TEX_X,TEX_X,0);\n\tDATA(14, 2752,-3048,2976,-3072); \tDATA(15, 225,0.,TEX_X,56); \t\tDATA3(16, TEX_NUKE24,TEX_X,0);\n\tDATA(17, 2752,-3360,2752,-3112); \tDATA(18, 248,0.+kC,TEX_X,62); \t\tDATA3(19, TEX_BROWNGRN,TEX_BROWNGRN,2);\n\tDATA(20, 2752,-3112,2752,-3048); \tDATA(21, 64,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 58\n\t\tBEGIN_ROW(59);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, 104,184,TEX_FLOOR4_8,TEX_FLOOR6_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3680,-3904,3584,-3904); \tDATA(3, 96,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3744,-3808,3680,-3904); \tDATA(6, 115,0.,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3584,-3840,3616,-3776); \tDATA(9, 71,0.,TEX_BROWNGRN,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3616,-3776,3552,-3552); \tDATA(12, 232,0.,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3552,-3552,3552,-3392); \tDATA(15, 160,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3552,-3392,3648,-3264); \tDATA(18, 160,0.,TEX_BROWNGRN,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 3680,-3552,3744,-3808); \tDATA(21, 263,0.,TEX_BROWNGRN,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 3680,-3392,3680,-3552); \tDATA(24, 160,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 3808,-3264,3680,-3392); \tDATA(27, 181,0.,TEX_BROWNGRN,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 3648,-3264,3496,-3032); \tDATA(30, 277,0.,TEX_BROWNGRN,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, 3584,-2880,3808,-3264); \tDATA(33, 444,0.,TEX_BROWNGRN,-1); \t\tDATA3(34, TEX_X,TEX_X,2);\n\tDATA(35, 3496,-3032,3456,-3032); \tDATA(36, 40,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(37, TEX_X,TEX_X,2);\n\tDATA(38, 3360,-2880,3584,-2880); \tDATA(39, 224,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(40, TEX_X,TEX_X,2);\n\tDATA(41, 3400,-3152,3304,-3040); \tDATA(42, 147,0.,TEX_X,53); \t\tDATA3(43, TEX_X,TEX_BROWNGRN,0);\n\tDATA(44, 3584,-3904,3584,-3840); \tDATA(45, 64,0.+kC,TEX_X,87); \t\tDATA3(46, TEX_X,TEX_X,0);\n\tDATA(47, 3304,-3040,3320,-3040); \tDATA(48, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(49, TEX_X,TEX_X,2);\n\tDATA(50, 3320,-3040,3360,-2880); \tDATA(51, 164,0.,TEX_BROWNGRN,-1); \t\tDATA3(52, TEX_X,TEX_X,2);\n\tDATA(53, 3456,-3032,3416,-3152); \tDATA(54, 126,0.,TEX_BROWNGRN,-1); \t\tDATA3(55, TEX_X,TEX_X,2);\n\tDATA(56, 3416,-3152,3400,-3152); \tDATA(57, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(58, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 59\n\t\tBEGIN_ROW(60);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 16,152,TEX_FLAT14,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2176,-2304,2208,-2304); \tDATA(3, 32,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2208,-2560,2176,-2560); \tDATA(6, 32,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2176,-2560,2176,-2304); \tDATA(9, 256,0.+kC,TEX_X,20); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2208,-2304,2208,-2560); \tDATA(12, 256,0.+kC,TEX_X,60); \t\tDATA3(13, TEX_STEP1,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 60\n\t\tBEGIN_ROW(61);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, 24,152,TEX_FLAT14,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2208,-2304,2304,-2304); \tDATA(3, 96,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2304,-2304,2304,-2560); \tDATA(6, 256,0.+kC,TEX_COMPTILE,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2304,-2560,2208,-2560); \tDATA(9, 96,0.-kC,TEX_COMPTILE,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2208,-2560,2208,-2304); \tDATA(12, 256,0.+kC,TEX_X,59); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 61\n\t\tBEGIN_ROW(62);\n\t\tDATA1(0, 0.627);\n\t\tDATA(1, -8,72,TEX_FLOOR4_8,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2520,-2560,2752,-2560); \tDATA(3, 232,0.-kC,TEX_BROWN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2624,-2784,2520,-2688); \tDATA(6, 141,0.,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2496,-2560,2520,-2560); \tDATA(9, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2520,-2688,2496,-2688); \tDATA(12, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2496,-2688,2496,-2560); \tDATA(15, 128,0.+kC,TEX_X,15); \t\tDATA3(16, TEX_BROWN1,TEX_X,0);\n\tDATA(17, 2752,-2560,2624,-2784); \tDATA(18, 257,0.,TEX_X,50); \t\tDATA3(19, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 62\n\t\tBEGIN_ROW(63);\n\t\tDATA1(0, 0.753);\n\t\tDATA(1, 0,136,TEX_FLAT20,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2752,-3360,2736,-3360); \tDATA(3, 16,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2736,-3112,2752,-3112); \tDATA(6, 16,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2752,-3112,2752,-3360); \tDATA(9, 248,0.+kC,TEX_X,57); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2736,-3360,2736,-3112); \tDATA(12, 248,0.+kC,TEX_X,1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 63\n\t\tBEGIN_ROW(64);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -56,24,TEX_FLOOR7_1,TEX_F_SKY1);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2736,-3648,2488,-3744); \tDATA(3, 265,0.,TEX_BROWN144,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2488,-3744,2240,-3776); \tDATA(6, 250,0.,TEX_BROWN144,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2240,-3648,2736,-3648); \tDATA(9, 496,0.-kC,TEX_X,1); \t\tDATA3(10, TEX_X,TEX_X,1);\n\tDATA(11, 2240,-3776,2240,-3648); \tDATA(12, 128,0.+kC,TEX_X,12); \t\tDATA3(13, TEX_STARTAN3,TEX_X,1);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 64\n\t\tBEGIN_ROW(65);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,104,TEX_FLOOR5_2,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2856,-4160,2888,-4160); \tDATA(3, 32,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2888,-4160,2912,-4160); \tDATA(6, 24,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3160,-4352,3128,-4352); \tDATA(9, 32,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3128,-4352,3104,-4352); \tDATA(12, 24,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3104,-4160,3128,-4160); \tDATA(15, 24,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3128,-4160,3160,-4160); \tDATA(18, 32,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 2912,-4352,2888,-4352); \tDATA(21, 24,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 2888,-4352,2856,-4352); \tDATA(24, 32,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 2888,-4320,2888,-4352); \tDATA(27, 32,0.+kC,TEX_BRNBIGR,64); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 2888,-4352,2888,-4320); \tDATA(30, 32,0.+kC,TEX_BRNBIGL,64); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, 2888,-4192,2888,-4320); \tDATA(33, 128,0.+kC,TEX_BRNBIGC,64); \t\tDATA3(34, TEX_X,TEX_X,2);\n\tDATA(35, 2888,-4320,2888,-4192); \tDATA(36, 128,0.+kC,TEX_BRNBIGC,64); \t\tDATA3(37, TEX_X,TEX_X,2);\n\tDATA(38, 2888,-4160,2888,-4192); \tDATA(39, 32,0.+kC,TEX_BRNBIGL,64); \t\tDATA3(40, TEX_X,TEX_X,2);\n\tDATA(41, 2888,-4192,2888,-4160); \tDATA(42, 32,0.+kC,TEX_BRNBIGR,64); \t\tDATA3(43, TEX_X,TEX_X,2);\n\tDATA(44, 3128,-4352,3128,-4320); \tDATA(45, 32,0.+kC,TEX_BRNBIGL,64); \t\tDATA3(46, TEX_X,TEX_X,2);\n\tDATA(47, 3128,-4320,3128,-4352); \tDATA(48, 32,0.+kC,TEX_BRNBIGR,64); \t\tDATA3(49, TEX_X,TEX_X,2);\n\tDATA(50, 3128,-4192,3128,-4160); \tDATA(51, 32,0.+kC,TEX_BRNBIGR,64); \t\tDATA3(52, TEX_X,TEX_X,2);\n\tDATA(53, 3128,-4160,3128,-4192); \tDATA(54, 32,0.+kC,TEX_BRNBIGL,64); \t\tDATA3(55, TEX_X,TEX_X,2);\n\tDATA(56, 3128,-4320,3128,-4192); \tDATA(57, 128,0.+kC,TEX_BRNBIGC,64); \t\tDATA3(58, TEX_X,TEX_X,2);\n\tDATA(59, 3128,-4192,3128,-4320); \tDATA(60, 128,0.+kC,TEX_BRNBIGC,64); \t\tDATA3(61, TEX_X,TEX_X,2);\n\tDATA(62, 2912,-4160,3104,-4160); \tDATA(63, 192,0.-kC,TEX_X,84); \t\tDATA3(64, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(65, 3104,-4352,2912,-4352); \tDATA(66, 192,0.-kC,TEX_X,65); \t\tDATA3(67, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(68, 2856,-4352,2856,-4160); \tDATA(69, 192,0.+kC,TEX_X,65); \t\tDATA3(70, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(71, 3160,-4160,3160,-4352); \tDATA(72, 192,0.+kC,TEX_X,65); \t\tDATA3(73, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 65\n\t\tBEGIN_ROW(66);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -24,48,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3200,-4128,3328,-4128); \tDATA(3, 128,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2688,-4128,2816,-4128); \tDATA(6, 128,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2816,-4128,2856,-4160); \tDATA(9, 51,0.,TEX_BROWNGRN,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3160,-4160,3200,-4128); \tDATA(12, 51,0.,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3104,-4352,3104,-4384); \tDATA(15, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3104,-4384,3160,-4384); \tDATA(18, 56,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 3160,-4384,3160,-4352); \tDATA(21, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 2856,-4352,2856,-4384); \tDATA(24, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\tDATA(26, 2856,-4384,2912,-4384); \tDATA(27, 56,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(28, TEX_X,TEX_X,2);\n\tDATA(29, 2912,-4384,2912,-4352); \tDATA(30, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(31, TEX_X,TEX_X,2);\n\tDATA(32, 3328,-4544,3072,-4544); \tDATA(33, 256,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(34, TEX_X,TEX_X,2);\n\tDATA(35, 2944,-4544,2688,-4544); \tDATA(36, 256,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(37, TEX_X,TEX_X,2);\n\tDATA(38, 2912,-4352,3104,-4352); \tDATA(39, 192,0.-kC,TEX_X,64); \t\tDATA3(40, TEX_X,TEX_X,0);\n\tDATA(41, 2688,-4544,2688,-4128); \tDATA(42, 416,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(43, TEX_X,TEX_X,2);\n\tDATA(44, 3328,-4128,3328,-4544); \tDATA(45, 416,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(46, TEX_X,TEX_X,2);\n\tDATA(47, 2856,-4160,2856,-4352); \tDATA(48, 192,0.+kC,TEX_X,64); \t\tDATA3(49, TEX_X,TEX_X,0);\n\tDATA(50, 3160,-4352,3160,-4160); \tDATA(51, 192,0.+kC,TEX_X,64); \t\tDATA3(52, TEX_X,TEX_X,0);\n\tDATA(53, 3072,-4544,2944,-4544); \tDATA(54, 128,0.-kC,TEX_X,66); \t\tDATA3(55, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 66\n\t\tBEGIN_ROW(67);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,72,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3072,-4544,3072,-4608); \tDATA(3, 64,0.+kC,TEX_LITE3,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2944,-4608,2944,-4544); \tDATA(6, 64,0.+kC,TEX_LITE3,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2944,-4544,3072,-4544); \tDATA(9, 128,0.-kC,TEX_X,65); \t\tDATA3(10, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(11, 3072,-4608,3040,-4608); \tDATA(12, 32,0.-kC,TEX_STARTAN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2976,-4608,2944,-4608); \tDATA(15, 32,0.-kC,TEX_STARTAN1,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3024,-4592,2992,-4592); \tDATA(18, 32,0.-kC,TEX_X,67); \t\tDATA3(19, TEX_X,TEX_EXITSIGN,0);\n\tDATA(20, 2992,-4600,3024,-4600); \tDATA(21, 32,0.-kC,TEX_X,67); \t\tDATA3(22, TEX_X,TEX_EXITSIGN,0);\n\tDATA(23, 3024,-4600,3024,-4592); \tDATA(24, 8,0.+kC,TEX_X,67); \t\tDATA3(25, TEX_X,TEX_EXITSIGN,0);\n\tDATA(26, 2992,-4592,2992,-4600); \tDATA(27, 8,0.+kC,TEX_X,67); \t\tDATA3(28, TEX_X,TEX_EXITSIGN,0);\n\tDATA(29, 3040,-4608,2976,-4608); \tDATA(30, 64,0.-kC,TEX_X,68); \t\tDATA3(31, TEX_X,TEX_STARTAN1,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 67\n\t\tBEGIN_ROW(68);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,56,TEX_FLOOR5_2,TEX_FLAT23);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2992,-4592,3024,-4592); \tDATA(3, 32,0.-kC,TEX_X,66); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 3024,-4600,2992,-4600); \tDATA(6, 32,0.-kC,TEX_X,66); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 3024,-4592,3024,-4600); \tDATA(9, 8,0.+kC,TEX_X,66); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2992,-4600,2992,-4592); \tDATA(12, 8,0.+kC,TEX_X,66); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 68\n\t\tBEGIN_ROW(69);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,48,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2976,-4632,2976,-4608); \tDATA(3, 24,0.+kC,TEX_EXITDOOR,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3040,-4608,3040,-4632); \tDATA(6, 24,0.+kC,TEX_EXITDOOR,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3040,-4632,2976,-4632); \tDATA(9, 64,0.-kC,TEX_X,69); \t\tDATA3(10, TEX_X,TEX_EXITDOOR,0);\n\tDATA(11, 2976,-4608,3040,-4608); \tDATA(12, 64,0.-kC,TEX_X,66); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 69\n\t\tBEGIN_ROW(70);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,-24,TEX_FLOOR5_2,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3040,-4632,3040,-4648); \tDATA(3, 16,0.+kC,TEX_DOORTRAK,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2976,-4648,2976,-4632); \tDATA(6, 16,0.+kC,TEX_DOORTRAK,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3040,-4648,2976,-4648); \tDATA(9, 64,0.-kC,TEX_X,72); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2976,-4632,3040,-4632); \tDATA(12, 64,0.-kC,TEX_X,68); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 70\n\t\tBEGIN_ROW(71);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,88,TEX_FLOOR5_2,TEX_TLITE6_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3040,-4672,3104,-4672); \tDATA(3, 64,0.-kC,TEX_STARTAN1,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2912,-4672,2976,-4672); \tDATA(6, 64,0.-kC,TEX_STARTAN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3104,-4672,3104,-4864); \tDATA(9, 192,0.+kC,TEX_STARTAN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2912,-4864,2912,-4800); \tDATA(12, 64,0.+kC,TEX_STARTAN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2912,-4800,2912,-4736); \tDATA(15, 64,0.+kC,TEX_SW1STRTN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2912,-4736,2912,-4672); \tDATA(18, 64,0.+kC,TEX_STARTAN1,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 3104,-4864,2912,-4864); \tDATA(21, 192,0.-kC,TEX_STARTAN1,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 2976,-4672,3040,-4672); \tDATA(24, 64,0.-kC,TEX_X,72); \t\tDATA3(25, TEX_X,TEX_STARTAN1,0);\n\tDATA(26, 3024,-4840,2992,-4840); \tDATA(27, 32,0.-kC,TEX_X,71); \t\tDATA3(28, TEX_X,TEX_EXITSIGN,0);\n\tDATA(29, 2992,-4848,3024,-4848); \tDATA(30, 32,0.-kC,TEX_X,71); \t\tDATA3(31, TEX_X,TEX_EXITSIGN,0);\n\tDATA(32, 3024,-4848,3024,-4840); \tDATA(33, 8,0.+kC,TEX_X,71); \t\tDATA3(34, TEX_X,TEX_EXITSIGN,0);\n\tDATA(35, 2992,-4840,2992,-4848); \tDATA(36, 8,0.+kC,TEX_X,71); \t\tDATA3(37, TEX_X,TEX_EXITSIGN,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 71\n\t\tBEGIN_ROW(72);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,72,TEX_FLOOR5_2,TEX_FLAT23);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2992,-4840,3024,-4840); \tDATA(3, 32,0.-kC,TEX_X,70); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 3024,-4848,2992,-4848); \tDATA(6, 32,0.-kC,TEX_X,70); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 3024,-4840,3024,-4848); \tDATA(9, 8,0.+kC,TEX_X,70); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2992,-4848,2992,-4840); \tDATA(12, 8,0.+kC,TEX_X,70); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 72\n\t\tBEGIN_ROW(73);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -24,48,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3040,-4648,3040,-4672); \tDATA(3, 24,0.+kC,TEX_EXITDOOR,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2976,-4672,2976,-4648); \tDATA(6, 24,0.+kC,TEX_EXITDOOR,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2976,-4648,3040,-4648); \tDATA(9, 64,0.-kC,TEX_X,69); \t\tDATA3(10, TEX_X,TEX_EXITDOOR,0);\n\tDATA(11, 3040,-4672,2976,-4672); \tDATA(12, 64,0.-kC,TEX_X,70); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 73\n\t\tBEGIN_ROW(74);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -104,48,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2752,-3776,2752,-3904); \tDATA(3, 128,0.+kC,TEX_X,74); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2720,-3904,2688,-3776); \tDATA(6, 131,0.,TEX_X,81); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2688,-3776,2752,-3776); \tDATA(9, 64,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2752,-3904,2720,-3904); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 74\n\t\tBEGIN_ROW(75);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -88,48,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2784,-3776,2784,-3904); \tDATA(3, 128,0.+kC,TEX_X,75); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2752,-3904,2752,-3776); \tDATA(6, 128,0.+kC,TEX_X,73); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2752,-3776,2784,-3776); \tDATA(9, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2784,-3904,2752,-3904); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 75\n\t\tBEGIN_ROW(76);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -72,48,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2816,-3776,2816,-3904); \tDATA(3, 128,0.+kC,TEX_X,76); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2784,-3904,2784,-3776); \tDATA(6, 128,0.+kC,TEX_X,74); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2784,-3776,2816,-3776); \tDATA(9, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2816,-3904,2784,-3904); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 76\n\t\tBEGIN_ROW(77);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -56,48,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2848,-3776,2848,-3904); \tDATA(3, 128,0.+kC,TEX_X,77); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2816,-3904,2816,-3776); \tDATA(6, 128,0.+kC,TEX_X,75); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2816,-3776,2848,-3776); \tDATA(9, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2848,-3904,2816,-3904); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 77\n\t\tBEGIN_ROW(78);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -40,48,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2880,-3776,2880,-3904); \tDATA(3, 128,0.+kC,TEX_X,78); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2848,-3904,2848,-3776); \tDATA(6, 128,0.+kC,TEX_X,76); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 2848,-3776,2880,-3776); \tDATA(9, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2880,-3904,2848,-3904); \tDATA(12, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 78\n\t\tBEGIN_ROW(79);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -24,48,TEX_FLOOR5_2,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2880,-3904,2880,-3776); \tDATA(3, 128,0.+kC,TEX_X,77); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 2880,-3776,2912,-3776); \tDATA(6, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2912,-3904,2880,-3904); \tDATA(9, 32,0.-kC,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2912,-3776,2912,-3904); \tDATA(12, 128,0.+kC,TEX_X,83); \t\tDATA3(13, TEX_BROWN96,TEX_BROWN96,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 79\n\t\tBEGIN_ROW(80);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -136,-24,TEX_FLOOR5_1,TEX_TLITE6_6);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2240,-4096,2240,-3968); \tDATA(3, 128,0.+kC,TEX_X,6); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2368,-3968,2368,-4096); \tDATA(6, 128,0.+kC,TEX_X,80); \t\tDATA3(7, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(8, 2368,-4096,2344,-4096); \tDATA(9, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2344,-4096,2264,-4096); \tDATA(12, 80,0.-kC,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2264,-4096,2240,-4096); \tDATA(15, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2240,-3968,2264,-3968); \tDATA(18, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\tDATA(20, 2264,-3968,2344,-3968); \tDATA(21, 80,0.-kC,TEX_BROWN1,-1); \t\tDATA3(22, TEX_X,TEX_X,2);\n\tDATA(23, 2344,-3968,2368,-3968); \tDATA(24, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(25, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 80\n\t\tBEGIN_ROW(81);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -136,-40,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2368,-4096,2368,-3968); \tDATA(3, 128,0.+kC,TEX_X,79); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 2632,-3792,2688,-3920); \tDATA(6, 139,0.,TEX_X,81); \t\tDATA3(7, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(8, 2688,-3920,2672,-3920); \tDATA(9, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2672,-3920,2368,-4096); \tDATA(12, 351,0.,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 2368,-3968,2616,-3792); \tDATA(15, 304,0.,TEX_BROWN1,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2616,-3792,2632,-3792); \tDATA(18, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 81\n\t\tBEGIN_ROW(82);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -120,48,TEX_FLOOR5_1,TEX_CEIL5_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2688,-3776,2720,-3904); \tDATA(3, 131,0.,TEX_X,73); \t\tDATA3(4, TEX_BROWN1,TEX_BROWN1,0);\n\tDATA(5, 2688,-3920,2632,-3792); \tDATA(6, 139,0.,TEX_X,80); \t\tDATA3(7, TEX_X,TEX_BROWN1,0);\n\tDATA(8, 2632,-3792,2688,-3776); \tDATA(9, 58,0.,TEX_BROWN1,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 2720,-3904,2688,-3920); \tDATA(12, 35,0.,TEX_BROWN1,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 82\n\t\tBEGIN_ROW(83);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -24,48,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2944,-4000,3072,-4000); \tDATA(3, 128,0.-kC,TEX_X,52); \t\tDATA3(4, TEX_X,TEX_X,0);\n\tDATA(5, 2944,-4016,2944,-4000); \tDATA(6, 16,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3072,-4000,3072,-4016); \tDATA(9, 16,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3072,-4016,2944,-4016); \tDATA(12, 128,0.-kC,TEX_X,85); \t\tDATA3(13, TEX_X,TEX_BIGDOOR4,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 83\n\t\tBEGIN_ROW(84);\n\t\tDATA1(0, 0.565);\n\t\tDATA(1, -24,-24,TEX_FLOOR5_2,TEX_FLAT5_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2944,-3904,2912,-3904); \tDATA(3, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 2912,-3776,2944,-3776); \tDATA(6, 32,0.-kC,TEX_DOORSTOP,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2944,-3776,2944,-3904); \tDATA(9, 128,0.+kC,TEX_X,52); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2912,-3904,2912,-3776); \tDATA(12, 128,0.+kC,TEX_X,78); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 84\n\t\tBEGIN_ROW(85);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -24,48,TEX_FLOOR5_2,TEX_CEIL3_5);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2912,-4160,2912,-4128); \tDATA(3, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3104,-4128,3104,-4160); \tDATA(6, 32,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 3104,-4160,2912,-4160); \tDATA(9, 192,0.-kC,TEX_X,64); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 2912,-4128,2944,-4032); \tDATA(12, 101,0.,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3072,-4032,3104,-4128); \tDATA(15, 101,0.,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 2944,-4032,3072,-4032); \tDATA(18, 128,0.-kC,TEX_X,85); \t\tDATA3(19, TEX_X,TEX_BIGDOOR4,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 85\n\t\tBEGIN_ROW(86);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, -24,-24,TEX_FLOOR5_2,TEX_FLAT20);\n\t\t\/\/ Sidedefs\n\tDATA(2, 2944,-4032,2944,-4016); \tDATA(3, 16,0.+kC,TEX_DOORTRAK,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3072,-4016,3072,-4032); \tDATA(6, 16,0.+kC,TEX_DOORTRAK,-1); \t\tDATA3(7, TEX_X,TEX_X,2);\n\tDATA(8, 2944,-4016,3072,-4016); \tDATA(9, 128,0.-kC,TEX_X,82); \t\tDATA3(10, TEX_X,TEX_X,0);\n\tDATA(11, 3072,-4032,2944,-4032); \tDATA(12, 128,0.-kC,TEX_X,84); \t\tDATA3(13, TEX_X,TEX_X,0);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 86\n\t\tBEGIN_ROW(87);\n\t\tDATA1(0, 1.000);\n\t\tDATA(1, -48,32,TEX_FLOOR4_8,TEX_TLITE6_6);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3200,-3968,3200,-3744); \tDATA(3, 224,0.+kC,TEX_BROWNGRN,-1); \t\tDATA3(4, TEX_X,TEX_X,2);\n\tDATA(5, 3328,-3744,3328,-3968); \tDATA(6, 224,0.+kC,TEX_X,54); \t\tDATA3(7, TEX_X,TEX_X,0);\n\tDATA(8, 3328,-3968,3304,-3968); \tDATA(9, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3304,-3968,3200,-3968); \tDATA(12, 104,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3200,-3744,3304,-3744); \tDATA(15, 104,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3304,-3744,3328,-3744); \tDATA(18, 24,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\n\t\t\/\/ Sector Data 87\n\t\tBEGIN_ROW(88);\n\t\tDATA1(0, 0.502);\n\t\tDATA(1, 104,184,TEX_FLOOR4_8,TEX_FLOOR6_2);\n\t\t\/\/ Sidedefs\n\tDATA(2, 3520,-3904,3520,-3840); \tDATA(3, 64,0.+kC,TEX_X,54); \t\tDATA3(4, TEX_X,TEX_BROWNGRN,0);\n\tDATA(5, 3584,-3840,3584,-3904); \tDATA(6, 64,0.+kC,TEX_X,58); \t\tDATA3(7, TEX_BROWNGRN,TEX_BROWNGRN,0);\n\tDATA(8, 3520,-3840,3536,-3840); \tDATA(9, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(10, TEX_X,TEX_X,2);\n\tDATA(11, 3536,-3840,3584,-3840); \tDATA(12, 48,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(13, TEX_X,TEX_X,2);\n\tDATA(14, 3584,-3904,3536,-3904); \tDATA(15, 48,0.-kC,TEX_BROWNGRN,-1); \t\tDATA3(16, TEX_X,TEX_X,2);\n\tDATA(17, 3536,-3904,3520,-3904); \tDATA(18, 16,0.-kC,TEX_SUPPORT2,-1); \t\tDATA3(19, TEX_X,TEX_X,2);\n\t\tEND_ROW();\n\t\tEND_BLOCK();\n\t\t\n\t\t\t\/\/Entities\n\t\t\n\t\tBEGIN_BLOCK(vec2(128, 0));\n\t\tBEGIN_ROW(0);\tDATA( 0, ENTITY_TYPE_PLAYER, 0, 1056, -3616 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\n        \/\/ Doors must be the first entities so we can traverse them below\n\t    #define DOOR_START 1    \n        \n\t\tBEGIN_ROW(1);\n        DATA( 0, ENTITY_TYPE_DOOR, 0, 1545, -2483 );\tDATA( 1, 0, 7, 0, 0 );\n\t\tEND_ROW();\n\n\t\tBEGIN_ROW(2);\n        DATA( 0, ENTITY_TYPE_DOOR, 0, 2926, -3830 );\tDATA( 1, 0, 7, 0, 0 );\n\t\tEND_ROW();\n\n\t\tBEGIN_ROW(3);\n        DATA( 0, ENTITY_TYPE_DOOR, 0, 3000, -4019 );\tDATA( 1, 0, 7, 0, 0 );\n\t\tEND_ROW();\n\n\t\tBEGIN_ROW(4);\n        DATA( 0, ENTITY_TYPE_DOOR, 0, 3000, -4644 );\tDATA( 1, 0, 7, 0, 0 );\n\t\tEND_ROW();\n\n        \/\/ Hacky - final params are trigger location, yaw param is speed, -ive yaw = stays down\n        \n\t\tBEGIN_ROW(5);\n        DATA( 0, ENTITY_TYPE_PLATFORM, 0, 3410, -3489 );\tDATA( 1, -10, 7, 2996, -4070 );\n\t\tEND_ROW();\n\n\t\tBEGIN_ROW(6);\n        DATA( 0, ENTITY_TYPE_PLATFORM, 1, 3533, -3874 );\tDATA( 1, 200, 7, 2945, -2918 );\n\t\tEND_ROW();\n\n        #define DOOR_COUNT 6\n\t    #define DOOR_END ( DOOR_START + DOOR_COUNT )\n\n\n\t\tBEGIN_ROW(7);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR, 288, -3104 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(8);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR, 288, -3360 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(9);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 528, -3312 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(10);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 528, -3152 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(11);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 3440, -3472 );\tDATA( 1, 135, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(12);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 3360, -3504 );\tDATA( 1, 135, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(13);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 2912, -2816 );\tDATA( 1, 90, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(14);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 3056, -3584 );\tDATA( 1, 90, 14, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(15);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 3136, -3408 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(16);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_BLUEARMOR, 1824, -3280 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(17);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 2736, -4256 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(18);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 3280, -4256 );\tDATA( 1, 180, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(19);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 3008, -4416 );\tDATA( 1, 90, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(20);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 3280, -4304 );\tDATA( 1, 180, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(21);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 2736, -4304 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(22);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_MEDIKIT, 2880, -4416 );\tDATA( 1, 0, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(23);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 144, -3136 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(24);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 144, -3328 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(25);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 96, -3392 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(26);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 96, -3072 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(27);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 432, -3040 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(28);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 432, -3424 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(29);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 32, -3232 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(30);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, -32, -3232 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(31);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 1312, -3520 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(32);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 736, -3520 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(33);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 752, -2992 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(34);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 976, -2912 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(35);\tDATA( 0, ENTITY_TYPE_BARREL, 0, 1312, -3264 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(36);\tDATA( 0, ENTITY_TYPE_BARREL, 0, 1152, -2912 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(37);\tDATA( 0, ENTITY_TYPE_BARREL, 0, 864, -3328 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(38);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 2672, -2752 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(39);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 2752, -2640 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(40);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 3232, -3040 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(41);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 2800, -3040 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(42);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 2912, -4176 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(43);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 3104, -4176 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(44);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 2720, -4352 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(45);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP, 3296, -4352 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(46);\tDATA( 0, ENTITY_TYPE_BARREL, 0, 2944, -4320 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(47);\tDATA( 0, ENTITY_TYPE_BARREL, 0, 3184, -4224 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(48);\tDATA( 0, ENTITY_TYPE_BARREL, 0, 2832, -4240 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(49);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 3184, -4176 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(50);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 2832, -4176 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(51);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 2736, -4192 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(52);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 3280, -4192 );\tDATA( 1, 180, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(53);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS, 3280, -4448 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(54);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2736, -4448 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(55);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3072, -4832 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(56);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2944, -4832 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(57);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3072, -4704 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(58);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2944, -4704 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(59);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_IMP, 3008, -4816 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(60);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_STIMPACK, 3072, -4768 );\tDATA( 1, 90, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(61);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_MEDIKIT, 2304, -4032 );\tDATA( 1, 90, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(62);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_GREENARMOR, -224, -3232 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(63);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, -288, -3232 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(64);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 1056, -3552 );\tDATA( 1, 90, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(65);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 1792, -2944 );\tDATA( 1, 270, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(66);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 3408, -3504 );\tDATA( 1, 135, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(67);\tDATA( 0, ENTITY_TYPE_DECORATION, ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS, 2784, -4160 );\tDATA( 1, 270, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(68);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 2272, -2432 );\tDATA( 1, 180, 15, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(69);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_TROOPER, 2272, -2352 );\tDATA( 1, 180, 14, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(70);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 2272, -2512 );\tDATA( 1, 180, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(71);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 2464, -2432 );\tDATA( 1, 180, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(72);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2224, -2320 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(73);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2224, -2544 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(74);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2288, -2544 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(75);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2288, -2320 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(76);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 1712, -2144 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(77);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 2240, -2256 );\tDATA( 1, 180, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(78);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_SHOTGUN, 3264, -3936 );\tDATA( 1, 270, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(79);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_MEDIKIT, 3232, -3808 );\tDATA( 1, 270, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(80);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 3216, -3888 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(81);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, -160, -3232 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(82);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 240, -3376 );\tDATA( 1, 135, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(83);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 240, -3088 );\tDATA( 1, 225, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(84);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 1696, -2688 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(85);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 1920, -2176 );\tDATA( 1, 270, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(86);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 2976, -3264 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(87);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 3008, -3520 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(88);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 3008, -3072 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(89);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 2816, -2688 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(90);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 2496, -3968 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(91);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 2256, -4064 );\tDATA( 1, 0, 4, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(92);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, 3072, -4256 );\tDATA( 1, 90, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(93);\tDATA( 0, ENTITY_TYPE_ENEMY, ENTITY_SUB_TYPE_ENEMY_SERGEANT, -192, -3296 );\tDATA( 1, 0, 12, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(94);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3616, -3392 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(95);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3712, -3264 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(96);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3472, -2960 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(97);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3376, -3024 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(98);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3568, -2992 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(99);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3616, -3088 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(100);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3664, -3168 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tBEGIN_ROW(101);\tDATA( 0, ENTITY_TYPE_ITEM, ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS, 3648, -3840 );\tDATA( 1, 0, 7, 0, 0 );\tEND_ROW();\n\t\tEND_BLOCK();\n        \n        fragColor = DATA_END();\n    }\n    \n    \/\/ Flashing sectors\n    if ( floor(fragCoord.x) == 0. ) \n    {\n        float fTestSectorId = floor(fragCoord.y);\n        if ( fTestSectorId == 31. || fTestSectorId == 65.)\n        {\n        \tfragColor.x = (hash(floor(iGlobalTime * 10.0)) > 0.2) ? 0.4 : 0.8;\n        }\n        else\n        if ( fTestSectorId == 36. || fTestSectorId == 37. )\n        {\n            fragColor.x = sin(iGlobalTime * 8.0) * 0.5 + 0.5;\n            fragColor.x = sqrt(fragColor.x);\n        }\n    }\n\n    \/\/ We need to modify the map data in this pass \n    \/\/ but as simply as possible due to constraints in the data shader.\n    \/\/ Doors are hardcoded to be the first n entities...\n    \n    \/\/ Output to the sector info texel\n    if ( floor(fragCoord.x) == 1. )\n    {\n        float fOutputSectorId = floor(fragCoord.y - 1.);\n        \n        #define ENTITY_DATA_YPOS 8.\n\n        for (int iDoorIndex = DOOR_START; iDoorIndex < DOOR_END; iDoorIndex++)\n        {\n            float fDoorIndex = float(iDoorIndex);\n            vec2 vAddress = vec2(fDoorIndex, ENTITY_DATA_YPOS);\n            vec4 vEntData0 = LoadVec4( iChannel1, vAddress );\n            \n            \/\/\n            vec3 vUnpacked0 = ByteUnpack3( vEntData0.x ) - 1.;\n            float fType = vUnpacked0.x;\n            float fSubType = vUnpacked0.y;\n            float fSectorId = vUnpacked0.z;\n            \n            \/\/ Validate it really is a door (could be blank on frame zero)\n            if ( fType == ENTITY_TYPE_DOOR )\n            {\n                if ( fSectorId == fOutputSectorId )\n                {\n                    \/\/ Update the ceiling height\n\t\t\t\t    \/\/ The entity target data[0].z field stores the height\n                    fragColor.y = vEntData0.z;\n                }                \n            }            \n            else if ( fType == ENTITY_TYPE_PLATFORM )\n            {\n                if ( fSectorId == fOutputSectorId )\n                {\n                    \/\/ Update the floor height\n\t\t\t\t    \/\/ The entity target data[0].z field stores the height\n                    fragColor.x = vEntData0.z;\n                }                \n            }\n        }        \n                \n    }\n}\n        \n","name":"Buf A","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":258,"channel":0}],"code":"\/\/ Sprite Sheet\n\n\/\/ Pickup \/ Enemy Sprites\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Util\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 Quantize( const in vec3 col, float fLevels )\n{\n\treturn floor( col * fLevels + 0.5 ) * (1.0 \/ fLevels);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    return vA.x * vB.y - vA.y * vB.x;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nfloat hash2D(vec2 p)\n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = Hash( fl );\n\tfloat h1 = Hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Raymarching\n\n\nstruct SceneResult\n{\n\tfloat fDist;\n\tfloat fObjectId;\n    vec3 vUVW;\n};\n\nSceneResult Scene_Union( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist < b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_Subtract( const in SceneResult a, const in SceneResult b )\n{\n    if ( -a.fDist < b.fDist )\n    {\n        return a;\n    }\n\n    SceneResult result;\n    result.fDist = -b.fDist;\n    result.fObjectId = b.fObjectId;\n    result.vUVW = b.vUVW;\n    return result;\n}\n\nSceneResult Scene_Intersection( const in SceneResult a, const in SceneResult b )\n{\n    if ( a.fDist > b.fDist )\n    {\n        return a;\n    }\n    return b;\n}\n    \nSceneResult Scene_GetDistance( const vec3 vPos );    \n\nvec3 Scene_GetNormal(const in vec3 vPos)\n{\n    const float fDelta = 0.01;\n    vec2 e = vec2( -1, 1 );\n    \n    vec3 vNormal = \n        Scene_GetDistance( vPos + e.yxx * fDelta ).fDist * e.yxx + \n        Scene_GetDistance( vPos + e.xxy * fDelta ).fDist * e.xxy + \n        Scene_GetDistance( vPos + e.xyx * fDelta ).fDist * e.xyx + \n        Scene_GetDistance( vPos + e.yyy * fDelta ).fDist * e.yyy;\n    \n    if ( dot( vNormal, vNormal ) < 0.00001 )\n    {\n        return vec3(0, 1, 0);\n    }\n    \n    return normalize( vNormal );\n}    \n\nSceneResult Scene_Trace( const in vec3 vRayOrigin, const in vec3 vRayDir, float maxDist )\n{\t\n    SceneResult result;\n    result.fDist = 0.0;\n    result.vUVW = vec3(0.0);\n    result.fObjectId = 0.0;\n    \n\tfloat t = 0.1;\n\tconst int kRaymarchMaxIter = 128;\n\tfor(int i=0; i<kRaymarchMaxIter; i++)\n\t{\t\t\n\t\tresult = Scene_GetDistance( vRayOrigin + vRayDir * t );\t\t\n        t += result.fDist;\n\n        if ( abs(result.fDist) < 0.001 )\n\t\t{\n\t\t\tbreak;\n\t\t}\t\t\n        if ( t > maxDist )\n        {\n            result.fObjectId = -1.0;\n\t        t = maxDist;\n            break;\n        }\n\t}\n    \n    result.fDist = t;\n\n    return result;\n}\n\n\nvec4 Raymarch_GetColor( vec3 vRayOrigin, vec3 vRayDir )\n{\n    vec4 vColor = vec4(0);\n    \n    return vColor;\n}\n\nstruct PoseLeg\n{\n    vec3 vHip;\n    vec3 vKnee;\n    vec3 vAnkle;\n    vec3 vToe;\n};\n\nstruct PoseArm\n{\n    vec3 vShoulder;\n    vec3 vElbow;\n    vec3 vWrist;\n    vec3 vHand;\n};\n\nstruct Pose\n{\n    PoseLeg leftLeg;\n    PoseLeg rightLeg;\n    PoseArm leftArm;\n    PoseArm rightArm;\n    \n    vec3 vHeadUp;\n    vec3 vHeadFd;\n};\n    \nstruct CharDef\n{\n    float fToe;\n    float fAnkle;\n    float fKnee;\n    float fHip;\n    \n    float fShoulder;\n    float fElbow;\n    float fWrist;\n    float fHand;\n    \n    float fHead1;\n    float fHead2;\n        \n    vec3 vCol;\n\n    vec3 vUniformColor0;\n    vec3 vUniformColor1;\n    vec3 vBootsColor;\n    vec3 vSkinColor;\n\n    vec3 vEyeColor;\n    vec3 vHairColor;\n};\n\nvoid CharDef_Default( inout CharDef charDef )\n{    \n    charDef.fToe = 2.5;\n    charDef.fAnkle = 3.0;\n    charDef.fKnee = 3.0;\n    charDef.fHip = 4.0;\n    \n    charDef.fShoulder = 3.0;\n    charDef.fElbow = 2.5;\n    charDef.fWrist = 2.4;\n    charDef.fHand = 2.5;\n    \n    charDef.fHead1 = 4.0;\n    charDef.fHead2 = 3.0;    \n    \n    charDef.vCol = vec3( 0.4, 1.0, 0.2 );\n    charDef.vEyeColor = vec3( 1, 0, 0 );\n    \n    charDef.vUniformColor0 = vec3( 0, 1, 0 );\n    charDef.vUniformColor1 = vec3( 0, 0, 1 );\n    charDef.vBootsColor = vec3(0.5);\n    charDef.vSkinColor = vec3(239, 163, 115) \/ 255.;    \n    charDef.vHairColor = vec3( 0 );\n}\n\nvoid CharDef_Imp( inout CharDef charDef )\n{    \n    CharDef_Default(charDef);\n    \n    float fExtra = 1.0;\n    \n    charDef.fToe += fExtra;\n    charDef.fAnkle += fExtra;\n    charDef.fKnee += fExtra;\n    charDef.fHip += fExtra;\n    \n    charDef.fShoulder += fExtra;\n    charDef.fElbow += fExtra;\n    charDef.fWrist += fExtra;\n    charDef.fHand += fExtra;\n    \n    charDef.fHead1 += 0.4;\n    charDef.fHead2 += 0.4;  \n    \n    charDef.vCol = vec3( 1.0, 0.5, 0.2 );\n    charDef.vUniformColor0 = charDef.vCol;\n\tcharDef.vUniformColor1 = charDef.vCol * 0.7;\n\tcharDef.vSkinColor = charDef.vCol * 1.2;\n    charDef.vBootsColor = charDef.vCol * 0.5;\n    charDef.vHairColor = charDef.vSkinColor;\n\n    charDef.vEyeColor = vec3( 1.0, 0.9, .1 ) * 10.;\n}\n\nvoid CharDef_Trooper( inout CharDef charDef )\n{    \n    CharDef_Default(charDef);\n\n    float fExtra = 0.1;\n    \n    charDef.fToe += fExtra;\n    charDef.fAnkle += fExtra;\n    charDef.fKnee += fExtra;\n    charDef.fHip += fExtra;\n    \n    charDef.fShoulder += fExtra;\n    charDef.fElbow += fExtra;\n    charDef.fWrist += fExtra;\n    charDef.fHand += fExtra;\n    \n    charDef.fHead1 = 3.5;\n    charDef.fHead2 = 3.2;      \n\n    charDef.vUniformColor0 = vec3( 87, 67, 44 ) \/ 255.;\n    charDef.vUniformColor1 = 1.5 * vec3( 90, 71, 49 ) \/ 255.;\n    charDef.vBootsColor = 1.5 * vec3(63,71,43) \/ 255.;\n\n    charDef.vHairColor = vec3( 67, 147, 55) \/ 255.;\n\n    charDef.fHead1 = 3.5;\n    charDef.fHead2 = 3.2;      \n}\n\nvoid CharDef_Sergeant( inout CharDef charDef )\n{    \n    CharDef_Default(charDef);\n\n    float fExtra = 0.2;\n    \n    charDef.fToe += fExtra;\n    charDef.fAnkle += fExtra;\n    charDef.fKnee += fExtra;\n    charDef.fHip += fExtra;\n    \n    charDef.fShoulder += fExtra;\n    charDef.fElbow += fExtra;\n    charDef.fWrist += fExtra;\n    charDef.fHand += fExtra;\n    \n    charDef.fHead1 = 3.5;\n    charDef.fHead2 = 3.2;      \n\n    charDef.vCol = vec3( 0.3, 0.3, 0.3 );\n\n    charDef.vUniformColor0 = vec3( 0.3, .3, .3 );\n    charDef.vUniformColor1 = vec3( 0.1, 0.1, 0.1 );\n    charDef.vBootsColor = vec3(0.5,0,0);\n\n    charDef.vHairColor = vec3( 179, 115, 71) \/ 255.;\n}\n\nstruct Scene\n{\n    float fCameraRotation;\n    vec3 vLightDir;\n    vec3 vLightColor;\n    vec3 vAmbientLight;\n    \n    bool bArmor;\n    bool bCharacter;\n    \n    CharDef charDef;\n    Pose pose;\n    \n    vec3 vWeaponStart;\n    vec3 vWeaponDir;\n    \n};\n    \nScene g_scene;\n\nvoid Pose_MirrorLeft( inout Pose pose )\n{\n    vec3 vMirror = vec3( -1.0, 1, 1 );\n    pose.rightLeg.vHip = pose.leftLeg.vHip * vMirror;\n    pose.rightLeg.vKnee = pose.leftLeg.vKnee * vMirror;\n    pose.rightLeg.vAnkle = pose.leftLeg.vAnkle * vMirror;\n    pose.rightLeg.vToe = pose.leftLeg.vToe * vMirror;\n\n    pose.rightArm.vShoulder = pose.leftArm.vShoulder * vMirror;\n    pose.rightArm.vElbow = pose.leftArm.vElbow * vMirror;\n    pose.rightArm.vWrist = pose.leftArm.vWrist * vMirror;\n    pose.rightArm.vHand = pose.leftArm.vHand * vMirror;\n}\n\n\nvoid Pose_Flip( inout Pose pose )\n{\n    vec3 vTemp;\n    vec3 vMirror = vec3( -1.0, 1, 1 );\n        \n\t#define SWAP_FLIP(X,Y) vTemp=X;X=Y*vMirror; Y=vTemp*vMirror;\n    \n    SWAP_FLIP(pose.rightLeg.vHip, pose.leftLeg.vHip);\n    SWAP_FLIP(pose.rightLeg.vKnee, pose.leftLeg.vKnee);\n    SWAP_FLIP(pose.rightLeg.vAnkle, pose.leftLeg.vAnkle);\n    SWAP_FLIP(pose.rightLeg.vToe, pose.leftLeg.vToe);\n\n    SWAP_FLIP(pose.rightArm.vShoulder, pose.leftArm.vShoulder);\n    SWAP_FLIP(pose.rightArm.vElbow, pose.leftArm.vElbow);\n    SWAP_FLIP(pose.rightArm.vWrist, pose.leftArm.vWrist);\n    SWAP_FLIP(pose.rightArm.vHand, pose.leftArm.vHand);\n    \n    pose.vHeadUp *= vMirror;\n    pose.vHeadFd *= vMirror;\n}\n\nvoid Pose_Clear( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 5.0, 14.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 5.0, 3.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 5.0, 3.0, -4.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 40.0, 0.0 );\n    pose.leftArm.vElbow = vec3( 8.0, 30.0, 1.0 );\n    pose.leftArm.vWrist = vec3( 9.0, 28.0, -4.0 );\n    pose.leftArm.vHand = vec3( 10.0, 28.0, -5.0 );\n    \n    Pose_MirrorLeft( pose );\n    \n    pose.vHeadUp = vec3(0, 1, 0);\n    pose.vHeadFd = vec3(0, 0, -1);\n}\n\nvoid Pose_Attack( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 5.0, 14.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 5.0, 3.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 5.0, 3.0, -2.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 40.0, -1.0 );\n    pose.leftArm.vElbow = vec3( 8.0, 34.0, -5.0 );\n    pose.leftArm.vWrist = vec3( 1.2, 37.0, -10.0 );\n    pose.leftArm.vHand = vec3( 0.0, 37.0, -10.0 );\n    \n    Pose_MirrorLeft( pose );\n        \n    pose.leftLeg.vHip.z = 3.0;\n    pose.leftLeg.vKnee.z = 5.0;\n    pose.leftLeg.vAnkle.z = 8.0;\n    pose.leftLeg.vAnkle.y = 4.0;\n    pose.leftLeg.vToe.z = 5.0;\n\n    pose.rightLeg.vHip.z = 1.0;\n    pose.rightLeg.vKnee.z = -5.0;\n    pose.rightLeg.vAnkle.z = -8.0;\n    pose.rightLeg.vToe.z = -7.0;\n\n    pose.leftArm.vShoulder.z += 1.;\n    pose.rightArm.vShoulder.z -= 1.;\n\n    pose.leftArm.vHand.y += 1.8;\n    pose.leftArm.vHand.z -= 3.;\n    pose.leftArm.vWrist.z -= 3.;\n    pose.rightArm.vHand.z += 1.;\n    pose.rightArm.vWrist.z += 1.;\n    \n    pose.vHeadUp = vec3(0, 1, -.5);\n    pose.vHeadFd = vec3(0, 0, -1);    \n}\n\nvoid Pose_Walk1( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 5.0, 14.0, -4.0 );\n    pose.leftLeg.vAnkle = vec3( 5.0, 8.0, 7.0 );\n    pose.leftLeg.vToe = vec3( 5.0, 4.0, 6.0 );\n\n    pose.rightLeg.vHip = vec3( -2.0, 24.0, 1.0 );\n    pose.rightLeg.vKnee = vec3( -5.0, 14.0, -2.0 );\n    pose.rightLeg.vAnkle = vec3( -5.0, 3.0, 2.0 );\n    pose.rightLeg.vToe = vec3( -5.0, 2.0, -2.0 );\n\n    pose.leftArm.vShoulder.z += 1.;\n    pose.rightArm.vShoulder.z -= 1.;\n    \n    pose.vHeadUp = vec3(0, 1, -.5);\n    pose.vHeadFd = vec3(0.1, 0, -1);    \n    \n    \n    pose.rightArm.vShoulder = vec3( -3.5, 40.0, 1.0 );\n    pose.rightArm.vElbow = vec3( -8.0, 30.0, -0.0 );\n    pose.rightArm.vWrist = vec3( -9.0, 24.0, -8.0 );\n    pose.rightArm.vHand = vec3( -9.0, 23.0, -9.0 );    \n\n    pose.leftArm.vShoulder = vec3( 3.5, 40.0, -1.0 );\n    pose.leftArm.vElbow = vec3( 8.0, 30.0, 2.0 );\n    pose.leftArm.vWrist = vec3( 9.0, 24.0, -4.0 );\n    pose.leftArm.vHand = vec3( 9.0, 23.0, -6.0 );\n}\n\nvoid Pose_Walk2( inout Pose pose )\n{\n    Pose_Walk1( pose );\n    Pose_Flip( pose );\n}\n\nvoid Pose_Pain( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 24.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 4.0, 15.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 4.0, 4.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 4.0, 3.0, -4.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 36.0, 6.0 );\n    pose.leftArm.vElbow = vec3(10.0, 27.0, 4.0 );\n    pose.leftArm.vWrist = vec3( 12.0, 25.0, -6.0 );\n    pose.leftArm.vHand = vec3( 12.5, 26.0, -6.0 );\n    \n    Pose_MirrorLeft( pose );\n\n    pose.rightLeg.vHip = vec3( -2.0, 24.0, 1.0 );\n    pose.rightLeg.vKnee = vec3( -4.0, 15.0, 2.0 );\n    pose.rightLeg.vAnkle = vec3( -4.0, 4.0, 3.0 );\n    pose.rightLeg.vToe = vec3( -4.0, 3.0, -2.0 );\n\n    \n    pose.vHeadUp = vec3(0, 1, .5);\n    pose.vHeadFd = vec3(0, .5, -1);\n    \n}\n\nvoid Pose_Die( inout Pose pose )\n{\n    pose.leftLeg.vHip = vec3( 2.0, 20.0, -3.0 );\n    pose.leftLeg.vKnee = vec3( 4.0, 12.0, -10.0 );\n    pose.leftLeg.vAnkle = vec3( 4.0, 4.0, -6.0 );\n    pose.leftLeg.vToe = vec3( 4.0, 3.0, -11.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, 28.0, 9.0 );\n    pose.leftArm.vElbow = vec3(10.0, 23.0, 4.0 );\n    pose.leftArm.vWrist = vec3( 9.0, 28.0, -6.0 );\n    pose.leftArm.vHand = vec3( 8.5, 29.0, -6.0 );\n    \n    Pose_MirrorLeft( pose );\n\n    pose.leftArm.vWrist.y -= 4.0;\n    pose.leftArm.vHand.y -= 5.0;\n    pose.leftArm.vHand.z -= 2.0;\n    \n    pose.rightArm.vHand.z -= 2.0;\n    \n    pose.rightLeg.vKnee.x -= 3.0;\n        \n    pose.vHeadUp = vec3(0, 1, .6);\n    pose.vHeadFd = vec3(0, .5, -1);\n    \n}\n\nvoid Pose_Weapon()\n{\n    \n    g_scene.vWeaponStart = g_scene.pose.rightArm.vHand + vec3( 0, 2, 0);\n    g_scene.vWeaponDir = normalize( g_scene.pose.leftArm.vHand - g_scene.vWeaponStart );\n}\n\nvoid Weapon_None()\n{\n\tg_scene.vWeaponStart = vec3(-10,-100,0);\n    g_scene.vWeaponDir = vec3(1, 0, 0);\n}\n\nvoid Weapon_DefaultPos()\n{\n\tg_scene.vWeaponStart = vec3(-10,6,0);\n    g_scene.vWeaponDir = vec3(1, 0, 0);\n    \n}\n\n\nvoid Pose_Dead( inout Pose pose )\n{\n    float dy = 4.0;\n    pose.leftLeg.vHip = vec3( 2.0, dy + 3.0, 1.0 );\n    pose.leftLeg.vKnee = vec3( 4.0, dy + 4.0, -2.0 );\n    pose.leftLeg.vAnkle = vec3( 15.0, dy + 7.0, -0.0 );\n    pose.leftLeg.vToe = vec3( 6.0, dy + 4.0, -2.0 );\n\n    pose.leftArm.vShoulder = vec3( 3.5, dy + 5.0, 0.0 );\n    pose.leftArm.vElbow = vec3( 4.0, dy + 4.0, 1.0 );\n    pose.leftArm.vWrist = vec3( 3.0, dy + 6.0, -4.0 );\n    pose.leftArm.vHand = vec3( 5.0, dy + 4.0, -5.0 );\n    \n    Pose_MirrorLeft( pose );\n\n    pose.leftArm.vElbow.y += 5.;\n    pose.leftLeg.vKnee.y += 4.;\n    \n    pose.vHeadUp = vec3(1, 0.3, 0);\n    pose.vHeadFd = vec3(0, 0, -1);\n    \n    Weapon_None();\n}\n\nvoid Scene_Clear()\n{\n    g_scene.vLightDir = normalize( vec3(0, 1, -0.3) );\n    g_scene.vLightColor = vec3(1, 1, 1);\n    g_scene.vAmbientLight = vec3(0.4);\n    \n    g_scene.bCharacter = false;\n    g_scene.bArmor = false;\n        \n    g_scene.fCameraRotation = 0.0;\n    \n\t\n    Weapon_None();\n    \n    Pose_Clear( g_scene.pose );\n    \n    CharDef_Default( g_scene.charDef );\n}\n\n\n\nconst float kMaxTraceDist = 1000.0;\n\n#define MAT_BG 0.0\n#define MAT_CHARACTER 1.0\n#define MAT_WHITE 2.0\n#define MAT_GREY 3.0\n#define MAT_SHOTGUN 4.0\n#define MAT_WOOD 5.0\n#define MAT_HEAD 6.0\n#define MAT_EYE 7.0\n\nvec2 Segment_Internal( vec3 vPos, vec3 vP0, vec3 vP1 )\n{\n\tvec3 pa = vPos - vP0;\n\tvec3 ba = vP1 - vP0;\n\tfloat h = clamp( dot(pa,ba)\/dot(ba,ba), 0.0, 1.0 );\n\t\n\treturn vec2( length( pa - ba*h ), h );\n}\n\nfloat Segment( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    vec2 vC = Segment_Internal( vPos, vP0, vP1 );\n    \n    return vC.x - mix(r0, r1, vC.y);\n}\n\nvec3 Segment3( vec3 vPos, vec3 vP0, vec3 vP1, float r0, float r1 )\n{\n    \/\/return vec3( Segment( vPos, vP0, vP1, r0, r1 ) );\n    vec3 vDir = normalize(vP1 - vP0);\n    float len = length( vP1 - vP0 );\n    float t = dot( vDir, vPos - vP0 ) \/ len;\n    float clamped_t = clamp( t, 0.0, 1.0 );\n\n    vec3 vClosestOnLine = mix( vP0, vP1, clamped_t);\n    vec3 vDirToClosest = vPos - vClosestOnLine;\n    float fClosestDist = length( vDirToClosest );\n    \n    float d = fClosestDist - mix(r0, r1, t);\n\n    vec3 fd = vec3(1,0,0);\n    \n    return vec3( d, t, dot( fd, normalize(vDirToClosest))  );\n}\n\n\n\/*\nfloat Limb( vec3 vPos, vec3 vP0, vec3 vP1, vec3 vPerpDir, float l1, float l2, float rStart, float rMid, float rEnd )\n{\n    vec3 vStartToEnd = vP1 - vP0;\n    vec3 vDir = normalize( vStartToEnd );\n    \n    vec3 vTemp = cross( vDir, vPerpDir);\n    vec3 vPerDir = normalize( cross( vDir, vTemp) );\n    \n    float d = length( vStartToEnd );\n    \n    float d1 = (l1 * l1 - l2 *  l2 + d * d) \/ ( 2.0 * d );\n    float d2 = d - d1;\n    \n    float h = sqrt( l1 * l1 - d1 * d1 );\n\n    vec3 vMidPoint = vP0 + vDir * d1 + vPerpDir * h;\n    \n    return LimbSegments();\n    float fSD1 = Segment( vPos, vP0, vMidPoint, rStart, rMid );\n    float fSD2 = Segment( vPos, vMidPoint, vP1, rMid, rEnd );\n\n    return min( fSD1, fSD2 );\n}\n*\/\nfloat SmoothMin( float a, float b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b-a)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 SmoothMin3( vec3 a, vec3 b, float k )\n{\n\t\/\/return min(a,b);\n\t\n\t\n    \/\/float k = 0.06;\n\tfloat h = clamp( 0.5 + 0.5*(b.x-a.x)\/k, 0.0, 1.0 );\n\treturn mix( b, a, h ) - k*h*(1.0-h);\n}\n\nvec3 LimbCombine( vec3 fA, vec3 fB )\n{\n    return SmoothMin3( fA, fB, 0.5);\n    \/\/return min( fA, fB );\n}\n\nvec3 Chain( vec3 vPos, vec4 vA, vec4 vB, vec4 vC, vec4 vD, vec3 vWeights )\n{\n    vec3 vD1 = Segment3( vPos, vA.xyz, vB.xyz, vA.w, vB.w );\n    vec3 vD2 = Segment3( vPos, vB.xyz, vC.xyz, vB.w, vC.w );\n    vec3 vD3 = Segment3( vPos, vC.xyz, vD.xyz, vC.w, vD.w );\n    \n    vD1.y = vD1.y * vWeights.x;\n    vD2.y = vWeights.x + vD2.y * vWeights.y;\n    vD3.y = vWeights.x + vWeights.y + vD3.y * vWeights.z;\n    \n    vec3 vResult = LimbCombine( vD1, vD2 );    \n    vResult = LimbCombine( vResult, vD3 );    \n    return vResult;\n}\n\nvec3 LegDist( vec3 vPos, PoseLeg leg )\n{    \n    return Chain( \n        vPos,\n        vec4(leg.vToe, g_scene.charDef.fToe),\n        vec4(leg.vAnkle, g_scene.charDef.fAnkle),\n        vec4(leg.vKnee, g_scene.charDef.fKnee), \n        vec4(leg.vHip, g_scene.charDef.fHip), \n        vec3(0.1, 0.4, 0.5 )\n    );\n}\n\nvec3 ArmDist( vec3 vPos, PoseArm arm )\n{\n    return Chain( \n        vPos,\n        vec4(arm.vShoulder, g_scene.charDef.fShoulder), \n        vec4(arm.vElbow, g_scene.charDef.fElbow), \n        vec4(arm.vWrist, g_scene.charDef.fWrist),\n        vec4(arm.vHand, g_scene.charDef.fHand),\n        vec3(0.5, 0.4, 0.1 )\n    );    \n}\n\n\nvec3 TorsoDistance( vec3 vPos, vec3 vA, vec3 vB, vec3 vC, vec3 vD, float fSizeTop, float fSizeBase )\n{    \n    vec3 vMidBase = (vA + vB) * 0.5;\n    vec3 vMidTop = (vC + vD) * 0.5;\n    \n    vec3 vAxis = vMidTop - vMidBase;\n    float fAxisLen = length( vAxis );\n    vec3 vAxisDir = normalize( vAxis );\n    \n    float fProjection = dot( vAxisDir, vPos - vMidBase );\n    \n    float fNormProj = fProjection \/ fAxisLen;\n    float fNormProjClamped = clamp( fNormProj, 0., 1. );\n    \n    \/\/vec3 vProjected = vMidBase + vAxisDir * clamp( fProjection, 0., fAxisLen );\n    \n    vec3 vSpinePos = mix( vMidBase, vMidTop, fNormProjClamped );\n\n    vec3 vPerpBase = (vB - vA) * 0.5;\n    vec3 vPerpTop = (vD - vC) * 0.5;\n    \n    vec3 vPerp = mix( vPerpBase, vPerpTop, fNormProj );\n    vec3 vPerpDir = normalize( vPerp );\n    \n    float fSideLen = length( vPerp );\n    \n    float fPerpProj = dot( vPerpDir, vPos - vSpinePos );\n    float fPerpProjClamped = clamp( fPerpProj, -fSideLen, fSideLen );\n    \n\tvec3 vBackPlanePos = vSpinePos + vPerpDir * fPerpProjClamped;\n    \n    float fSize = mix( fSizeBase, fSizeTop, fNormProjClamped );\n    \n    \/\/float fNormPerpProj = fPerpProj \/ length(vPerp);\n    \/\/float fNormPerpProjClamped = clamp( fNormPerpProj, -1., 1.);\n    \n    \/\/vec3 vSidePos = vSpinePos + vPerp;\n    \/\/vec3 vBackPlanePos = mix( vSpinePos, vSidePos, fNormPerpProjClamped );\n    \n    \n    float fDistance = length(vPos - vBackPlanePos) - fSize;\n    \n    return vec3( fDistance, fNormProj, fPerpProj \/ (fSideLen * 2.0) + 0.5);\n}\n\nfloat BodyCombine( float fA, float fB )\n{\n    return SmoothMin( fA, fB, 0.5);\n    \/\/return min( fA, fB );\n}\nvec3 BodyCombine3( vec3 fA, vec3 fB )\n{\n    return SmoothMin3( fA, fB, 0.5);\n    \/\/return min( fA, fB );\n}\n\nSceneResult Character_GetDistance( vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_BG, vec3(0.0) );\n\n\n    vec3 vLeftLeg = LegDist( vPos, g_scene.pose.leftLeg );\n    vec3 vRightLeg = LegDist( vPos, g_scene.pose.rightLeg );\n    vec3 vLeftArm = ArmDist( vPos, g_scene.pose.leftArm );\n    vec3 vRightArm = ArmDist( vPos, g_scene.pose.rightArm );\n    vec3 vTorsoDist = TorsoDistance( \n        vPos,\n        g_scene.pose.leftLeg.vHip, \n        g_scene.pose.rightLeg.vHip,\n        g_scene.pose.leftArm.vShoulder,\n        g_scene.pose.rightArm.vShoulder,\n    \tg_scene.charDef.fShoulder, g_scene.charDef.fHip);\n        \n    vTorsoDist.y += 1.0;\n    vLeftArm.y += 2.0;\n    vRightArm.y += 2.0;            \n    vLeftArm.z += 1.0;\n    vLeftLeg.z += 1.0;\n        \n    vec3 vLimbDist = vec3(10000.0);\n    vLimbDist = BodyCombine3( vLimbDist, vLeftLeg );\n    vLimbDist = BodyCombine3( vLimbDist, vRightLeg );\n    vLimbDist = BodyCombine3( vLimbDist, vLeftArm );\n    vLimbDist = BodyCombine3( vLimbDist, vRightArm );        \n    vec3 vCharacterDist = BodyCombine3( vLimbDist, vTorsoDist );\n\n    \/\/vCharacterDist.x -= fbm( vLimbDist.xy * 10., 0.9 ) * 2.0;\n    \n    float fNeckSize = 1.0;\n    float fNeckLen = 3.0;\n\n    vec3 vNeckBase = (g_scene.pose.leftArm.vShoulder + g_scene.pose.rightArm.vShoulder) * 0.5;\n    vec3 vNeckTop = vNeckBase + g_scene.pose.vHeadUp * fNeckLen;\n    vec3 vNeckDist = Segment3( vPos, vNeckBase, vNeckTop, fNeckSize, fNeckSize );\n    \n    float fHead1 = g_scene.charDef.fHead1;\n    float fHead2 = g_scene.charDef.fHead2;\n    float fHeadTop = 6.0;\n    float fHeadChin = 2.0;\n    \n    vec3 vHeadBase = vNeckBase + g_scene.pose.vHeadUp * ( fHeadChin + fHead2);\n    vec3 vHead2 = vHeadBase  + g_scene.pose.vHeadFd * (fHead2 * .5);\n    vec3 vHead1 = vHeadBase + g_scene.pose.vHeadUp * (fHeadTop - fHead1);\n    \n    vec3 vHeadDist = Segment3( vPos, vHead1, vHead2, fHead1, fHead2 );\n    vHeadDist = SmoothMin3( vHeadDist, vNeckDist, 0.5 );\n\n    vec3 vNosePos = vHead1 + g_scene.pose.vHeadFd * fHead1 * 1.2 - g_scene.pose.vHeadUp * 1.5;\n    float fNoseDist = length( vPos - vNosePos ) - 1.;\n    vHeadDist.x = min( vHeadDist.x, fNoseDist ); \/\/ keep material\n\n\n    vec3 vEyePerp = normalize( cross(g_scene.pose.vHeadFd, g_scene.pose.vHeadUp) );\n\n    vec3 vEyePos1 = vHead1 + g_scene.pose.vHeadFd * fHead1 + vEyePerp * 1.5;\n    float fEyeDist1 = length( vPos - vEyePos1 ) - 1.;\n\n    vec3 vEyePos2 = vHead1 + g_scene.pose.vHeadFd * fHead1 - vEyePerp * 1.5;\n    float fEyeDist2 = length( vPos - vEyePos2 ) - 1.;\n    \n    float fEyeDist = min( fEyeDist1, fEyeDist2 );\n        \n    vHeadDist.x = max( vHeadDist.x, -(fEyeDist - 0.2) );\n    \n    \n    \/\/vCharacterDist = BodyCombine3( vCharacterDist, vHeadDist );\n    result = Scene_Union( result, SceneResult( vHeadDist.x, MAT_HEAD, vHeadDist.yzz ) );    \n    \n    \n    \n    result = Scene_Union( result, SceneResult( fEyeDist, MAT_EYE, g_scene.charDef.vCol ) );    \n        \n    result = Scene_Union( result, SceneResult( vCharacterDist.x, MAT_CHARACTER, vCharacterDist.yzz ) );    \n\n         \n    return result;\n}\n\n\nSceneResult Armor_GetDistance( vec3 vPos )\n{\n    vPos.x = abs(vPos.x);\n\n    vPos.y += 1.;\n    \n    float fScale = 1.4;\n    vPos \/= fScale;\n    \n    float fDist1 = Segment( vPos, vec3(0,10,2), vec3(6, 9, 0), 4., 4. );\n    float fDist2 = Segment( vPos, vec3(0,10,0), vec3(0, 5, 0), 5., 6. );\n    float fDist = SmoothMin( fDist1, fDist2, 1.5 );\n\n    float fDistHole1 = Segment( vPos, vec3(0,12,-1), vec3(0, -2, -0.5), 3.5, 4.5 );    \n    float fDistHole2 = Segment( vPos, vec3(0,10,2), vec3(8, 8, -1), 3.0, 3.0 );\n    float fDistHole = SmoothMin( fDistHole1, fDistHole2, 1.5 );\n\n    SceneResult result = SceneResult( fDist, MAT_WHITE, vec3(0.0) );\n        \n    result = Scene_Subtract( result, SceneResult( fDistHole, MAT_GREY, vec3(0.0) ));\n    \n    \/\/fDist = -SmoothMin( -fDist, fDistHole, 1.0 );\n    \n    fDist *= fScale;\n    \n\n    return result;\n}\n\n\nSceneResult Scene_GetDistance( const vec3 vPos )\n{\n    SceneResult result = SceneResult( kMaxTraceDist, MAT_BG, vec3(0.0) );\n        \n\tif ( g_scene.bCharacter )\n    {\n\t    result = Scene_Union( result, Character_GetDistance( vPos ) );\n    }\n\n    {\n\/*        float fDist = Segment( vPos, vec3(-10,10,0), vec3(13, 10, 0), 1., 1. );\n        result = Scene_Union( result, SceneResult( fDist, MAT_SHOTGUN, g_scene.charDef.vCol ) );    \n\n        float fDist2 = Segment( vPos, vec3(-12,6,0), vec3(-4, 10, 0), 2., 1. );\n        result = Scene_Union( result, SceneResult( fDist2, MAT_WOOD, g_scene.charDef.vCol ) );    *\/\n        \n        vec3 vStart = g_scene.vWeaponStart;\n        vec3 vDir = g_scene.vWeaponDir;\n        float fDist = Segment( vPos, vStart, vStart + vDir * 23.0, 1., 1. );\n        result = Scene_Union( result, SceneResult( fDist, MAT_SHOTGUN, g_scene.charDef.vCol ) );    \n\n        float fDist2 = Segment( vPos, vStart + vDir * -2. + vec3(0,-4,0), vStart + vDir * 6., 2., 1. );\n        result = Scene_Union( result, SceneResult( fDist2, MAT_WOOD, g_scene.charDef.vCol ) );\n    }\n    \n    if ( g_scene.bArmor )\n    {        \n\t    result = Scene_Union( result, Armor_GetDistance( vPos ) );\n    }\n    \n    return result;\n}\n\n\n\n\nvec4 Raymarch_Sprite( vec2 fragCoord, vec4 vSpriteInfo )\n{\n    vec4 vResult = vec4( 0 );\n    \n    vec2 vSpritePos = fragCoord - vSpriteInfo.xy;\n    float fSpriteX = vSpritePos.x - vSpriteInfo.z * 0.5;\n    \n    float fRotation = g_scene.fCameraRotation;\n    \n    \/\/fRotation += iGlobalTime;\n    \n    vec3 vCameraPos;\n    vCameraPos.x = cos(fRotation) * fSpriteX;\n    vCameraPos.y = vSpritePos.y;\n    vCameraPos.z = sin(fRotation) * fSpriteX;\n    \n    vec3 vCameraDir = vec3(-sin(fRotation), 0, cos(fRotation));\n    \n    vCameraPos -= vCameraDir * 200.0;\n\n\tSceneResult sceneResult = Scene_Trace( vCameraPos, vCameraDir, 1000.0 );\n    \n    if ( sceneResult.fDist > 400.0 )\n    {\n        return vResult;\n    }\n\n    vec3 vHitPos = vCameraPos + vCameraDir * sceneResult.fDist;\n    \n    vec3 vNormal = Scene_GetNormal( vHitPos );\n    \n    float fShade = max( 0.0, dot( vNormal, g_scene.vLightDir ) );\n    \n    float fSpecIntensity = 1.0;\n    \n    float fFBM1 = fbm( sceneResult.vUVW.xy * 30.0 * vec2(1.0, 0.4), 0.2 );    \n    float fFBM2 = fbm( sceneResult.vUVW.xy * 30.0 * vec2(1.0, 0.4) + 5.0, 0.5 );\n    vec3 vDiffuseCol = vec3(1.);\n    if ( sceneResult.fObjectId == MAT_CHARACTER )\n    {\n        float fUniformBlend = smoothstep( 0.5, 0.6, fFBM1 );\n        \n        vDiffuseCol = mix( g_scene.charDef.vUniformColor0, \n                          g_scene.charDef.vUniformColor1, \n                          fUniformBlend );\n        \n        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vSkinColor, step(2.2,sceneResult.vUVW.x) );\n\n        float fBootBlend = step(sceneResult.vUVW.x, .4);\n        \n        fBootBlend = max( fBootBlend, step( abs(2.5 - sceneResult.vUVW.x), 0.2 ) ); \/\/ arm thing\n        \n        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vBootsColor, fBootBlend );\n                \n        float fGoreBlend = smoothstep( 0.6, 0.7, fFBM2 );\n        fGoreBlend = max( fGoreBlend, step(2.9,sceneResult.vUVW.x) ); \/\/ bloody hands\n        \n        vDiffuseCol = mix( vDiffuseCol, \n                          vec3(1,0,0), \n                          fGoreBlend );\n        \n        \/\/vDiffuseCol = fract(sceneResult.vUVW);\/\/g_scene.charDef.vCol;\n        \/\/vDiffuseCol = sceneResult.vUVW.xxx \/ 5.0;\/\/g_scene.charDef.vCol;\n    }\n    else if ( sceneResult.fObjectId == MAT_SHOTGUN )\n    {\n        vDiffuseCol = vec3( 0.2 );\n    }\n    else if ( sceneResult.fObjectId == MAT_WOOD )\n    {\n        vDiffuseCol = vec3( 0.4, 0.2, .1 );\n    }\n    else if ( sceneResult.fObjectId == MAT_HEAD )\n    {\n        vDiffuseCol = g_scene.charDef.vSkinColor;\n        float fHairBlend = step( sceneResult.vUVW.x + fFBM1 * 0.5, 0.1 );\n        vDiffuseCol = mix( vDiffuseCol, g_scene.charDef.vHairColor, fHairBlend );\n    }\n    else if ( sceneResult.fObjectId == MAT_EYE )\n    {\n        vDiffuseCol = g_scene.charDef.vEyeColor;\n    }\n    else if ( sceneResult.fObjectId == MAT_GREY )\n    {\n        vDiffuseCol = vec3( 0.2 );\n        fSpecIntensity = 0.1;\n    }\n    \n    vec3 vDiffuseLight = g_scene.vAmbientLight + fShade * g_scene.vLightColor;\n    vResult.rgb = vDiffuseCol * vDiffuseLight;\n    \n    vec3 vRefl = reflect( vec3(0, 0, 1), vNormal );\n    float fDot = max(0.0, dot( vRefl, g_scene.vLightDir )) * fShade;\n    float fSpec = pow( fDot, 5.0 );\n    vResult.rgb += fSpec * fSpecIntensity;\n    \n    vResult.rgb = 1.0 - exp2( vResult.rgb * -2.0 );\n    vResult.rgb = pow( vResult.rgb, vec3(1.0 \/ 1.5) );\n    \n    vResult.a = 1.0;\n    \n    return vResult;\n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nbool MaskBarrel(vec2 vTexCoord)\n{\n\tvec2 vSize = vec2(23.0, 32.0);\n\t\n\tvTexCoord = floor(vTexCoord);\n\t\n\t\/\/ remove corner pixels\n\tvec2 vWrapCoord = fract((vTexCoord + vec2(2.0, 1.0) ) \/ vSize) * vSize;\n\t\n\treturn ( (vWrapCoord.x >= 4.0) || (vWrapCoord.y >= 2.0) );\n}\n\nvec4 TexBar1A( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    if ( any( lessThan( vTexCoord, vec2(0) ) ) ) return vec4(0);\n    if ( any( greaterThan( vTexCoord, vec2(22,32) ) ) ) return vec4(0);\n    vTexCoord.y = 31. - vTexCoord.y;\n\tvec3 col = vec3(123.0, 127.0, 99.0) \/ 255.0;\n\t\n\tfloat fBrownStreakBlend = smoothstep( 2.0, 1.0, abs(vTexCoord.x - 3.5));\n\tcol = mix(col, vec3(0.724, 0.736, 0.438), fBrownStreakBlend);\n\t\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 3.0) && (vTexCoord.x < 18.0) )\n\t{\n\t\tcol = col * clamp(((vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\telse\n\t{\n\t\tcol = col * clamp((1.0 - (vTexCoord.x \/ 18.0)), 0.0, 1.0);\t\t\n\t}\n\t\n\tfloat fNukageBlend = 0.0;\n\tif( (vTexCoord.y == 1.0) && (vTexCoord.x > 8.0) && (vTexCoord.x < 14.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tif( (vTexCoord.y == 2.0) && (vTexCoord.x > 2.0) && (vTexCoord.x < 20.0) )\n\t{\n\t\tfNukageBlend = 1.0;\n\t}\t\n\tcol = mix(col, vec3(0.172, 0.560, 0.144) * fRandom, fNukageBlend);\n\t\n\t\n\tif(vTexCoord.x < 1.0)\n\t{\n\t\tcol += 0.1;\n\t}\n\t\n\tfloat fBlend = clamp(((vTexCoord.x - 20.0) \/ 3.0), 0.0, 1.0);\n\tcol += fBlend * 0.2;\n\t\n\tfloat fBumpY = 8.0;\n\tif(vTexCoord.y > 14.0) fBumpY += 9.0;\n\tif(vTexCoord.y > 23.0) fBumpY += 8.0;\n\n\tvec4 vBump = SmoothBump( vTexCoord, vec2(2.0, fBumpY), vec2(23.0 - 2.0, fBumpY), normalize(vec2(-0.2, 1.0)), 1.25 );\t\n\tcol += vBump.x * 0.2;\n\n\t\/\/ rim highlights\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(17.0, 0.0)) \/ vec2(8.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(20.0, 1.0)) \/ vec2(4.0, 1.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t{\n\t\tvec2 vOffset = (vTexCoord - vec2(3.0, 2.0)) \/ vec2(4.0, 2.0);\n\t\tcol += clamp(1.0 - dot(vOffset, vOffset), 0.0, 1.0) * 0.2;\n\t}\t\n\t\n\tcol *= 0.5 + fRandom * 0.5;\n\t\n    vec4 vResult;\n    vResult.rgb = col;\n    vResult.a = MaskBarrel( vTexCoord ) ? 1. : 0.;\n    \n\treturn vResult;\n}\n\n\nvec4 CosApprox( vec4 x )\n{\n\tx = abs(fract(x * (0.5))*2.0 - 1.0);\n\tvec4 x2 = x*x;\n\treturn( ( x2 * 3.0) - ( 2.0 * x2*x) );\n}\n\nbool MaskCorpseSprite(vec2 vTexCoord)\n{\n\t\/\/vTexCoord = floor(vTexCoord);\n    \n    vec2 vUV = vTexCoord.xy \/ vec2(48.0, 22.0);\n    vec2 vOffset = vUV;\n    vOffset = vOffset * 2.0 -vec2(1.0, 0.6);\n    float fDist = dot(vOffset, vOffset);\n    fDist += dot(CosApprox(vTexCoord.xyxy * vec4(0.55, 0.41, 0.25, 0.1)), vec4(0.2 * -vOffset.y));\n\treturn fDist < 0.4;\n}\n\nvec4 TexPlayW( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 col = mix(vec3(190.0, 10.0, 10.0), vec3(50, 16.0, 16.0 ), fRandom * vTexCoord.y\/18.0) \/ 255.0;\n    \n    vec4 vResult = vec4(0);\n    vResult.rgb = col;\n    vResult.a = MaskCorpseSprite( vTexCoord ) ? 1. : 0.;\n    \n\treturn vResult;\n}\n\nvec4 TexFireball( vec2 vTexCoord, float fRandom, float fHRandom, float fSize, float fType )\n{\n    float fLen = length( vTexCoord - vec2(fSize) ) \/ fSize;\n    \n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = mix( vec3( 1., 0.5, 0.4), vec3(0.6, 0.2, 0.05), fLen );\/\/vec3(sin(fLen * 10.0) * 0.5 + 0.5,0,1);\n    if ( fType == 0. )\n    {\n    \tvResult.rgb += vec3( 1., 0.3, 0.1) * ( exp( fLen * -3.0)) * 3.;\n    }\n    else\n    {\n        fLen += fRandom - 0.25;\n    }\n    vResult.rgb *= fRandom * 0.5 + 0.5;\n\n    if ( fLen < 1.0 )\n    {\n        vResult.a = 1.;\n    }\n    \n    return vResult;\n}\n\nvec4 TexHealthBonus( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    float fLen = length( vTexCoord - vec2(8.0, 6.0) ) \/ 5.5;\n    \n    vec4 vResult = vec4(0);\n    \n    vec3 vCol = vec3(0,0,1);\n    if ( all( greaterThan( vTexCoord, vec2( 6, 13) ) ) && all( lessThan( vTexCoord, vec2(10, 16 ) ) ) )\n\t{\n        vCol = vec3(1., .5, .2) * 2.;\n\t}\n    \n    float fShade = clamp( vTexCoord.y \/ 10.0, 0.0, 1.0);\n    vResult.rgb = vCol * fShade * fRandom;\n    if ( fLen < 1.0 )\n    {\n        vResult.a = 1.;\n    }\n    \n    if ( all( greaterThan( vTexCoord, vec2( 6, 4) ) ) && all( lessThan( vTexCoord, vec2(10, 16 ) ) ) )\n\t{\n        vResult.a = 1.;\n\t}\n    \n    \n    return vResult;\n}\n    \nvec4 TexArmorBonus( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec2 vXY = vTexCoord - vec2(7.5,7.0);\n\n    vec4 vResult = vec4(0);\n    \n    float fRad = 8.0;\n    if ( vXY.y < 0.0 )\n    {\n        vXY.y += 1.0;\n        vXY.x *= 0.9;\n    }\n\n    vec3 vCol = mix( vec3(75), vec3(95, 67, 35), step(0.55, fRandom)) \/ 255.;\n    \n    \n    float fLen = length( vXY );\n    \n    if ( fLen < fRad )\n    {\n    \tvec3 vNormal = normalize( vec3( vXY, sqrt( fRad * fRad - fLen * fLen) ) );\n        vec3 vLight = normalize( vec3( 0.4, 0.3, 3.0 ) );\n        \n                \n        float fShade = max(0.0, dot( vLight, vNormal ) );\n        \n        float fHighlight = pow(fShade, 50.0) * 0.2;\n        \n        fShade = fShade * 0.8 + 0.2;\n        \n        \n        vResult = vec4( vCol * fShade + fHighlight, 1 );\n    }\n    \n    if ( (vTexCoord.x == 6. || vTexCoord.x == 9.) && ( vTexCoord.y >= 0. && vTexCoord.y < 5.) )\n    {\n        vResult.rgb *= 0.5;\n    }\n    else\n    if ( (vTexCoord.x >= 6. && vTexCoord.x <= 9.) && vTexCoord.y == 0. )\n    {\n        vResult.rgb *= 0.5;\n    }\n    \n    float fMirrorX = 7.5 - abs( vTexCoord.x - 7.5 );\n    vec2 vMirror = vec2( fMirrorX, vTexCoord.y );\n    \n    bool bEye = false;\n    if( all( greaterThanEqual( vMirror, vec2(2,4) ) ) &&\n        all( lessThanEqual( vMirror, vec2(5,5) ) ))\n    {\n        bEye = true; \n    }\n\n    if( all( greaterThanEqual( vMirror, vec2(4,2) ) ) &&\n        all( lessThanEqual( vMirror, vec2(5,3) ) ))\n    {\n        bEye = true; \n    }\n    \n    if( bEye )\n\t{\n        float fEyeShade = clamp( 1.0 - (10. -vMirror.x - vMirror.y) \/ 8.0, 0.0, 1.0);\n\t\tvResult.rgb = fEyeShade * vec3(83,175,71) \/ 255.;\n\t}\n\n    if( all( greaterThanEqual( vMirror, vec2(4,0) ) ) &&\n        all( lessThanEqual( vMirror, vec2(5,1) ) ))\n    {\n        vResult = vec4(0.0);\n    }\n    \n    \n    \/*\n\n    vec3 vCol = vec3(0,1,.5);\n    if ( all( greaterThan( vTexCoord, vec2(4, 6) ) ) && all( lessThan( vTexCoord, vec2(8, 9 ) ) ) )\n\t{\n        vCol *= 0.5;\n\t}\n    if ( all( greaterThan( vTexCoord, vec2(9, 6) ) ) && all( lessThan( vTexCoord, vec2(13, 9 ) ) ) )\n\t{\n        vCol *= 0.5;\n\t}\n    \n    float fShade = clamp( vTexCoord.y \/ 10.0, 0.0, 1.0);\n    vResult.rgb = vCol * fShade * fRandom;\n    if ( fLen < 1.0 )\n    {\n        vResult.a = 1.;\n    }\n    \n    if ( length( vTexCoord ) < 5.5 )\n    {\n        vResult.a = 0.;\n    }\n    if ( length( vTexCoord - vec2(16,0)) < 5.5 )\n    {\n        vResult.a = 0.;\n    }\n\t*\/\n    \n    return vResult;\n}\n\nvec4 TexWallImpact( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    float fLen = length( vTexCoord - vec2(3.0) ) \/ 3.0;\n    fLen = sqrt(fLen);\n    fLen = max( 0.0, fLen * 1.3 - 0.3 );\n    vResult.rgb = mix( vec3(1.,1.,.8), vec3(0.4,0.2,0.0), fLen * fLen);\n    vResult.rgb *= 1.5;\n    \n\n    vResult.a = step(fLen, 1.0);\n    \n    return vResult;  \n}\n\nvec4 TexBulletSmokeImpact( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = vec3(1.0,1.0,1.0) * fRandom;\n    \n    float fLen = length( (vTexCoord - vec2(4.0, 8.0)) \/ vec2(6.0, 10.0) ) ;\n\n    fRandom = 1.0 - fRandom;\n    \n    vResult.a = step(fLen + fRandom * fRandom * 2.0, 1.0);\n    \n    return vResult;    \n}\n\nvec4 TexFleshImpact( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = vec3(1.0,0.0,0.0) * fRandom;\n    \n    float fLen = length( vTexCoord - vec2(4.0) ) \/ 4.2;\n\n    vResult.a = step(fLen + fRandom * fRandom * 1.5, 1.0);\n    \n    return vResult;  \n}\n    \nvec4 TexEnemyPlaceholder( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n    \n    vResult.rgb = vec3(0,0.2,0);\n    if ( (length( vTexCoord - vec2(16.0, 50.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n    if ( (length( vTexCoord - vec2(16.0, 30.) ) < 12.0) )\n    {\n        vResult.a = 1.;\n    }\n    \n    if ( (length( vTexCoord - vec2(9.0, 5.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n\n    if ( (length( vTexCoord - vec2(31. -9.0, 5.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n\n    if ( (length( vTexCoord - vec2(9.0, 15.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n\n    if ( (length( vTexCoord - vec2(31. -9.0, 15.) ) < 5.0) )\n    {\n        vResult.a = 1.;\n    }\n        \n    return vResult;\n}\n\nvec4 TexShotgunItem( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(1);\n    \n    vResult.rgb = vec3(0.3) * fRandom;\n \n    return vResult;    \n}\n\nvec4 TexPlaceholder( vec2 vTexCoord, float fRandom, float fHRandom, vec3 vCol )\n{\n    vec4 vResult = vec4(1);\n    \n    vResult.rgb = vCol * fRandom;\n \n    return vResult;\n}\n\n\nbool RedCross( vec2 vTexCoord )\n{\n    if ( all( greaterThan( vTexCoord, vec2( -4, -2) ) ) && all( lessThan( vTexCoord, vec2(3, 1 ) ) ) )\n\t{\n        return true;\n\t}\n\n    if ( all( greaterThan( vTexCoord, vec2( -2, -4) ) ) && all( lessThan( vTexCoord, vec2(1, 3 ) ) ) )\n\t{\n        return true;\n\t}\n    \n    return false;\n}\n\nfloat Flap( vec2 vTexCoord )\n{\n    float f1 = vTexCoord.y - 4.0;\n    float f2 = vTexCoord.y + vTexCoord.x - 9.0;\n\n    float fFlap = min(f1,f2);\n    \n    return fFlap \/ 3.0;\n    \n}\n\nvec4 TexMedikit( vec2 vTexCoord, float fRandom, float fHRandom, float fEdge )\n{\n    vec4 vResult = vec4(1);\n    \n    float xMirror = 13.5 - abs(vTexCoord.x - 13.5);\n    \n    if ( xMirror - vTexCoord.y + 15.0 - fEdge < 0.0 )\n    {\n        return vec4(0.0);\n    }\n    \n    xMirror -= fEdge * .5;\n        \n    vResult.rgb = vec3(111)\/255.;\n \n    if ( vTexCoord.y > 15. )\n    {\n\t\tvResult.rgb = vec3(139)\/255.;\n    }\n    else\n    if ( vTexCoord.y > 14. )\n    {\n\t\tvResult.rgb = vec3(167)\/255.;\n    }        \n    \n    float fFlap = Flap( vec2( xMirror, vTexCoord.y ) );\n    \n    \/\/ Strap\n    if ( xMirror >= 6. && xMirror <= 8. )\n    {\n        if ( vTexCoord.y < 6. )\n        {\n            if ( fFlap >= 1.0 )\n            {\n\t        \tvResult.rgb = vec3(151) \/ 255.;\n            }\n            else\n            {\n\t        \tvResult.rgb = vec3(39) \/ 255.;\n            }\n        }\n    }\n        \n    if ( fFlap > 0.0 && fFlap < 1.0 )\n    {\n        vResult.rgb *= 1.0 - fFlap;\n    }\n\n    if ( vTexCoord.y < 1. )\n    {\n        vResult.rgb *= 0.75;\n    }\n\n    \n    vResult.rgb *= (fRandom * 0.2 + 0.8);\n\n    vec2 vCrossPos = vTexCoord - vec2(14, 11 );\n    if ( RedCross( vCrossPos ) )\n\t{\n        float fDist = 1.0 - length( vCrossPos ) \/ 4.5;\n        vResult.rgb = fDist * vec3(155,0,0)\/255.;\n        \n\t}\n\n    \/*if ( RedCross( vCrossPos + vec2(1,-1) ) )\n    {\n        vResult.rgb *= 0.9;        \n    }\n    \n    if ( RedCross( vCrossPos - vec2(1,-1) ) )\n    {\n\t\t\tvResult.rgb *= 1.1;        \n    }*\/\n                        \n    return vResult;\n}\n\nvec4 TexFloorLamp( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = vec4(0);\n\n    float y = floor( vTexCoord.y );\n    float xMirror = floor( abs(vTexCoord.x - 11.) );\n\n    float fWidth = 6.0;;\n    float fSpread = 1.0 \/ 4.0;\n    float fLightPos = 10.0;\n    \n    if ( y == 47.0 )\n    {\n        fWidth = 3.0;\n    }\n    else\n    if ( y == 46.0 )\n    {\n        fWidth = 5.0;\n    }\n    else\n    if ( y == 7.0 || y == 10.0 || y == 13.0 )\n    {\n        fWidth = 7.0;\n        fSpread = 1.0 \/ 8.;\n        fLightPos = 8.0;\n    }\n    else\n    if ( y == 2.0 || y == 3.0 )\n    {\n        fWidth = 11.0;\n    }\n    else\n    if ( y == 1.0 )\n    {\n        fWidth = 9.0;\n    }\n    else\n    if ( y == 4.0 )\n    {\n        fWidth = 10.0;\n    }\n    if ( y == 5.0 )\n    {\n        fWidth = 8.0;\n    }\n    \n    if ( y <= 5.0 )\n    {\n        fSpread = 1.0 \/ 20.;\n        fLightPos = y * .5 + 5.;\n    }\n    \n    if ( xMirror < fWidth )\n    {\n        if ( y >= 41. && y <= 44. )\n        {\n            vec2 delta = vTexCoord - vec2(11, 42.5);\n            float d = dot( delta, delta );\n\t        \n            float fShade1 = 0.8 - (xMirror \/ 6.0);\n            \n            float fShade2 = 1.0 - d \/ 8.0;\n            float fShade = max(0.0, max( fShade1, fShade2 ) );\n            \n            vec3 vCol = vec3(215, 187, 67)\/255.;\n            vCol += fShade * vec3(1, 0.75, 0.5);\n    \t    vResult = vec4( vCol,1.0);\n        }\n        else\n        {\n\t        float fShade= max(0.0, 1.0 - abs(vTexCoord.x - fLightPos ) * fSpread ) * 0.25;\n    \t    vResult = vec4(vec3(fShade),1.0);\n        }\n    }\n    \n    return vResult;\n}\n\nvec3 Project( vec3 a, vec3 b )\n{\n\treturn a - b * dot(a, b);\n}\n\/*\nvoid TraceSlab( const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vSlabOrigin, const in vec3 vSlabDir, const in float fThickness, out float fNear, out float fFar, inout vec3 vNormal )\n{\n    \n    float t0 = projOffset0 \/ projDir;\n    float t1 = projOffset1 \/ projDir;\n    \n    \n    \n    if ( f0 > \n}\n*\/\nfloat TraceCylinder( const in vec3 vRayOrigin, const in vec3 vRayDir, const in vec3 vCylinderOrigin, const in vec3 vCylinderDir, const in float fLength, const in float fCylinderRadius, inout vec3 vNormal )\n{\t\n\t\n\tvec3 vOffset = vCylinderOrigin - vRayOrigin;\n\t\n\tvec3 vProjOffset = Project(vOffset, vCylinderDir);\n\tvec3 vProjDir = Project(vRayDir, vCylinderDir);\n\tfloat fProjScale = length(vProjDir);\n\tvProjDir \/= fProjScale;\n\t\n\t\/\/ intersect circle in projected space\n\t\n\tfloat fTClosest = dot(vProjOffset, vProjDir);\n\t\n\tvec3 vClosest = vProjDir * fTClosest;\n\tfloat fDistClosest = length(vClosest - vProjOffset);\n\tif(fDistClosest < fCylinderRadius)\n\t{\t\t\n\t\tfloat fHalfChordLength = sqrt(fCylinderRadius * fCylinderRadius - fDistClosest * fDistClosest);\n\t\tfloat fTIntersectMin = clamp((fTClosest - fHalfChordLength) \/ fProjScale, 0.0, 100000.0);\n\t\tfloat fTIntersectMax = (fTClosest + fHalfChordLength) \/ fProjScale;\t\n\t\t\n\t\tif(fTIntersectMax > fTIntersectMin)\n\t\t{\t\n            vec3 vHitPos = vRayOrigin + vRayDir * fTIntersectMin;\n            float hitU = dot( vHitPos - vCylinderOrigin, vCylinderDir );\n            if ( hitU >= 0.0 && hitU <= fLength )\n            {\n\t\t\t\tvNormal = normalize(vProjDir * (fTClosest - fHalfChordLength) - vProjOffset );\n\t\t\t\treturn fTIntersectMin;\n            }\n\t\t}\t\t\n\t}\n    \n    \/\/ end cap\n\n    vec3 vEndPos = vCylinderOrigin;\n\tvNormal = vCylinderDir;\n    \n    if ( dot( vRayDir, vCylinderDir) < 0.0 )\n    {\n        vEndPos += vCylinderDir * fLength;\n        vNormal = -vNormal;\n    }\n    \n    vec3 vEndOffset = vEndPos - vRayOrigin;\n    float endDot = dot( vEndOffset , vCylinderDir );\n    float dirDot = dot( vRayDir, vCylinderDir );\n    \n    float capT = endDot \/ dirDot;\n    \n    if ( capT > 0.0 )\n    {\n        vec3 vCapPos = vRayOrigin + vRayDir * capT;\n        \n        if ( length( vEndPos - vCapPos ) < fCylinderRadius )\n        {\n            return capT;\n        }\n    }\n    \n    \n    return 100000.0;\n}\n\nvec4 TexTallTechnoPillar( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 vRayOrigin = vec3(0.0, 64.0, -300.0);\n    vec3 vRayTarget = vec3( vTexCoord.x - 38. * .5, vTexCoord.y, 0.0);\n    vec3 vRayDir = normalize( vRayTarget - vRayOrigin );\n    \n    vec3 vNormal;\n    \n    float t = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 3, 0), vec3(0,1,0), 127.0 - 6., 12.0, vNormal );\n\n    vec3 vNormal2;\n    float t2; \n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 3, 0), vec3(0,1,0), 6.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n\n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 127. - 3. - 6., 0), vec3(0,1,0), 6.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n\n\n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 32, 0), vec3(0,1,0), 2.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n    \n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 36, 0), vec3(0,1,0), 2.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n    t2 = TraceCylinder( vRayOrigin, vRayDir, vec3(0, 40, 0), vec3(0,1,0), 2.0, 16.0, vNormal2 );\n    if ( t2 < t )\n    {\n        t = t2;\n        vNormal = vNormal2;\n    }\n    \n    \n    \/\/vec3 vNormal1;\n    if ( t > 5000. )\n    {\n        return vec4(0.);\n    }\n    \n    vec3 vLight = normalize( vec3(-1., -0.5, -2 ) );\n    \n    float fShade = max(0.0, dot( vNormal, vLight ));\n    \n    vec3 vCol = vec3(0.2) + fRandom * 0.1;\n    \n    vec3 vPos = vRayOrigin + vRayDir * t;\n    \n    if ( vPos.y > 43. && vPos.y < 118. )\n    {\n        float f = fRandom \/ .75;\n        \/\/f *= 0.75 + fHRandom * 0.25;\n        vCol = vec3( pow( f, 5.0) );\n    }\n    \n    vCol *= fShade;\n    return vec4(vCol,1);\n    \n    \/\/ float fShade = fRandom - fHRandom * 0.5;\n    \/\/return vec4(fShade,fShade, fShade, 1);\n}\n\nvoid AddGlow( inout vec3 vResult, vec2 vSpritePixel, vec2 vGlowPos, vec3 vCol, float f )\n{\n    float fLen = length( vSpritePixel - vGlowPos );\n    \n    vResult += exp2(-fLen * f) * vCol;\n}\n\nvec4 MuzzleFlash( vec2 vUV, vec2 vPos, vec2 vSize )\n{\n    vec4 vResult = vec4( 0.0 );\n    vec2 vLocalPos = vUV - vPos;\n    vLocalPos = vLocalPos \/ vSize;\n    float fDist = length( vLocalPos );\n    fDist += abs(vLocalPos.x) + abs(vLocalPos.y);\n\n    float fFactor = fDist * 5.0 + fbm( vLocalPos * 100., 0.8);\n\n    \/\/float fAmount = exp2( * fFactor );\n\n    if ( fFactor < 3.0)\n    {\n        fFactor = 1.0 - fFactor \/ 3.0;\n\n        fFactor = pow( 0.5 + fFactor, 5.0 );\n\n        vResult.rgb = vec3( fFactor, pow(fFactor, 2.0) * .4, pow(fFactor, 3.0) * .2) * 5.0;\n        vResult.a = 1.0;\n\n    }\n    \n    return vResult;\n}\n\n\nvec4 TexBarExpl( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = TexBar1A( vTexCoord - vec2(4,0), fRandom, fHRandom );\n    \n    vec4 vExplode = MuzzleFlash( vTexCoord, vec2(16,16), vec2(60, 60));\n    \n    if ( vExplode.a > 0.0 )\n    {\n        vResult.rgb += vExplode.rgb * 0.2;\n        vResult.a = 1.0;\n        return vResult;\n    }\n    \n    \/\/AddGlow( vResult.rgb, vTexCoord, vec2(13., 20.0), vec3(1,.9, .5) * 2., 0.15 );\n    \/\/vResult *= TexFireball( vTexCoord, fRandom, fHRandom );\n\treturn vResult;\n}\n\nvec4 TexBarExpl2( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec4 vResult = MuzzleFlash( vTexCoord.yx, vec2(24,19), vec2(90, 82));    \n    \n\treturn vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\n\nvec2 SpritePixel( vec2 sheetPixel, vec4 vSpriteInfo )\n{\n    return floor(sheetPixel - vSpriteInfo.xy);\n}\n\nbool IsInSprite( vec2 sheetPixel, vec4 vSpriteInfo )\n{\n    return all( greaterThanEqual(sheetPixel, vSpriteInfo.xy) ) && all( lessThan(sheetPixel, vSpriteInfo.xy + vSpriteInfo.zw) );\n}\n\nbool SpriteSelectIterate( vec4 vSpriteInfo, vec2 sheetPixel, inout vec4 vOutSpriteInfo, inout float fOutSpriteIndex, inout float fTestIndex )\n{\n    bool isInSprite = IsInSprite( sheetPixel, vSpriteInfo );\n    \n    if ( isInSprite )\n    {\n        vOutSpriteInfo = vSpriteInfo;\n        fOutSpriteIndex = fTestIndex;\n    }\n    \n    fTestIndex++;\n    return isInSprite;\n}\n\nbool SpriteProcessIterate( inout float fTestIndex, float fSpriteIndex )\n{\n    bool bResult = false;\n    if ( fSpriteIndex == fTestIndex )\n    {\n        bResult = true;\n    }\n    \n    fTestIndex++;\n    \n    return bResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sprite Crop Sheet Info\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SPR_RIGHT(V) vec2((V.x + V.z), V.y)\n#define SPR_ABOVE(V) vec2(V.x, (V.y + V.w))\n\nconst vec4 kSpriteNone\t\t\t\t= vec4( 0 );\n\nconst vec4 kSpriteBarrel\t\t\t= vec4(\tSPR_RIGHT(kSpriteNone),\t\t\t\t\t23,32);\nconst vec4 kSpriteBarrelExpl\t\t= vec4(\tSPR_RIGHT(kSpriteBarrel),\t\t\t\t32,32);\n\nconst vec4 kSpriteFireball\t\t\t= vec4(\tSPR_RIGHT(kSpriteBarrelExpl),\t\t\t20,20);\nconst vec4 kSpriteFireball2\t\t\t= vec4(\tSPR_RIGHT(kSpriteFireball),\t\t\t\t24,24);\n\nconst vec4 kSpriteHealthBonus\t\t= vec4(\tSPR_RIGHT(kSpriteFireball2),\t\t\t16,16);\nconst vec4 kSpriteArmorBonus\t\t= vec4(\tSPR_ABOVE(kSpriteHealthBonus),\t\t\t16,15);\nconst vec4 kSpriteMedikit\t\t\t= vec4(\tSPR_RIGHT(kSpriteHealthBonus),\t\t\t28,19);\nconst vec4 kSpriteStimpack\t\t\t= vec4(\tSPR_RIGHT(kSpriteMedikit),\t\t\t\t16,19);\nconst vec4 kSpriteBlueArmor\t\t\t= vec4(\tSPR_RIGHT(kSpriteStimpack),\t\t\t\t32,24);\nconst vec4 kSpriteGreenArmor\t\t= vec4(\tSPR_RIGHT(kSpriteBlueArmor),\t\t\t32,24);\nconst vec4 kSpriteShotgun\t\t\t= vec4(\tSPR_RIGHT(kSpriteGreenArmor),\t\t\t32,16);\n\nconst vec4 kSpriteWallImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteShotgun),\t\t\t\t6,6);\nconst vec4 kSpriteWallSmokeImpact1\t= vec4(\tSPR_RIGHT(kSpriteWallImpact1),\t\t\t8,16);\nconst vec4 kSpriteFleshImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteWallSmokeImpact1),\t\t8,8);\n\nconst vec4 kSpriteBloodyMess\t\t= vec4(\tSPR_RIGHT(kSpriteFleshImpact1) + vec2(0,16),\t\t42,16);\nconst vec4 kSpriteDeadTrooper \t\t= vec4(\tSPR_RIGHT(kSpriteBloodyMess),\t\t\t42,16);\nconst vec4 kSpriteDeadSergeant \t\t= vec4(\tSPR_RIGHT(kSpriteDeadTrooper),\t\t\t42,16);\nconst vec4 kSpriteDeadImp \t\t\t= vec4(\tSPR_RIGHT(kSpriteDeadSergeant),\t\t\t42,16);\n\nconst vec4 kSpriteBarrelExpl2\t\t= vec4(\t480,0,\t\t\t\t\t\t\t\t\t38,48);\n\nconst vec4 kSpriteFloorLamp\t\t\t= vec4(\t480,48,\t\t\t\t\t\t\t\t\t23,48);\nconst vec4 kSpriteTallTechnoPillar\t= vec4(\tSPR_ABOVE(kSpriteFloorLamp),\t\t\t38,128);\n\nconst vec4 kSpriteEnemyBegin = vec4(0, 32., 32, 52);\n\n\n#define SPRITE_ENEMY_ACTION_STAND \t\t0.\n#define SPRITE_ENEMY_ACTION_ATTACK\t\t1.\n#define SPRITE_ENEMY_ACTION_WALK1 \t\t2.\n#define SPRITE_ENEMY_ACTION_WALK2 \t\t3.\n#define SPRITE_ENEMY_ACTION_PAIN \t\t4.\n#define SPRITE_ENEMY_ACTION_DIE \t\t5.\n\n#define SPRITE_ENEMY_ACTION_COUNT \t\t6\n\n#define SPRITE_ENEMY_ACTION_DEAD\t\t10.\n\n#define SPRITE_ENEMY_TYPE_TROOPER \t0.\n#define SPRITE_ENEMY_TYPE_IMP \t\t1.\n#define SPRITE_ENEMY_TYPE_SERGEANT \t2.\n\n#define SPRITE_ENEMY_TYPE_COUNT     3\n\nvec4 GetEnemySprite( float fType, float fAction, float fDirection )\n{\n    vec2 vGridPos = vec2( fType + fDirection * float(SPRITE_ENEMY_TYPE_COUNT), fAction );\n    vec2 vPos = kSpriteEnemyBegin.xy +kSpriteEnemyBegin.zw * vGridPos;\n\treturn vec4( vPos, kSpriteEnemyBegin.zw );\n}\n\n\n\nbool GetEnemySpriteId( vec2 fragCoord, out float fEnemySpriteType, out float fEnemySpriteAction, out float fEnemySpriteDirection )\n{\n    vec2 vGridLocal = fragCoord - kSpriteEnemyBegin.xy;\n    vec2 vGridPos = floor( vGridLocal \/ kSpriteEnemyBegin.zw );\n    \n    fEnemySpriteType = mod( vGridPos.x, float(SPRITE_ENEMY_TYPE_COUNT) );\n    fEnemySpriteAction = vGridPos.y;\n    fEnemySpriteDirection = floor( vGridPos.x \/ float(SPRITE_ENEMY_TYPE_COUNT) );\n\n    return ( vGridPos.x >= 0. && vGridPos.y >= 0. && vGridPos.x < (float(SPRITE_ENEMY_TYPE_COUNT) * 5.0) && vGridPos.y < float(SPRITE_ENEMY_ACTION_COUNT) );        \n}\n\n\n\n\nvoid Pose_Enemy( float fEnemySpriteType, float fEnemySpriteAction, float fEnemySpriteDirection )\n{\n    bool bWeapon = false;\n    if ( fEnemySpriteType == float(SPRITE_ENEMY_TYPE_IMP))\n    {\n        CharDef_Imp( g_scene.charDef );            \n    }            \n    else\n        if ( fEnemySpriteType == float(SPRITE_ENEMY_TYPE_TROOPER))\n        {\n            CharDef_Trooper( g_scene.charDef );\n        }   \n    else\n        if ( fEnemySpriteType == float(SPRITE_ENEMY_TYPE_SERGEANT))\n        {\n            CharDef_Sergeant( g_scene.charDef );\n            bWeapon = true;\n        }                        \n\n    \/\/\/\/\/\/\n    \n    if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_STAND))\n    {\n        Pose_Clear( g_scene.pose );\n    }            \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_ATTACK))\n        {\n            Pose_Attack( g_scene.pose );\n        }            \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_WALK1))\n        {\n            Pose_Walk1( g_scene.pose );\n        }   \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_WALK2))\n        {\n            Pose_Walk2( g_scene.pose );\n        }                        \n    else\n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_PAIN))\n        {\n            Pose_Pain( g_scene.pose );\n        }                        \n    else \n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_DIE))\n    {\n        Pose_Die( g_scene.pose );\n        bWeapon = false;        \n    }                        \n    else \n        if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_DEAD))\n    {\n        Pose_Dead( g_scene.pose );\n        bWeapon = false;\n    }                        \n\n                          \n    if ( bWeapon )\n    {\n    \tPose_Weapon();\n    }\n    else\n    {\n\t\tWeapon_None();\n    }    \n\n    g_scene.fCameraRotation = fEnemySpriteDirection * radians(45.0);            \n}\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define FONT_POS \tvec2(280,0)\n#define FONT_CHAR \tvec2(16,0)\n\nvec4 NumFont_Char( vec2 vTexCoord, float fDigit )\n{\n \tif ( fDigit < 0.0 || fDigit > 10.0 )\n    \treturn vec4(0.0);\n    \n    \/\/vTexCoord = floor(vTexCoord * vec2(14.0, 16.0)) + 0.5 + vec2(480,96);\n    vTexCoord = floor(vTexCoord) + 0.5 + FONT_POS;\n    vTexCoord += FONT_CHAR * fDigit;\n    \n    vec2 vScale = vec2(1.0) \/ iChannelResolution[1].xy;\n        \n    float fSample_TL = texture2D( iChannel1, (vTexCoord - vec2(-1, 1) ) * vScale ).a;\n    float fSample_TC = texture2D( iChannel1, (vTexCoord - vec2( 0, 1) ) * vScale ).a;\n    float fSample_TR = texture2D( iChannel1, (vTexCoord - vec2( 1, 1) ) * vScale ).a;\n    \n    float fSample_CL = texture2D( iChannel1, (vTexCoord - vec2(-1, 0) ) * vScale ).a;\n    float fSample_CC = texture2D( iChannel1, (vTexCoord - vec2( 0, 0) ) * vScale ).a;\n    float fSample_CR = texture2D( iChannel1, (vTexCoord - vec2( 1, 0) ) * vScale ).a;\n    float fSample_CS = texture2D( iChannel1, (vTexCoord - vec2( 2, 0) ) * vScale ).a;\n\n    float fSample_BL = texture2D( iChannel1, (vTexCoord - vec2(-1,-1) ) * vScale ).a;\n    float fSample_BC = texture2D( iChannel1, (vTexCoord - vec2( 0,-1) ) * vScale ).a;\n    float fSample_BR = texture2D( iChannel1, (vTexCoord - vec2( 1,-1) ) * vScale ).a;\n    float fSample_BS = texture2D( iChannel1, (vTexCoord - vec2( 2,-1) ) * vScale ).a;\n    \n    \n    float fSample_SC = texture2D( iChannel1, (vTexCoord - vec2( 0,-2) ) * vScale ).a;\n    float fSample_SR = texture2D( iChannel1, (vTexCoord - vec2( 1,-2) ) * vScale ).a;\n    float fSample_SS = texture2D( iChannel1, (vTexCoord - vec2( 2,-2) ) * vScale ).a;\n   \n    float fOutline = min( 1.0, \n\t\tfSample_TL + fSample_TC + fSample_TR +\n\t\tfSample_CL + fSample_CC + fSample_CR +\n\t\tfSample_BL + fSample_BC + fSample_BR );\n    \n    float fShadow = min( 1.0, \n\t\tfSample_CC + fSample_CR + fSample_CS +\n\t\tfSample_BC + fSample_BR + fSample_BS + \n\t\tfSample_SC + fSample_SR + fSample_SS);\n    \t\n    float fMain = fSample_CC;\n    \n    vec4 vResult = vec4(0.0);\n    \n    float fAlpha = min( 1.0, fOutline + fMain + fShadow );\n    \n    float fShade = fSample_TL * 1.5 + fSample_BR * -1.5 + fSample_TC * 1.0 + fSample_CL * 1.0 \n        + fSample_BC * -1.0 + fSample_CR * -1.0;\n    \n    fShade = clamp( fShade * 0.25, 0.0, 1.0 );\n    \n    fShade = fShade * .3 + .7;\n    \n    vec3 vColor = vec3( .2 ); \/\/ drop shadow\n    \n    if ( fOutline > 0.0 )\n        vColor = vec3(.4, 0, 0); \/\/ outline\n\n    if ( fMain > 0.0 )\n        vColor = vec3(fShade, 0, 0); \/\/ main text\n            \n    vResult = vec4(vColor, fAlpha);\n    \n    return vResult;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    bool bReuseData = false;\n    if ( iFrame > 0 )\n    {\n\t    \/\/ Check Resolution\n        vec4 info = texture2D( iChannel0, vec2(0.0, 0.0));\n        if ( (info.x == iResolution.x) && (info.y == iResolution.y) )\n        {\n            bReuseData = true;\n        }\n    }\n\n\tif ( bReuseData )\n    {\n        fragColor = texture2D( iChannel0, fragCoord\/iResolution.xy );\n        return;\n        \/\/vResult.r = sin(iGlobalTime * 10.0) *0.5 + 0.5; \/\/ flash the cache\n    }    \n    \n    vec2 vFontCoord = floor( fragCoord - FONT_POS );\n    \n    vec4 vResult = vec4(0.2,0,0,1);\n    \n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;    \n    \n    vec2 vSpritePixel = vec2(0);\n    vec4 vSpriteInfo = vec4(0);\n    \n    float fSpriteIndex = -1.;\n    \n    bool bRaymarch = false;\n    Scene_Clear();\n    \n    \n    #if 0\n        bRaymarch = true;\n    \n    \t#if 1\n    \t\tg_scene.bArmor = true;\n    \t#endif\n    \n    \t#if 0\n            g_scene.bCharacter = true;\n\n            \/\/float fType = SPRITE_ENEMY_TYPE_TROOPER;\n            float fType = SPRITE_ENEMY_TYPE_SERGEANT;\n            \/\/float fType = SPRITE_ENEMY_TYPE_IMP;\n\n            \/\/float fAction = SPRITE_ENEMY_ACTION_STAND;\n            float fAction = SPRITE_ENEMY_ACTION_WALK1;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_WALK2;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_ATTACK;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_PAIN;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_DIE;\n            \/\/float fAction = SPRITE_ENEMY_ACTION_DEAD;\n\n\n            Pose_Enemy( fType, fAction, 0. );\n\n    \t#endif\n\n        vec2 vSize = vec2(512, 512);\n        float fScale = 6.5;\n        vec2 vPos = fragCoord.xy;\n        vPos.x = (vPos.x - vSize.x * .5) \/ fScale + vSize.x * .5;\n        vPos.y \/= fScale;\n    \n    \tg_scene.fCameraRotation = iGlobalTime;\n    \tfragColor = Raymarch_Sprite( vPos.xy, vec4(0,0,512,512) );\n    \n    \treturn;\n    #endif\n    \n    \n    float fTestIndex = 0.;\n    if ( SpriteSelectIterate( kSpriteFireball, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n    }\n    if ( SpriteSelectIterate( kSpriteFireball2, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n    }\n    if ( SpriteSelectIterate( kSpriteBarrel, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBarrelExpl, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBarrelExpl2, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBloodyMess, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        fPersistence = 1.0;\n    }\n    if ( SpriteSelectIterate( kSpriteHealthBonus, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteArmorBonus, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        fPersistence = 0.6;\n    }\n    if ( SpriteSelectIterate( kSpriteMedikit, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteStimpack, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteBlueArmor, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bArmor = true;\n    }\n    if ( SpriteSelectIterate( kSpriteGreenArmor, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bArmor = true;\n\t    g_scene.vLightDir = normalize( vec3(0.2, 1, -0.2) );\n        \n    }\n    if ( SpriteSelectIterate( kSpriteShotgun, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bCharacter = false;\n        Weapon_DefaultPos();\n    }\n    if ( SpriteSelectIterate( kSpriteWallImpact1, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteWallSmokeImpact1, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        fPersistence = 0.95;\n    }\n    if ( SpriteSelectIterate( kSpriteFleshImpact1    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n    }\n    if ( SpriteSelectIterate( kSpriteDeadTrooper    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {        \n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t    CharDef_Trooper( g_scene.charDef );            \n        Pose_Dead( g_scene.pose );\n    }\n    if ( SpriteSelectIterate( kSpriteDeadSergeant    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t    CharDef_Sergeant( g_scene.charDef );                    \n        Pose_Dead( g_scene.pose );\n    }\n    if ( SpriteSelectIterate( kSpriteDeadImp    , fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t    CharDef_Imp( g_scene.charDef );                    \n        Pose_Dead( g_scene.pose );\n    }\n    if ( SpriteSelectIterate( kSpriteFloorLamp, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n    }\n    if ( SpriteSelectIterate( kSpriteTallTechnoPillar, fragCoord, vSpriteInfo, fSpriteIndex, fTestIndex ) )\n    {\n        fNoise2Freq = 2.0;\n        fPersistence = 1.0;\n    }\n    \n    float fEnemySpriteType;\n    float fEnemySpriteAction;\n    float fEnemySpriteDirection;\n    bool isEnemySprite = GetEnemySpriteId( fragCoord, fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection );\n\n    vec2 vFontMax = 10. * FONT_CHAR;\n    if( vFontCoord.x >= 0.0 && vFontCoord.y >= 0.0 && vFontCoord.x < (vFontMax.x + 16.0) && vFontCoord.y < (vFontMax.y + 16.0) )\n    {\n        fSpriteIndex = 777.;\n    }\n    else\n    if ( isEnemySprite )\n    {\n        bRaymarch = true;\n        g_scene.bCharacter = true;\n\t\tPose_Enemy( fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection );\n        \n        fSpriteIndex = 666.;\n        vSpriteInfo = GetEnemySprite( fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection );\n        \n        \/\/fragColor.rgb= vec3( fEnemySpriteType, fEnemySpriteAction, fEnemySpriteDirection) \/ 8.0; return;\n    }\n        \n    if ( fSpriteIndex == -1.0 )\n    {\n        discard;\n    }\n\t\t\n\tvec4 vRaymarchResult = vec4( 0 );\n    vRaymarchResult = Raymarch_Sprite( fragCoord.xy, vSpriteInfo );\n    \n    {    \n        vSpritePixel = SpritePixel( fragCoord, vSpriteInfo );\n\n        float fRandom = fbm( vSpritePixel, fPersistence );\n        float fHRandom = noise1D( vSpritePixel.x * fNoise2Freq );\/\/ - (vSpritePixel.y \/ vSpriteInfo.w);\n\n        fTestIndex = 0.;\n\n\t    if( vFontCoord.x >= 0.0 && vFontCoord.y >= 0.0 && vFontCoord.x < (vFontMax.x + 16.0) && vFontCoord.y < (vFontMax.y + 16.0) )\n        {\n\n            float fFontDigit = floor( vFontCoord.x \/ 16.0);\n            vec2 vFontPixel = floor( vFontCoord.xy );\n            vFontPixel.x = mod( vFontPixel.x, 16.0 );\n            vResult = NumFont_Char( vFontPixel, fFontDigit );\n            \/\/float fValue = NumFont_BinChar( vFontPixel, fFontDigit );\n            \/\/vResult =  vec4( fValue );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFireball( vSpritePixel, fRandom, fHRandom, vSpriteInfo.z * .5, 0. );\n        }\n\t\tif ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFireball( vSpritePixel, fRandom, fHRandom, vSpriteInfo.z * .5, 1. );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBar1A( vSpritePixel, fRandom, fHRandom );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBarExpl( vSpritePixel, fRandom, fHRandom );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBarExpl2( vSpritePixel, fRandom, fHRandom );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom  );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexHealthBonus( vSpritePixel, fRandom, fHRandom  );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexArmorBonus( vSpritePixel, fRandom, fHRandom  );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Medikit\n            vResult = TexMedikit( vSpritePixel, fRandom, fHRandom, 0.0 );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Stimpack\n            vResult = TexMedikit( vSpritePixel + vec2(6,0), fRandom, fHRandom, 5.0 );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ blue armor\n            \/\/vResult = TexPlaceholder( vSpritePixel, fRandom, fHRandom, vec3(0,0,1) );\n            vResult = vRaymarchResult;            \n            vResult.rgb *= fRandom * vec3(0,0,1);            \n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ green armor\n            vResult = vRaymarchResult;            \n            vResult.rgb *= fRandom * vec3(0,1.0,0);\n            \/\/vResult = TexPlaceholder( vSpritePixel, fRandom, fHRandom, vec3(0,1.0,0) );\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Shotgun\n            \/\/vResult = TexShotgunItem( vSpritePixel, fRandom, fHRandom  );\n            vResult = vRaymarchResult;       \n            vResult.rgb *= fRandom;\n            \n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexWallImpact( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexBulletSmokeImpact( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFleshImpact( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Dead trooper\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom );\n            float fMask = fRandom * fRandom * ((16.0 - vSpritePixel.y) \/ 4.0);\n            if ( (vRaymarchResult.a - fMask ) > 0. )\n            {\n            \tvResult = vRaymarchResult;            \n\t            vResult.xyz *= fRandom;\n            }\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Dead sergeant\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom );\n            float fMask = fRandom * fRandom * ((16.0 - vSpritePixel.y) \/ 4.0);\n            if ( (vRaymarchResult.a - fMask ) > 0. )\n            {\n            \tvResult = vRaymarchResult;            \n\t            vResult.xyz *= fRandom;\n            }\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            \/\/ Dead imp\n            vResult = TexPlayW( vSpritePixel, fRandom, fHRandom );\n            float fMask = fRandom * fRandom * ((16.0 - vSpritePixel.y) \/ 4.0);\n            if ( (vRaymarchResult.a - fMask ) > 0. )\n            {\n            \tvResult = vRaymarchResult;            \n\t            vResult.xyz *= fRandom;\n            }\n        }\n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexFloorLamp( vSpritePixel, fRandom, fHRandom  );\n        }        \n        if ( SpriteProcessIterate( fTestIndex, fSpriteIndex) )\n        {\n            vResult = TexTallTechnoPillar( vSpritePixel, fRandom, fHRandom  );\n        }        \n        \n        \n        if ( isEnemySprite )\n        {\n            vResult = vRaymarchResult;\n            vResult.xyz *= fRandom;\n            \n            if ( fEnemySpriteAction == float(SPRITE_ENEMY_ACTION_ATTACK) )\n            {\n\t            AddGlow( vResult.xyz, vSpritePixel, vec2(16. - 8. * sin( g_scene.fCameraRotation), 36), vec3(1,.9, .5) * 3., 1.0 );\n            }\n        }\n\n        vResult.rgb = clamp( vResult.rgb, 0.0, 1.0 );\n        vResult.rgb = Quantize(vResult.rgb, 32.0);\n    }\n    \n\t\n\n \n    \/\/ Flash alpha channel\n#if 0\n    if ( vResult.a == 0. )\n    {\n        float fFlash = 1.0;\n        \/\/float fFlash = sin(iGlobalTime* 10.) * 0.5 + 0.5;\n        vResult.rgb = mix ( vec3(0,0,0.3), vec3(1,.5, 1), fFlash );\n    }\n#endif    \n    \n    if ( floor ( fragCoord ) == vec2(0.0) )\n    {\n        vResult = vec4( iResolution.x, iResolution.y, 0, 0 );\n    }\n    \n    fragColor = vResult;\n}\n","name":"Buf B","description":"","type":"buffer"},{"inputs":[{"id":33,"src":"\/presets\/tex00.jpg","ctype":"keyboard","channel":3,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":259,"channel":0}],"code":"\/\/ Update \/ Game Logic\n\n\/\/#define DEV\n\n#ifdef DEV\n\n#define CHEAT_GOD\n#define CHEAT_NOCLIP\n#define CHEAT_NOAI\n\n#endif \n\n\n\/\/ TODO:\n\/\/\n\/\/ * Bug fixes\n\/\/ ** Only pickup when needed\n\/\/ ** Fix slidebox bugs *!*\n\/\/ ** Fix line of sight bugs\n\n\/\/ * Performance\n\/\/ ** Profile\n\/\/ ** Entity rendering precalc\n\/\/ ** Sector update logic in BufC (makes bufA static)\n\n\/\/ *Implement more textures\n\/\/ ** Exit door\n\/\/ ** Exit area door\n\/\/ ** Walls with alpha\n\/\/\n\/\/ * Add more decorations \n\/\/ ** Dead players\n\/\/ ** Candelabra\n\n\/\/ * Sprites\n\/\/ ** improve fireball + explode\n\n\/\/ * Presentation \/ UI\n\/\/ ** Skill select?\n\/\/ ** Level summary\n\n\/\/ * Enemy sound \/ path finding\n\n\/\/ * Viewmodel\n\/\/ ** Viewmodel hand\n\/\/ ** Better pistol viewmodel\n\/\/ ** Better viewmodel anim\n\n\/\/ * Map color (brown vs yellow)\n\n\/\/ * Gameplay\n\/\/ ** More authentic movement\n\/\/ ** Mouse accel\n\/\/ ** Balance damage \/ health amounts\n\n\/\/ * Ammo \/ ammo pickups\n\/\/ ** Clip\n\/\/ ** Shells\n\/\/ ** Box of shells\n\n\/\/ * Unpinned top \/ bottom textures\n\n\/\/ * Generic door \/ platform logic\n\n\/\/ * Improve enemy poses\n\n\n\/\/#define ALLOW_MAP\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define FAR_CLIP 1000000.0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Util\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 Quantize( const in vec3 col, float fLevels )\n{\n\treturn floor( col * fLevels + 0.5 ) * (1.0 \/ fLevels);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    return vA.x * vB.y - vA.y * vB.x;\n}\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid SetFlag( inout float fBits, float fFlag )\n{\n    \/\/ TODO: flag mask logic \n    fBits = fFlag;\n}\n\n\nbool FlagSet( float fBits, float fFlag )\n{\n    return fract( floor( fBits \/ fFlag ) * 0.5 ) >= 0.5;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nconst float KEY_1 = \t49.5\/256.0;\nconst float KEY_2 = \t50.5\/256.0;\nconst float KEY_3 = \t51.5\/256.0;\nconst float KEY_ENTER = 13.5\/256.0;\nconst float KEY_SHIFT = 16.5\/256.0;\nconst float KEY_CTRL  = 17.5\/256.0;\nconst float KEY_ALT   = 18.5\/256.0;\nconst float KEY_TAB\t  = 9.5\/256.0;\n\nbool Key_IsPressed(float key)\n{\n    return texture2D( iChannel3, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool Key_IsToggled(float key)\n{\n    return texture2D( iChannel3, vec2(key, 1.0) ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Packing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat BytePack2( vec2 val )\n{ \n    return dot( floor(val), vec2(1, 256) );\n}\n\nfloat BytePack2( float x, float y )\n{\n    return BytePack2( vec2( x, y ) );\n}\n\nvec2 ByteUnpack2( float x )\n{\n    return mod( floor(vec2(x) \/ vec2(1, 256)), 256. );\n}\n\nfloat BytePack3( vec3 val )\n{ \n    return dot( floor(val), vec3(1, 256, 65536) );\n}\n\nfloat BytePack3( float x, float y, float z )\n{\n    return BytePack3( vec3( x, y, z ) );\n}\n\nvec3 ByteUnpack3( float x )\n{\n    return mod( floor(vec3(x) \/ vec3(1, 256, 65536)), 256. );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( sampler, vUV, -100.0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in vec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nvec4 ReadMapData( vec2 address )\n{\n    return LoadVec4( MAP_CHANNEL, address );\n}\n    \nvec4 ReadStateData( vec2 address )\n{\n    return LoadVec4( STATE_CHANNEL, address );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Game State\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MAIN_GAME_STATE_BOOT\t\t\t0.\n#define MAIN_GAME_STATE_SKILL_SELECT\t1.\n#define MAIN_GAME_STATE_INIT_LEVEL\t\t2.\n#define MAIN_GAME_STATE_GAME_RUNNING\t3.\n#define MAIN_GAME_STATE_WIN\t\t\t\t4.\n\nstruct GameState\n{\n    float fMainState;\n    float fStateTimer;\n    float fSkill;\n    float fGameTime;\n    \n    vec4 vPrevMouse;\n    \n    float fMap;\n    float fHudFx;\n    \n    float fMessage;\n    float fMessageTimer;\n};\n\nvoid GameState_Reset( out GameState gameState )\n{\n    gameState.fMainState = MAIN_GAME_STATE_BOOT;\n\tgameState.fSkill = 0.;\n    gameState.fGameTime = 0.;\n    gameState.fStateTimer = 0.;\n    \n    gameState.vPrevMouse = iMouse;\n    \n    gameState.fMap = 0.0;\n    gameState.fHudFx = 0.0;\n    \n    gameState.fMessage = -1.0;\n    gameState.fMessageTimer = 0.0;\n}\n\nGameState GameState_Read()\n{\n    GameState gameState;\n    \n    vec2 vAddress = vec2( 0 );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    gameState.fMainState = vData0.x;\n    gameState.fSkill = vData0.y;\n    gameState.fGameTime = vData0.z;\n    gameState.fStateTimer = vData0.w;    \n\n    gameState.vPrevMouse = vData1;\n    \n    gameState.fMap = vData2.x;\n    gameState.fHudFx = vData2.y;\n\n    gameState.fMessage = vData2.z;\n    gameState.fMessageTimer = vData2.w;\n    \n    return gameState;\n}\n\nvoid GameState_Store( GameState gameState, inout vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 vData0 = vec4( gameState.fMainState, gameState.fSkill, gameState.fGameTime, gameState.fStateTimer );    \n\n    vec4 vData1 = vec4( gameState.vPrevMouse );    \n\n    vec4 vData2 = vec4( gameState.fMap, gameState.fHudFx, gameState.fMessage, gameState.fMessageTimer );    \n\n    vec2 vAddress = vec2( 0 );\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.x++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Map Data\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n#define MAX_SECTOR_COUNT 96\n#define MAX_SIDEDEF_COUNT 32\n\n#define SECTOR_NONE -1.\n\nstruct MapInfo\n{\n    float fSectorCount;\n};\n    \nMapInfo ReadMapInfo()\n{\n    MapInfo mapInfo;\n    \n    vec4 vData = ReadMapData( vec2(0.0, 0.0) );\n    \n    mapInfo.fSectorCount = vData.x;\n    \n    return mapInfo;\n}\n\nstruct Sector\n{\n    float fSectorId;\n    float fLightLevel;\n\n    float fFloorHeight;\n    float fCeilingHeight;\n\n    float fFloorTexture;\n    float fCeilingTexture;\n};\n    \nvec2 GetSectorAddress( float fSectorId )\n{\n    return vec2(0.0, 1.0 + fSectorId );\n}\n\nvec2 GetSideDefAddress( float fSectorId, float fSideDefIndex )\n{\n    return vec2(2.0 + fSideDefIndex * 3.0, 1.0 + fSectorId );\n}\n    \nSector Map_ReadSector( float fSectorId )\n{\n    Sector sector;\n    \n    sector.fSectorId = fSectorId;\n    \n    vec2 vAddress = GetSectorAddress( fSectorId );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n\n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sector.fLightLevel = vData0.x;\n\n    sector.fFloorHeight = vData1.x;\n    sector.fCeilingHeight = vData1.y;\n    sector.fFloorTexture = vData1.z;\n    sector.fCeilingTexture = vData1.w;\n    \n    return sector;\n}\n\nstruct SideDef\n{\n    vec2 vA;\n    vec2 vB;\n    float fLength;\n    \n    float fNextSector;\n    \n    float fLightLevel;\n    \n    float fUpperTexture;\n    float fMiddleTexture;\n    float fLowerTexture;    \n    \n    float fFlags;\n};\n\nSideDef Map_ReadSideDefInfo( float fSectorId, float fSideDefIndex )\n{\n    SideDef sideDef;\n    \n    vec2 vAddress = GetSideDefAddress( fSectorId, fSideDefIndex );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;                       \n\n    sideDef.vA = vData0.xy;\n    sideDef.vB = vData0.zw;\n    \n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sideDef.fLength = vData1.x;\n    sideDef.fLightLevel = vData1.y;    \n    sideDef.fMiddleTexture = vData1.z;\n    sideDef.fNextSector = vData1.w;\n    \n    vec4 vData2 = ReadMapData(vAddress);\n    sideDef.fLowerTexture = vData2.x;\n    sideDef.fUpperTexture = vData2.y;\n    sideDef.fFlags = vData2.z;\n    \n    return sideDef;\n}\n\n\/\/ Return:\n\/\/   ray t value\n\/\/   sidedef u value\n\/\/   edge crossing direction\nvec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )\n{\n    vec2 vEdgeDir = sideDef.vB - sideDef.vA;\n    vec2 vOA = sideDef.vA - vRayPos;\n    float fDenom = Cross2d( vRayDir, vEdgeDir );\n    float fRcpDenom = 1.0 \/ fDenom;\n    \n    vec3 vHitTUD;\n    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;\n    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;\n    vHitTUD.z = fDenom;\n    \n    return vHitTUD;    \n}\n\nbool Map_ValidSectorId( MapInfo mapInfo, float fSectorId )\n{\n    return ( fSectorId >= 0.0 && fSectorId < mapInfo.fSectorCount );\n}\n\nbool Map_PointInSector( vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n    {\n        float fSideDefIndex = float(iSideDefIndex);\n        \n        SideDef sideDef = Map_ReadSideDefInfo( sector.fSectorId, fSideDefIndex );                        \n        \n        if ( sideDef.fLength <= 0.0)\n        {\n            break;\n        }\n\n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( MapInfo mapInfo, vec2 vPos, float fSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, fSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( fSectorId );\n\n    return Map_PointInSector( vPos, sector );\n}\n\nfloat Map_SeekSector( MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    {\n        float fSectorId = float(iSectorIndex);\n        \n        if ( !Map_ValidSectorId( mapInfo, fSectorId ) )\n        {\n            break;\n        }\n\n        if ( Map_PointInSector( mapInfo, vPos, fSectorId ) )\n        {\n            return fSectorId;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout float fSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapInfo, vPos, fSectorId ) )\n    {\n        float fNewSectorId = Map_SeekSector( mapInfo, vPos );\n        \n        if ( fNewSectorId != SECTOR_NONE )\n        {\n        \tfSectorId = fNewSectorId;\n        }                \n    }\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Trace\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nstruct TraceResult\n{\n    float fDist;\n    vec3 vTexture; \/\/ UV \/ TexureId during trace. Resolved to RGB for sprite rendering\n  \tfloat fLightLevel;\n    float fSector;\n};\n\nstruct TraceSectorState\n{\n    float fEnterDist;\n    float fExitY;\n    float fNextSector;\n    bool bNoUpper;\n};\n\nvoid TraceSideDef( vec3 vRayOrigin, vec3 vRayDir, inout TraceResult result, inout TraceSectorState sectorState, Sector sector, SideDef sideDef )\n{    \n\tvec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vRayOrigin.xz, vRayDir.xz );\n    float fHitT = vHitTUD.x;\n    float fHitU = vHitTUD.y;\n    float fDenom = vHitTUD.z;\n\n    if( \n        \/\/ We hit the edge between the endpoints\n        (fHitU >= 0.0) && (fHitU < 1.0) &&\n        \/\/ Hit point is further than sector entrance distance\n        (fHitT > sectorState.fEnterDist) && \n        \/\/ Track closest hit\n        (fHitT < result.fDist) && \n        \/\/ Ignore faces entering sector\n        (fDenom < 0.0)\n      )\n    {\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        sectorState.fExitY = fHitY;\n        result.fDist = fHitT;\n        \n        if( (sectorState.fExitY > sector.fFloorHeight) )                \n        {\n            sectorState.fNextSector = SECTOR_NONE;\n            if( sideDef.fNextSector == SECTOR_NONE && sideDef.fMiddleTexture != 0.0 && (sectorState.fExitY < sector.fCeilingHeight ) )\n            {\n                result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY);\n                result.vTexture.z = sideDef.fMiddleTexture;\n                result.fLightLevel = sideDef.fLightLevel;\n                sectorState.bNoUpper = false;\n            }\n            else\n            {\n                Sector nextSector = Map_ReadSector( sideDef.fNextSector );\n                                \n\t\t        bool bNoUpper = mod(sideDef.fFlags, 2.0) != 0.0;\n\n\t            if (sectorState.fExitY < sector.fCeilingHeight || bNoUpper )\n                {                                    \n                    if( nextSector.fFloorHeight > sector.fFloorHeight && fHitY > sector.fFloorHeight && fHitY < nextSector.fFloorHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fFloorHeight);\n                        result.vTexture.z = sideDef.fLowerTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }            \n                    else\n                    if( sideDef.fUpperTexture != 0.0 && nextSector.fCeilingHeight < sector.fCeilingHeight && fHitY < sector.fCeilingHeight && fHitY > nextSector.fCeilingHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fCeilingHeight);\n                        result.vTexture.z = sideDef.fUpperTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }\n                    else\n                    {\n                        sectorState.bNoUpper = bNoUpper;\n                        sectorState.fNextSector = sideDef.fNextSector;                          \n                    }\n                }\n            }\n        }\n    }\n}\n\nTraceResult Map_Trace( MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, float fSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.fSector = SECTOR_NONE;\n    \n    for(int iSectorIndex=0; iSectorIndex<20; iSectorIndex++)\n    {\n        if ( fSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( fSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.fNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.fSector = fSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n        {\n            float fSideDefIndex = float(iSideDefIndex);\n            \n            SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n            \n            if ( sideDef.fLength <= 0.0)\n            {\n\t\t\t\tbreak;\n            }\n\n            TraceSideDef( vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.vTexture.z = sector.fFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.vTexture.z = sector.fCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }        \n\n        fSectorId = sectorState.fNextSector;\n    }\n    \n    if ( result.vTexture.z == 1.0 )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Entity Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ENTITY_TYPE_NONE -1.\n\nstruct Entity\n{\n    float fId;\n    \n    float fType;\n    float fSubType;\n    float fSectorId;    \n\n    vec3 vPos;\n    float fYaw;\n    float fPitch;\n    \n    vec3 vVel;\n    float fYawVel;\n    \n    float fHealth;\n    float fArmor;    \n    \n    float fUseWeapon;    \n    float fHaveShotgun;\n    \n    float fTookDamage; \/\/ For HUD damage indicator\n    float fEvent; \/\/ Message event for UI \"Picked up an armor bonus\" etc.\n    \n    float fTimer; \/\/ Weapon reload for player, think timer for AI\n    float fTarget; \/\/ AI nemesis and also used for player aim up \/ down \n    float fFrameFlags;\n};\n    \n#define ENTITY_DATA_YPOS 8.\n#define ENTITY_DATA_SIZE 4.\n\n#define ENTITY_MAX_COUNT 128.\n    \n#define ENTITY_NONE -1.\n    \nfloat Entity_GetOutputId( vec2 fragCoord )\n{\n    if (\n           fragCoord.y < ENTITY_DATA_YPOS\n        || fragCoord.y >= (ENTITY_DATA_YPOS + ENTITY_DATA_SIZE)\n        || fragCoord.x >= ENTITY_MAX_COUNT\n       )\n    {\n        return ENTITY_NONE;        \n    }\n\n    return floor(fragCoord.x);\n}\n\nbool Entity_IdValid( float fEntityId )\n{\n    return ( fEntityId >= 0. && fEntityId < ENTITY_MAX_COUNT );\n}\n\nvoid Entity_Clear( inout Entity entity )\n{\n    entity.fType = ENTITY_TYPE_NONE;\n    entity.vPos = vec3(0);\n    entity.fSectorId = SECTOR_NONE;\n    entity.fYaw = 0.0;\n    entity.vVel = vec3(0);\n    entity.fYawVel = 0.0;\n    entity.fPitch = 0.0;\n    entity.fHealth = 0.0;\n    entity.fArmor = 0.0;\n    entity.fTimer = 0.0;\n    entity.fTarget = ENTITY_NONE;\n    entity.fFrameFlags = 0.0;    \n    entity.fUseWeapon = 1.;\n    entity.fHaveShotgun = 0.;\n    entity.fTookDamage = 0.;\n    entity.fEvent = 0.;\n}\n\nEntity Entity_Read( float fEntityId )\n{\n    Entity entity;\n    \n    entity.fId = fEntityId;\n    \n    vec2 vAddress = vec2( fEntityId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vec3 vUnpacked0x = ByteUnpack3( vData0.x ) - 1.;\n    vAddress.y++;\n    \n    \n    entity.fType = vUnpacked0x.x;\n    entity.fSubType = vUnpacked0x.y;\n    entity.fSectorId = vUnpacked0x.z;\n    \n    entity.fFrameFlags = vData0.y;\n    \n    entity.fTarget = vData0.z;\n    entity.fTimer = vData0.w;\n    \n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vPos = vData1.xyz;\n    entity.fYaw = vData1.w;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vVel = vData2.xyz;\n    entity.fYawVel = vData2.w;\n\n    vec4 vData3 = ReadStateData( vAddress );\n    vec2 vUnpacked3x = ByteUnpack2(vData3.x);\n    vec2 vUnpacked3y = ByteUnpack2(vData3.y);\n    vec2 vUnpacked3z = ByteUnpack2(vData3.z) -1.;\n    vAddress.y++;\n    \n    entity.fHealth = vUnpacked3x.x;\n    entity.fArmor = vUnpacked3x.y;\n    float fPackedWeaponInfo = vData3.y;\n    entity.fUseWeapon = vUnpacked3y.x;\n    entity.fHaveShotgun = vUnpacked3y.y;\n    entity.fTookDamage = vUnpacked3z.x;\n    entity.fEvent = vUnpacked3z.y;\n    entity.fPitch = vData3.w;\n    \n    return entity;\n}\n\nvoid Entity_Store( Entity entity, inout vec4 fragColor, in vec2 fragCoord )\n{\n    if ( !Entity_IdValid( entity.fId ) ) \n        return;\n\n    float fPacked0 = BytePack3( vec3(entity.fType, entity.fSubType, entity.fSectorId ) + 1. );\n\n    entity.fHealth = floor( clamp( entity.fHealth, 0.0, 255.0 ) );\n    entity.fArmor = floor( clamp( entity.fArmor, 0.0, 255.0 ) );\n    float fPackedHealthAndArmor = BytePack2( vec2( entity.fHealth, entity.fArmor ) ); \n\tfloat fPackedWeaponInfo = BytePack2( vec2( entity.fUseWeapon, entity.fHaveShotgun ) );\n\tfloat fPackedEvents = BytePack2( vec2( entity.fTookDamage, entity.fEvent ) + 1. );\n    \n    vec2 vAddress = vec2( entity.fId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = vec4( fPacked0, entity.fFrameFlags, entity.fTarget, entity.fTimer );    \n    vec4 vData1 = vec4( entity.vPos, entity.fYaw );\n    vec4 vData2 = vec4( entity.vVel, entity.fYawVel );\n    vec4 vData3 = vec4( fPackedHealthAndArmor, fPackedWeaponInfo, fPackedEvents, entity.fPitch );\n\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData3, fragColor, fragCoord );\n    vAddress.y++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Weapon Defs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define WEAPON_TYPE_PISTOL\t\t0.\n#define WEAPON_TYPE_SHOTGUN\t\t1.\n#define WEAPON_TYPE_FIREBALL\t2.\n\nstruct WeaponDef\n{\n    float fWeaponType;\n    float fReloadTime;\n    float fProjectileCount;\n    float fBaseDamagePerProjectile;\n    float fRandomDamagePerProjectile;\n    float fSpread;\n};\n\nWeaponDef Weapon_GetDef( float fWeaponType, bool bEnemy )\n{\n    WeaponDef weaponDef;\n\n    if ( fWeaponType == WEAPON_TYPE_SHOTGUN )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_SHOTGUN;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = bEnemy ? 3.0 : 7.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = radians(4.0);\n    }\n    else\n    if ( fWeaponType == WEAPON_TYPE_FIREBALL )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_FIREBALL;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = 5.0;\n        weaponDef.fRandomDamagePerProjectile = 0.0;\n        weaponDef.fSpread = radians(0.0);\n    }\n    else\n    {\n        \/\/ Pistol\n        weaponDef.fWeaponType = WEAPON_TYPE_PISTOL;\n        weaponDef.fReloadTime = 0.5;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = bEnemy ? radians(4.0) : 0.0;\n    }\n    \n    return weaponDef;\n}\n    \n#define ENTITY_TYPE_PLAYER \t0.\n\n#define ENTITY_TYPE_BARREL \t1.\n#define ENTITY_SUB_TYPE_BARREL_INACTIVE\t\t\t0.\n#define ENTITY_SUB_TYPE_BARREL_EXPLODING\t\t1.\n#define ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE\t\t2.\n\n#define ENTITY_TYPE_ITEM \t2.\n#define ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS \t0.\n#define ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS \t1.\n#define ENTITY_SUB_TYPE_ITEM_SHOTGUN \t\t2.\n#define ENTITY_SUB_TYPE_ITEM_STIMPACK\t\t3.\n#define ENTITY_SUB_TYPE_ITEM_GREENARMOR\t\t4.\n#define ENTITY_SUB_TYPE_ITEM_BLUEARMOR\t\t5.\n#define ENTITY_SUB_TYPE_ITEM_MEDIKIT\t\t6.\n\n#define ENTITY_TYPE_DECORATION 3.\n#define ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS\t\t\t0.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER\t\t\t1.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT\t\t2.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_IMP\t\t\t\t3.\n#define ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR\t4.\n#define ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP\t\t\t5.\n\n#define ENTITY_TYPE_ENEMY\t4.\n#define ENTITY_SUB_TYPE_ENEMY_TROOPER \t\t0.\n#define ENTITY_SUB_TYPE_ENEMY_IMP \t\t\t1.\n#define ENTITY_SUB_TYPE_ENEMY_SERGEANT \t\t2.\n\n#define ENTITY_TYPE_BULLET 5.\n#define\tENTITY_SUB_TYPE_BULLET_WALL\t\t\t0.\n#define\tENTITY_SUB_TYPE_BULLET_FLESH\t\t1.\n\n#define ENTITY_TYPE_DOOR 6.\n\n#define ENTITY_TYPE_PLATFORM 7.\n\n#define ENTITY_TYPE_FIREBALL 8.\n#define ENTITY_SUB_TYPE_FIREBALL 0.\n#define ENTITY_SUB_TYPE_FIREBALL_IMPACT 1.\n\n\n#define ENTITY_FRAME_FLAG_FIRE_WEAPON\t\t1.\n#define ENTITY_FRAME_FLAG_DROP_ITEM\t\t\t2.\n\n\n#define ENEMY_STATE_IDLE\t\t\t\t0.\n#define ENEMY_STATE_PAIN\t\t\t\t1.\n#define ENEMY_STATE_WALK_RANDOM\t\t\t2.\n#define ENEMY_STATE_WALK_TO_TARGET\t\t3.\n#define ENEMY_STATE_STAND\t\t\t\t4.\n#define ENEMY_STATE_FIRE\t\t\t\t5.\n#define ENEMY_STATE_DIE\t\t\t\t\t6.\n\n\n#define EVENT_HEALTH_BONUS \t1.\n#define EVENT_ARMOR_BONUS \t2.\n#define EVENT_SHOTGUN \t\t3.\n#define EVENT_STIMPACK\t\t4.\n#define EVENT_GREENARMOR\t5.\n#define EVENT_BLUEARMOR\t\t6.\n#define EVENT_MEDIKIT\t\t7.\n#define EVENT_DIED\t\t\t8.\n\n#define MESSAGE_NONE\t\t\t-1.\n#define MESSAGE_HEALTH_BONUS \t0.\n#define MESSAGE_ARMOR_BONUS \t1.\n#define MESSAGE_SHOTGUN \t\t2.\n#define MESSAGE_STIMPACK\t\t3.\n#define MESSAGE_GREENARMOR\t\t4.\n#define MESSAGE_BLUEARMOR\t\t5.\n#define MESSAGE_MEDIKIT\t\t\t6.\n#define MESSAGE_HUD_TEXT\t\t7.\n#define MESSAGE_CHOOSE_SKILL\t8.\n#define MESSAGE_SKILL_1\t\t\t9.\n#define MESSAGE_SKILL_2\t\t\t10.\n#define MESSAGE_SKILL_3\t\t\t11.\n#define MESSAGE_SKILL_4\t\t\t12.\n#define MESSAGE_SKILL_5\t\t\t13.\n#define MESSAGE_HANGAR\t\t\t14.\n#define MESSAGE_FINISHED\t\t15.\n#define MESSAGE_KILLS\t\t\t16.\n#define MESSAGE_ITEMS\t\t\t17.\n#define MESSAGE_SECRET\t\t\t18.\n#define MESSAGE_TIME\t\t\t19.\n#define MESSAGE_SELECT\t\t\t20.\n#define MESSAGE_COUNT\t\t\t21.\n\n\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\nMapInfo g_mapInfo;\nGameState g_gameState;\n\nstruct Controls\n{\n    bool menuConfirm;\n    bool menuUp;\n    bool menuDown;\n    \n    bool moveForwards;\n    bool moveBackwards;\n    bool moveLeft;\n    bool moveRight;\n    bool fire;\n\n    bool turnLeft;\n    bool turnRight;\n\n    bool run;\n    bool strafe;\n    bool open;    \n    \n    bool weap_2;\n    bool weap_3;\n    \n    bool toggleMouseLook;\n    bool toggleInvertY;\n};\n    \nControls g_controls;\n\nControls ReadControls()\n{\n    Controls controls;\n    \n    bool bArrowUp = Key_IsPressed( KEY_UP );\n    bool bArrowDown = Key_IsPressed( KEY_DOWN );\n    bool bSpace = Key_IsPressed( KEY_SPACE );        \n    bool bEnter = Key_IsPressed( KEY_ENTER );        \n    \n    controls.moveForwards = \t\tKey_IsPressed( KEY_W ) || bArrowUp;\n    controls.moveBackwards = \t\tKey_IsPressed( KEY_S ) || bArrowDown;\n    controls.moveLeft = \t\t\tKey_IsPressed( KEY_A );\n    controls.moveRight = \t\t\tKey_IsPressed( KEY_D );\n    controls.fire = \t\t\t\tbSpace;\n\n    controls.turnLeft = \t\t\tKey_IsPressed( KEY_LEFT );\n    controls.turnRight = \t\t\tKey_IsPressed( KEY_RIGHT );\n\n    controls.run = \t\t\t\t\tKey_IsPressed( KEY_SHIFT );\n    controls.strafe = \t\t\t\tKey_IsPressed( KEY_ALT );        \n    controls.open = \t\t\t\tbEnter || Key_IsPressed( KEY_F );\n    \n    controls.weap_2 = \t\t\t\tKey_IsPressed( KEY_2 );\n    controls.weap_3 = \t\t\t\tKey_IsPressed( KEY_3 );        \n    \n    controls.toggleMouseLook = \t\tKey_IsToggled( KEY_L );\n    controls.toggleInvertY = \t\tKey_IsToggled( KEY_I );\n    \n    controls.menuConfirm = \t\t\tbSpace || bEnter;\n    controls.menuUp = \t\t\t\tbArrowUp;\n    controls.menuDown = \t\t\tbArrowDown;\n    \n    return controls;\n}\n    \n\nvoid Entity_MapSpawn( inout Entity entity, float fSpawnIndex )\n{   \n    Entity_Clear( entity );\n    \n    vec4 vData0 = ReadMapData( vec2(128., fSpawnIndex) );\n    vec4 vData1 = ReadMapData( vec2(129., fSpawnIndex) );\n    \n    if ( dot(vData0.zw, vData0.zw) > 0.0 )\n    {\n        entity.fType = vData0.x;\n        entity.fSubType = vData0.y;\n        entity.vPos.xz = vData0.zw;\n        entity.vPos.y = 0.0;\n        entity.fYaw = radians( 90. - vData1.x );\n\n        entity.fSectorId = Map_SeekSector( g_mapInfo, entity.vPos.xz );    \n\n        Sector sector = Map_ReadSector( entity.fSectorId );\n\n        entity.vPos.y = sector.fFloorHeight;\n        \n        if ( entity.fType == ENTITY_TYPE_PLAYER )\n        {\n            entity.fHealth = 100.0;\n        }\n        if ( entity.fType == ENTITY_TYPE_ENEMY )\n        {\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )\n            {\n\t            entity.fHealth = 20.0;\n            }\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n            {\n\t            entity.fHealth = 30.0;\n            }\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_IMP )\n            {\n\t            entity.fHealth = 60.0;\n            }\n        }\n        if ( entity.fType == ENTITY_TYPE_BARREL )\n        {\n            entity.fHealth = 20.0;\n        }        \n        if ( entity.fType == ENTITY_TYPE_DOOR )\n        {        \n\t        entity.fTarget = sector.fFloorHeight;\n        }\n        if ( entity.fType == ENTITY_TYPE_PLATFORM )\n        {        \n            entity.vPos.y = sector.fFloorHeight;\n            entity.vPos.xz = vData1.zw; \/\/ trigger location\n\t        entity.fTarget = sector.fFloorHeight;\n        }\n    }\n    else\n    {\n        entity.fType = ENTITY_TYPE_NONE;\n    }\n}\n\nvoid Entity_Fall( inout Entity entity, float fTimestep )\n{\n    if ( Map_ValidSectorId( g_mapInfo, entity.fSectorId ) )\n    {\n        Sector sector = Map_ReadSector( entity.fSectorId );    \t\n        float a = -800.;\n        entity.vPos.y += entity.vVel.y * fTimestep + .5 * a * fTimestep * fTimestep;\n        entity.vVel.y += a * fTimestep;\n        if ( entity.vPos.y < sector.fFloorHeight )\n        {\n            entity.vPos.y = sector.fFloorHeight;\n            entity.vVel.y = 0.0;\n        }\n    }\n    else\n    {\n        entity.vVel.y = 0.0;\n    }\n}\n\n\nvoid SlideVector( inout float fSectorId, inout vec2 vPos, inout vec2 vVel, float fYPos, float fYPos2, float fDropOff )\n{       \n\tbool bReevaluate = false;\n    \n    float fInitialSector = fSectorId;\n    \n    \/\/ maximum number of sector traversal \/ wall collisions\n    for (int iIter=0; iIter<8; iIter++ )\n    {\n\t    bReevaluate = false;\n\n        float fVelLength = length( vVel );\n        if ( length( vVel ) <= 0.0 )\n        {\n            break;\n        }\n\n        vec2 vVelDir = normalize( vVel );\n\n        Sector sector = Map_ReadSector( fSectorId );\n\n        for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n        {\n            float fSideDefIndex = float(iSideDefIndex);\n\n            SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n\n            if ( sideDef.fLength <= 0.0)\n            {\n                break;\n            }\n\n            vec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vPos, vVelDir );\n\n            float fHitT = vHitTUD.x;\n            float fHitU = vHitTUD.y;\n            float fDenom = vHitTUD.z;        \n\n\t\t\t\/\/ Only consider cases when we are leaving sector\n            if ( fDenom < 0.0 )\n            {        \n                if ( fHitT > 0.0 && fHitT < fVelLength )\n                {\n                    if ( fHitU > 0.0 && fHitU < 1.0 )\n                    {\n                        \/\/ We hit a sidedef\n\n                        bool bSolid = true;\n                        bReevaluate = true;\n                        \n                        if ( sideDef.fNextSector != SECTOR_NONE )\n                        {\n#ifdef CHEAT_NOCLIP                            \n                            {   {   {\n#else \/\/ #ifdef CHEAT_NOCLIP                                \n                            \/\/ blocking flag\n                            if ( mod( floor(sideDef.fFlags \/ 2.), 2. ) == 0. )\n                            {\n                                \/\/ Check heights of next sector\n                                Sector nextSector = Map_ReadSector( sideDef.fNextSector );                            \n                                if( ( fYPos > nextSector.fFloorHeight && fYPos < nextSector.fCeilingHeight ) && \n                                    ( fYPos2 > nextSector.fFloorHeight && fYPos2 < nextSector.fCeilingHeight ) )\n                                {\n                                    \/\/ Check DropOff (enemies are blocked from walking over ledges higher than this)\n                                    if ( nextSector.fFloorHeight >= (sector.fFloorHeight - fDropOff) )\n                                    {\n#endif \/\/ #ifdef CHEAT_NOCLIP                            \n                                        \/\/ Consider next sector\n                                        bSolid = false;\n                                        fSectorId = sideDef.fNextSector;                                    \n                                    }\n                                }\n                            }\n                        }\n                        \n                        \n                        \/\/if (false)\n                        if ( bSolid )\n                        {\n                            \/\/vVel *= 0.0;\n                            \/\/break;\n\n                            \/\/ Apply the sliding constraint\n                            vec2 vAB = sideDef.vB - sideDef.vA;\n                            vec2 vNormal = normalize( vec2( -vAB.y, vAB.x ) );\n\n                            float fDot = dot( vVel, vNormal );\n                            vVel -= vNormal * fDot;\n                            vVel -= vNormal * 0.2;\n                            \n                            \/\/ Velocity updated, begin testing from initial sector\n                            fSectorId = fInitialSector;\n                        }    \n                        \n                        break;                    \n                    }\n                }\n            }                \n        }        \n\n        if ( !bReevaluate )\n        {\n            break;\n        }\n    }\n    \n    if (!bReevaluate)\n    {\n    \tvPos += vVel;    \n    }\n    else\n    {\n        vVel = vec2(0);\n    }\n}\n            \nvoid Entity_UpdateSlideBox( inout Entity entity, float fTimestep )\n{\n    entity.fYaw += entity.fYawVel * fTimestep;\n\n    const float fStepHeight = 24.1; \/\/ https:\/\/www.doomworld.com\/vb\/doom-general\/67054-maximum-height-monsters-can-step-on\/\n    const float fClearanceHeight = 32.;\n    \n    float fDropOff = 10000.0;\n    if ( entity.fType == ENTITY_TYPE_ENEMY )\n    {\n        \/\/ Enemies \n        fDropOff = 24.0;\n    }\n    entity.vVel.xz *= fTimestep;\n    SlideVector( entity.fSectorId, entity.vPos.xz, entity.vVel.xz, entity.vPos.y + fStepHeight, entity.vPos.y + fClearanceHeight, fDropOff );\n    entity.vVel.xz \/= fTimestep;\n}\n\nfloat Entity_GetWeaponType( Entity entity )\n{\n    if ( entity.fType == ENTITY_TYPE_PLAYER )\n    {\n        \/\/return WEAPON_TYPE_FIREBALL;\n        if ( entity.fUseWeapon == 1. )\n        {\n        \treturn WEAPON_TYPE_PISTOL;\n        }\n        else\n        {\n    \t\treturn WEAPON_TYPE_SHOTGUN;\n        }\n    }\n    else\n    if ( entity.fType == ENTITY_TYPE_ENEMY )\n    {\n        if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )\n        {\n            return WEAPON_TYPE_PISTOL;        \n        }\n        else if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n        {\n            return WEAPON_TYPE_SHOTGUN;        \n        }\n        else if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_IMP )\n        {\n            return WEAPON_TYPE_FIREBALL;        \n        }        \n    }\n\n    return WEAPON_TYPE_PISTOL;\n}\n\nWeaponDef Entity_GetWeaponDef( Entity entity )\n{\n    return Weapon_GetDef( Entity_GetWeaponType( entity ), entity.fType == ENTITY_TYPE_ENEMY );\n}\n    \n    \nfloat Enemy_GetState( Entity entity )\n{\n    return entity.fArmor;\n}\n\nvoid Enemy_SetState( inout Entity entity, float fNewState )\n{\n    if ( entity.fArmor == ENEMY_STATE_DIE )\n    {\n        return;\n    }\n    \n    entity.fArmor = fNewState;\n    \n    bool setRandomTimer = false;\n    \n    if ( fNewState == ENEMY_STATE_PAIN )\n    {\n        entity.fTimer = 0.2;    \n    }\n    else\n    if ( fNewState == ENEMY_STATE_DIE )\n    {\n        SetFlag( entity.fFrameFlags, ENTITY_FRAME_FLAG_DROP_ITEM );\n        entity.fTimer = 0.4;    \n    }\n    else\n#ifdef CHEAT_NOAI \n    {\n    \tentity.fArmor = ENEMY_STATE_STAND;        \n        entity.fTimer = 0.4;    \n    }\n#else        \n    if ( fNewState == ENEMY_STATE_FIRE )\n    {\n        SetFlag( entity.fFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON );\n        entity.fTimer = 0.3;    \n    }\n    else\n    if ( fNewState == ENEMY_STATE_WALK_RANDOM )\n    {\n    \tfloat fRandom = Hash( entity.fId + iGlobalTime + 3.456 );        \n        \n        entity.fYaw = fRandom * 3.14 * 2.0;\n\n        float fStepScale = 3.14 \/ 4.0;\n        entity.fYaw = floor( entity.fYaw \/ fStepScale ) * fStepScale;\n        \n        setRandomTimer = true;\n    }\n    else\n    if ( fNewState == ENEMY_STATE_WALK_TO_TARGET )\n    {\n        Entity targetEnt = Entity_Read( entity.fTarget );\n        vec3 vToTarget = targetEnt.vPos - entity.vPos;\n        entity.fYaw = atan(vToTarget.x, vToTarget.z);\n        \n        float fStepScale = 3.14 \/ 4.0;\n        entity.fYaw = floor( entity.fYaw \/ fStepScale ) * fStepScale;\n        \n        setRandomTimer = true;\n    }\n    else\n    {\n        setRandomTimer = true;\n    }    \n\n    if ( setRandomTimer )\n    {\n    \tfloat fRandom = Hash( entity.fId + iGlobalTime + 0.1 );        \n        entity.fTimer = 0.5 + fRandom * fRandom * 1.5;\n    }\n#endif \/\/ #ifndef CHEAT_NOAI        \n}\n\nvoid Enemy_SetRandomHostileState( inout Entity entity, bool notFire )\n{\n    float fRandom = Hash( entity.fId + iGlobalTime );\n    \n    if ( fRandom < 0.333 )\n    {\n        Entity targetEnt = Entity_Read( entity.fTarget );\n        vec3 vToTarget = targetEnt.vPos - entity.vPos;\n        \n        if ( length( vToTarget ) < 100.0 )\n        {\n        \tEnemy_SetState( entity, ENEMY_STATE_WALK_RANDOM );\n        }\n        else\n        {\n        \tEnemy_SetState( entity, ENEMY_STATE_WALK_TO_TARGET );\n\t\t}\n    }\n    else\n    if ( fRandom < 0.666 )\n    {        \n        if ( notFire )\n        {\n        \tEnemy_SetState( entity, ENEMY_STATE_STAND );                    \n        }\n        else\n        {\n\t        Enemy_SetState( entity, ENEMY_STATE_FIRE );        \n        }\n\t}\n    else\n    {        \n        Enemy_SetState( entity, ENEMY_STATE_STAND );        \n\t}\n}\n\nbool Entity_CanHear( Entity entityA, Entity entityB )\n{\n    \/\/ Simple distance check for now...\n    \/\/ Could do sector coloring somehow?\n    if ( length( entityA.vPos - entityB.vPos ) < 400.0 ) \n    {\n        return true;\n    }\n    return false;\n}\n\nbool Entity_CanSee( Entity entityA, Entity entityB )\n{\n    vec3 vRayStart = entityA.vPos + vec3(0,32,0);\n    vec3 vRayEnd = entityB.vPos + vec3(0,32,0);            \n    vec3 vRayDir = normalize( vRayEnd - vRayStart );\n    float fDistToTarget = distance( vRayStart, vRayEnd );\n\tTraceResult traceResult = Map_Trace( g_mapInfo, vRayStart, vRayDir, entityA.fSectorId, fDistToTarget );\n    return traceResult.fDist >= fDistToTarget;\n}\n\nbool Enemy_CanSee( Entity enemy, Entity target )\n{\n    vec3 vTargetPos = target.vPos;\n    vec3 vToTarget = vTargetPos - enemy.vPos;\n    float fAng = degrees( atan( vToTarget.x, vToTarget.z ) );\n\n    if ( abs( fAng ) < 45.0 )\n    {\n        \/\/ Line of sight check\n\n        if ( Entity_CanSee( enemy, target ) )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid Enemy_UpdateState(  inout Entity entity )\n{\n    float fState = Enemy_GetState( entity );\n    \n    if( entity.fHealth <= 0.0 )\n    {\n        Enemy_SetState( entity, ENEMY_STATE_DIE );\n        fState = ENEMY_STATE_DIE;\n    }\n\n    if ( fState == ENEMY_STATE_DIE )\n    {\n        if ( entity.fTimer == 0. )\n        {            \n            entity.fType = ENTITY_TYPE_DECORATION;\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_TROOPER )\n            {\n            \tentity.fSubType = ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER;\n    \t\t}\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n            {\n            \tentity.fSubType = ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT;\n    \t\t}\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ENEMY_IMP )\n            {\n            \tentity.fSubType = ENTITY_SUB_TYPE_DECORATION_DEAD_IMP;\n    \t\t}\n            else\n            {\n            \tentity.fSubType = ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS;            \n            }\n        }\n        \n        return;\n    }    \n     \n    \/\/ Check if can see player    \n    if ( entity.fTarget == ENTITY_NONE )\n    {        \n\t\tEntity playerEnt = Entity_Read( 0. );\n        \n        bool wakeUp = false;\n\n        if ( Enemy_CanSee( entity, playerEnt ) )\n        {\n\t\t\twakeUp = true;\n        }   \n\n        \/\/ Wake if player firing weapon\n        if ( !wakeUp )\n        {\n        \tif ( FlagSet( playerEnt.fFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON ) )\n            {\n                if ( Entity_CanHear( entity, playerEnt ) )\n                {\n\t                wakeUp  = true;\n\t\t\t\t}\n            }            \n        }\n\n        if ( wakeUp )\n        {\n            \/\/ target player \n            entity.fTarget = 0.;\n        \tEnemy_SetState( entity, ENEMY_STATE_STAND );\n            fState = ENEMY_STATE_STAND;            \n        }\n    }\n    \n    \n    if ( fState == ENEMY_STATE_IDLE )\n    {\n    }\n\telse\n    if ( fState == ENEMY_STATE_PAIN )\n    {\n        if ( entity.fTimer == 0. )\n        {\n            Enemy_SetState( entity, ENEMY_STATE_STAND );\n        }\n    }\n\telse\n    if ( \tfState == ENEMY_STATE_STAND ||\n        \tfState == ENEMY_STATE_FIRE ||\n        \tfState == ENEMY_STATE_WALK_TO_TARGET ||\n        \tfState == ENEMY_STATE_WALK_RANDOM\n       )\n    {\n        if ( entity.fTarget != ENTITY_NONE )\n        {\n            Entity targetEnt = Entity_Read( entity.fTarget );\n\n            if ( targetEnt.fHealth <= 0.0 )\n            {\n                entity.fTarget = ENTITY_NONE;\n                Enemy_SetState( entity, ENEMY_STATE_IDLE );\n            }\n        }\n        \n        if ( entity.fTimer == 0. )\n        {\n            if ( fState == ENEMY_STATE_FIRE )\n            {\n\t            Enemy_SetRandomHostileState( entity, true );\n            }\n            else\n            {\n\t            Enemy_SetRandomHostileState( entity, false );\n            }                \n        }\n    }        \n}\n\nbool Entity_IsAlivePlayer( Entity entity )\n{\n    if ( entity.fType == ENTITY_TYPE_PLAYER )\n    {\n        if ( entity.fHealth > 0.0 )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nbool Entity_CanReceiveDamage( Entity entity )\n{\n    if ( entity.fType == ENTITY_TYPE_BARREL )\n        return true;\n    \n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n#ifdef CHEAT_GOD        \n        return false;\n#else\n        return true;\n#endif    \n    }\n    \n    if ( entity.fType == ENTITY_TYPE_ENEMY )\n    {\n        if ( Enemy_GetState(entity) == ENEMY_STATE_DIE )\n        {\n            return false;\n        }\n        \n        return true;\n    }\n    \n    return false;\n}\n\nvoid Entity_ApplyDamage( inout Entity entity, float fAmount, float fSourceId )\n{\n    if ( !Entity_CanReceiveDamage( entity ) )\n    {\n        return;\n    }\n    \n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n        entity.fTookDamage += fAmount;\n        if ( entity.fHealth - fAmount <= 0.0 )\n        {\n            entity.fTimer = 1.5;\n            entity.fEvent = EVENT_DIED;\n        }\n    } \n    \n    float fArmorAbsorb = 0.;\n    \n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n        fArmorAbsorb = min( fAmount, entity.fArmor );\n        entity.fArmor -= fArmorAbsorb;\n        fArmorAbsorb *= 0.25; \/\/ always absorb 25% (ignore special rules about blue armor)\n    }\n    \n    entity.fHealth -= (fAmount - fArmorAbsorb);\n    \n    Entity source = Entity_Read( fSourceId );\n\n    if ( fSourceId != ENTITY_NONE )\n    {\n\t    entity.vVel.xz += normalize( entity.vPos.xz - source.vPos.xz ) * fAmount;\n    }\n\n    if ( entity.fType == ENTITY_TYPE_ENEMY )\n    {\n        if ( fSourceId != ENTITY_NONE )\n        {\n            if ( (source.fType == ENTITY_TYPE_ENEMY && entity.fSubType != source.fSubType)\n                || source.fType == ENTITY_TYPE_PLAYER )\n            {\n                \/\/ We are now riled with the attacker\n                entity.fTarget = fSourceId;\n            }\n        }\n        Enemy_SetState( entity, ENEMY_STATE_PAIN );\n    }                           \n}\n\nbool Entity_IsPlayerTarget( Entity entity )\n{\n    if ( \tentity.fType == ENTITY_TYPE_PLAYER ||\n       \t \tentity.fType == ENTITY_TYPE_BARREL || \n       \t\tentity.fType == ENTITY_TYPE_ENEMY )\n    {\n        return true;\n    }\n    \n    return false;\n}\n\nvoid Player_SelectTarget( inout Entity playerEnt )\n{\n    \/\/ Select target entity (used to aim shots up \/ down)\n    float fBiggestDot = cos( radians( 4.0 ) );\n    \n    float fClosest = FAR_CLIP;\n    \n    playerEnt.fTarget = ENTITY_NONE;\n    \n    vec2 vPlayerForwards = vec2( sin( playerEnt.fYaw ), cos( playerEnt.fYaw ) );\n    \n    for ( int iOtherEntityIndex=0; iOtherEntityIndex<int(ENTITY_MAX_COUNT); iOtherEntityIndex++ )\n    {\n        float fOtherEntityIndex = float(iOtherEntityIndex);\n        Entity otherEntity = Entity_Read( fOtherEntityIndex );\n\n        if ( Entity_IsPlayerTarget( otherEntity ) )\n        {\n            vec3 vToTarget = otherEntity.vPos - playerEnt.vPos;\n            \n            float fDist = length( vToTarget.xz );\n            \n            if ( fDist < fClosest ) \n            {\n                vec2 vDirToTarget = normalize( vToTarget.xz );\n                float fDot = dot( vDirToTarget, vPlayerForwards );\n                \n                if ( fDot > fBiggestDot )\n                {\n                    fClosest = fDist;\n                    playerEnt.fTarget = fOtherEntityIndex;\n                }\n            }\n        }        \n    }    \n}\n\nvoid Entity_Think( inout Entity entity, float fTimestep )\n{\n    entity.fTimer = max( 0.0, entity.fTimer - fTimestep );    \n\n    float fMaxAccel = 1000.0;    \n    vec2 vIdealVel = vec2(0);\n    \n    bool bUseVelSteer = false;\n    \n    if ( entity.fType == ENTITY_TYPE_PLAYER )\n    {        \n        bUseVelSteer = true;\n                \n        if( entity.fHealth > 0.0 )\n        {\n            vec2 vDir = vec2(0.0);\n\n\n\n            if ( g_controls.moveForwards )\n            {\n                vDir.y += 1.0;\n            }\n            if ( g_controls.moveBackwards )\n            {\n                vDir.y -= 1.0;\n            }\n            if (g_controls.moveLeft || (g_controls.turnLeft && g_controls.strafe))\n            {\n                vDir.x -= 1.0;\n            }\n            if (g_controls.moveRight || (g_controls.turnRight && g_controls.strafe))\n            {\n                vDir.x += 1.0;\n            }\n\n            float fspeed = g_controls.run ? 250.0 : 150.0;\n            fMaxAccel = g_controls.run ? 2000.0 : 1000.0; \n            float fMaxYawVelAccel = g_controls.run ? 50.0 : 30.0;\n            float fTurnspeed = g_controls.run ? 3.5 : 1.5;\n\n            vDir *= fspeed;\n\n            vIdealVel.x = vDir.x * cos( entity.fYaw ) + vDir.y * sin( entity.fYaw );\n            vIdealVel.y = vDir.x * -sin( entity.fYaw ) + vDir.y * cos( entity.fYaw );\n\n            float fMouseSpeed = 1.0 \/ 180.0;\n            \n            vec2 vMouseDelta = (iMouse.xy - g_gameState.vPrevMouse.xy) * fMouseSpeed;\n            vec2 vMouseSign = sign(vMouseDelta);\n            vec2 vMouseAbs = abs(vMouseDelta);\n            vMouseAbs = pow( vMouseAbs, vec2(1.5));\n            vMouseDelta = vMouseAbs * vMouseSign;\n            if ( iMouse.z > 0.0 && g_gameState.vPrevMouse.z > 0.0 )\n            {\n            \tentity.fYaw += (vMouseDelta.x);\n                \n                if ( g_controls.toggleMouseLook )\n                {\n                    float fPitchInvert = g_controls.toggleInvertY ? -1.0 : 1.0;\n                    \n                \tentity.fPitch += (vMouseDelta.y) * fPitchInvert;\n                }\n                else\n                {\n                \tentity.fPitch = 0.0;\n                }\n                float fMaxPitch = radians(89.0);\n                entity.fPitch = clamp( entity.fPitch, -fMaxPitch, fMaxPitch);\n            }\n            \n            float fIdealYawVel = 0.0;\n\n            if ( g_controls.turnLeft && !g_controls.strafe )\n            {\n                fIdealYawVel -= 1.0;\n            }\n            if ( g_controls.turnRight && !g_controls.strafe )\n            {\n                fIdealYawVel += 1.0;\n            }\n\n            fIdealYawVel *= fTurnspeed;\n\n            float fToIdealYawVel = fIdealYawVel - entity.fYawVel;\n            entity.fYawVel += clamp( fToIdealYawVel, -fMaxYawVelAccel * fTimestep, fMaxYawVelAccel * fTimestep );        \n            \n            \/\/ Change weapon\n            {\n\t\t\t\tif ( g_controls.weap_2 )\n                {\n                    entity.fUseWeapon = 1.;\n                }\n                \n\t\t\t\tif ( g_controls.weap_3 )\n                {\n                    if ( entity.fHaveShotgun > 0. )\n                    {\n                    \tentity.fUseWeapon = 2.;\n                    }\n                }\n            }\n            \n            \n            \/\/ Fire weapon\n            if ( g_controls.fire )\n            {\n                if ( entity.fTimer == 0.0 )\n                {\n                    SetFlag( entity.fFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON );\n\n                    WeaponDef weaponDef = Entity_GetWeaponDef( entity );\n\n                    \/\/ reload time\n                    entity.fTimer = weaponDef.fReloadTime;\n                    \n                    Player_SelectTarget( entity );\n                }\n            }\n            \n            \/\/ Apply Nukage damage\n\t        #define TEX_NUKAGE 2.0\n            Sector sector = Map_ReadSector( entity.fSectorId );\n            if ( sector.fFloorTexture == TEX_NUKAGE )\n            {\n                float fCurrTime = g_gameState.fGameTime;\n                float fNextTime = fCurrTime + fTimestep;\n                \/\/ apply damage every second\n                if ( floor( fCurrTime ) != floor( fNextTime ) )\n                {\n                    \/\/ 5 damage per second\n                \tEntity_ApplyDamage( entity, 5.0, ENTITY_NONE );\n                }\n            }                           \n        }\n        else\n        {\n            entity.fYawVel *= pow( 0.3, fTimestep );\n        }\n    }    \n    else if ( entity.fType == ENTITY_TYPE_ENEMY )\n    {\n        bUseVelSteer = true;\n        fMaxAccel = 50.;\n        \n        Enemy_UpdateState( entity );\n        \n        float fState = Enemy_GetState( entity );\n        \n        if ( fState == ENEMY_STATE_FIRE )\n        {\n            Entity targetEnt = Entity_Read( entity.fTarget );\n            vec3 vToTarget = targetEnt.vPos - entity.vPos;\n            entity.fYaw = atan(vToTarget.x, vToTarget.z);\n        }\n        \n        if ( fState == ENEMY_STATE_WALK_TO_TARGET || fState == ENEMY_STATE_WALK_RANDOM )\n        {\n            float fWalkSpeed = 50.;\n            vIdealVel.x = sin( entity.fYaw ) * fWalkSpeed;\n            vIdealVel.y = cos( entity.fYaw ) * fWalkSpeed;\n        }     \n    }    \n    else if ( entity.fType == ENTITY_TYPE_BARREL )\n    {\n        entity.vVel *= pow( 0.3, fTimestep );\n        \n        if( entity.fHealth <= 0.0 )\n        {\n            if ( entity.fSubType == ENTITY_SUB_TYPE_BARREL_INACTIVE )\n            {\n                entity.fSubType = ENTITY_SUB_TYPE_BARREL_EXPLODING;\n                entity.fTimer = 1.0;\n            }\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_BARREL_EXPLODING )\n            {\n                if ( entity.fTimer <= 0.0 )\n                {\n\t                entity.fSubType = ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE;\n                }\n            }\n            else\n            {\n\t\t\t\tEntity_Clear( entity );                                    \n            }\n        }        \n    }    \n    else if ( entity.fType == ENTITY_TYPE_BULLET )\n    {\n        entity.fTarget = -1.; \/\/ Clear target (only deal damage for first frame)\n        if ( entity.fTimer <= 0.0 )\n        {\n            Entity_Clear( entity );\n        }\n    }\n    else if ( entity.fType == ENTITY_TYPE_FIREBALL )\n    {\n        if ( entity.fTimer <= 0.0 )\n        {\n            Entity_Clear( entity );\n        }\n    }\n    else if ( entity.fType == ENTITY_TYPE_DOOR )\n    {        \n        Entity playerEnt = Entity_Read( 0. );\n        \n        bool bPlayerNearby = (distance(entity.vPos.xz, playerEnt.vPos.xz) < 100. );\n        bool bTrigger = g_controls.open && bPlayerNearby;\n        \n        float fOpenDist = entity.fTarget - entity.vPos.y;\n        \n        \/\/ Door state machine\n        if ( entity.fSubType == 0. )\n        {\n\t        \/\/ Closed        \n            if ( bTrigger )\n            {\n                entity.fSubType = 1.;\n            }\n        }\n        else\n        if ( entity.fSubType == 1. )\n        {\n\t        \/\/ Opening\n            fOpenDist += 40.0 * fTimestep;\n            \n            if ( fOpenDist >= 80.0 )\n            {\n                fOpenDist = 80.0;\n                entity.fSubType = 2.;\n                \n                entity.fTimer = 5.;\n            }\n        }\n        else\n        if ( entity.fSubType == 2. )\n        {\n\t        \/\/ Open\n            if ( bTrigger || entity.fTimer == 0.0 )\n            {\n                entity.fSubType = 3.;\n            }\n        }\n        else\n        if ( entity.fSubType == 3. )\n        {\n\t        \/\/ Closing\n            fOpenDist -= 40.0 * fTimestep;\n            \n            if ( fOpenDist <= 0.0 )\n            {\n                fOpenDist = 0.0;\n                entity.fSubType = 0.;\n            }\n            \n            if ( bTrigger )\n            {\n                entity.fSubType = 1.;\n            }            \n        }\n        \n        entity.fTarget = fOpenDist + entity.vPos.y;        \n    }\n    else\n    if ( entity.fType == ENTITY_TYPE_PLATFORM )\n    {\n        Entity playerEnt = Entity_Read( 0. );\n        \n        bool bPlayerNearby = (distance(entity.vPos.xz, playerEnt.vPos.xz) < 150. );\n        \n        float fOpenDist = entity.fTarget;\n        \/\/ Hack - params from spawn data yaw\n        float fSpawnYaw = 90. - degrees(entity.fYaw);\n        float fMoveSpeed = abs(fSpawnYaw);\n        bool bStaysLowered = fSpawnYaw < 0.0;\n        \n        \/\/ Hack - both platforms on this level go to this height\n        float fFinalFloorHeight = -48.;\n        \n        if ( entity.fSubType == 0. )\n        {\n            \/\/ Platform is Up\n            \n            if ( bPlayerNearby )\n            {\n                entity.fSubType = 1.;\n            }\n        }\n        else if ( entity.fSubType == 1. )\n        {\n            \/\/ Platform is Lowering\n            fOpenDist -= fMoveSpeed * fTimestep;\n            \n            if ( fOpenDist < fFinalFloorHeight )\n            {\n                fOpenDist = fFinalFloorHeight;\n                entity.fSubType = 2.;\n                \n                entity.fTimer = 5.;\n            }            \n        }\n        else if ( entity.fSubType == 2. )\n        {\n            \/\/ Platform is Down\n            if ( !bStaysLowered )\n            {\n                if ( entity.fTimer == 0.0 )\n                {\n                    entity.fSubType = 3.;\n                }            \n            }\n        }\n        else if ( entity.fSubType == 3. )\n        {\n            \/\/ Platform is Raising\n            fOpenDist += fMoveSpeed * fTimestep;\n            \n            if ( fOpenDist > entity.vPos.y )\n            {\n                fOpenDist = entity.vPos.y;\n                entity.fSubType = 0.;\n            }            \n        }\n        \n        entity.fTarget = fOpenDist;\n        \n        \/\/entity.fTarget = sin( iGlobalTime ) * 100.0;\n    }\n    \n    if ( bUseVelSteer )\n    {\n        vec2 vToIdealVel = vIdealVel - entity.vVel.xz;\n        float len = length( vToIdealVel );\n\n        if ( len > 0.0 )\n        {\n            entity.vVel.xz += normalize(vToIdealVel) * clamp( len, 0.0, fMaxAccel * fTimestep );\n        }        \n    }\n}\n\nbool CanBePushed( Entity entity, Entity otherEntity )\n{\n    if ( Entity_IsAlivePlayer( entity ) )\n    {\n        if ( (otherEntity.fType == ENTITY_TYPE_ENEMY && Enemy_GetState( otherEntity ) != ENEMY_STATE_DIE ) ||\n             (otherEntity.fType == ENTITY_TYPE_BARREL) ||\n             (otherEntity.fType == ENTITY_TYPE_DECORATION && otherEntity.fSubType == ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP)\n           )\n        {\n            return true;\n        }\n    }\n    else if ( entity.fType == ENTITY_TYPE_ENEMY )\n    {\n        if (    (otherEntity.fType == ENTITY_TYPE_ENEMY)\n             || (otherEntity.fType == ENTITY_TYPE_BARREL)\n             \/\/|| (otherEntity.fType == ENTITY_TYPE_PLAYER)\n           )\n        {\n            return true;\n        }\n    }\n    \n    return false;\n}\n\nvoid Entity_Collide( inout Entity entity, Entity otherEntity, float fTimestep )\n{\n    \/\/ True if we can be pushed\n    if ( CanBePushed( entity, otherEntity ) )\n    {\n        vec2 vDeltaPos = entity.vPos.xz - otherEntity.vPos.xz;\n        vec2 vDeltaVel = entity.vVel.xz - otherEntity.vVel.xz;\n\n        float fLen = length( vDeltaPos );\n        float fVelLen = length(vDeltaVel);\n        float fCombinedRadius = 20.0;\n        if ( fLen > 0.0 && fLen < fCombinedRadius )\n        {\n            vec2 vNormal = normalize(vDeltaPos);\n            \n            if ( fVelLen > 0.0 )\n            {\n                float fProj = dot( vNormal, vDeltaVel );\n\n                if ( fProj < 0.0 )\n                {\n                    \/\/ cancel vel in normal dir\n                    vec2 vImpulse = -fProj * vNormal;\n                    \n                    \/\/ Push away\n                    float fPenetration = fCombinedRadius - fLen;\n                    vImpulse += vNormal * fPenetration * 5.0 * fTimestep;\n                    \n                    \n\t\t\t\t    if ( CanBePushed( otherEntity, entity ) )\n                    {\n                    \tentity.vVel.xz += vImpulse * 0.5;\n                    }\n                    else\n                    {\n                    \tentity.vVel.xz += vImpulse;\n                    }\n                }\n            }            \n        }        \n    }    \n}\n\nvoid Player_GiveHealth( inout Entity entity, float fAmount, bool mega )\n{    \n    if ( mega )\n    {\n\t    entity.fHealth = min( entity.fHealth + fAmount, 200.0 );\n    }\n    else\n    {\n        if ( entity.fHealth < 100.0 )\n        {\n\t\t    entity.fHealth = min( entity.fHealth + fAmount, 100.0 );\n        }\n\t}\n}\n\nvoid Player_GiveArmor( inout Entity entity, float fAmount, bool mega )\n{\n    if ( mega )\n    {\n\t    entity.fArmor = min( entity.fArmor + fAmount, 200.0 );\n    }\n    else\n    {\n        if ( entity.fArmor < 100.0 )\n        {\n\t\t    entity.fArmor = min( entity.fArmor + fAmount, 100.0 );\n        }\n\t}\n\n}\n\n#define PICKUP_RADIUS 25.\n\nbool Fireball_Hit( Entity fireball, Entity other )\n{\n    if ( fireball.fSubType == ENTITY_SUB_TYPE_FIREBALL  )\n    {\n        if ( other.fId != fireball.fArmor )\n        {                    \t\n            if ( Entity_CanReceiveDamage( other ) )\n            {\n                if ( length( other.vPos.xz - fireball.vPos.xz ) < (12. + 16.0) )\n                {\n                \treturn true;\n                }\n            }\n        }\n    }\n    \n    return false;\n}\n            \nvoid Entity_Interact( inout Entity entity, float fTimestep )\n{    \n    \/\/ Apply actions to this entity based on every other entity\n    \n    float fSpawnQueueSlot = 0.0;\n    \n    for ( int iOtherEntityIndex=0; iOtherEntityIndex<int(ENTITY_MAX_COUNT); iOtherEntityIndex++ )\n    {\n        float fOtherEntityIndex = float(iOtherEntityIndex);\n        Entity otherEntity = Entity_Read( fOtherEntityIndex );\n\n        if ( entity.fType == ENTITY_TYPE_NONE )\n        {\n            if ( fOtherEntityIndex == entity.fId )\n            {\n\t            entity.fTarget = fSpawnQueueSlot;                \n    \t        break;\n            }\n\n\t        \/\/ Set this entity's position in spawn queue\n            if ( otherEntity.fType == ENTITY_TYPE_NONE )\n            {\n                fSpawnQueueSlot++;\n            }                    \n        }\n        else\n        {        \n            \/\/ Ignore self\n            if ( fOtherEntityIndex == entity.fId )\n            {\n                continue;\n            }\n\n            Entity_Collide( entity, otherEntity, fTimestep );\n\n            if ( Entity_IsAlivePlayer( entity ) )\n            {\n                if ( otherEntity.fType == ENTITY_TYPE_ITEM )\n                {\n                    if ( distance(entity.vPos.xz, otherEntity.vPos.xz) < PICKUP_RADIUS)\n                    {\n                        if( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS )\n                        {\n                            Player_GiveHealth( entity, 1.0, true );\n\t\t\t\t            entity.fEvent = EVENT_HEALTH_BONUS;                            \n                        }\n                        else\n                        if( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS )\n                        {\n                            Player_GiveArmor( entity, 1.0, false );\n\t\t\t\t            entity.fEvent = EVENT_ARMOR_BONUS;                            \n                        }\n                        else\n                        if ( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_MEDIKIT )\n                        {\n                            Player_GiveHealth( entity, 25.0, false );\n\t\t\t\t            entity.fEvent = EVENT_MEDIKIT;                            \n                        }\n                        else\n                        if ( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_STIMPACK )\n                        {\n                            Player_GiveHealth( entity, 10.0, false );\n\t\t\t\t            entity.fEvent = EVENT_STIMPACK;\n                        }\n                        else\n                        if ( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_GREENARMOR )\n                        {\n                            Player_GiveArmor( entity, 100.0, false );\n\t\t\t\t            entity.fEvent = EVENT_GREENARMOR;\n                        }\n                        else\n                        if ( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_BLUEARMOR )\n                        {\n                            Player_GiveArmor( entity, 200.0, true );\n\t\t\t\t            entity.fEvent = EVENT_BLUEARMOR;\n                        }\n                        else\n                        if ( otherEntity.fSubType == ENTITY_SUB_TYPE_ITEM_SHOTGUN )\n                        {\n                            if ( entity.fHaveShotgun == 0. )\n                            {\n\t                    \t\tentity.fUseWeapon = 2.;                        \n\t\t\t\t\t            entity.fEvent = EVENT_SHOTGUN;\n                            }\n                            \t\n                            entity.fHaveShotgun = 1.;\n                        }\n                    }\n                }\n            }\n            else\n            if ( entity.fType == ENTITY_TYPE_ITEM )\n            {\n                if ( Entity_IsAlivePlayer( otherEntity ) )\n                {\n                    if ( distance(entity.vPos.xz, otherEntity.vPos.xz) < PICKUP_RADIUS)\n                    {\n                        entity.fType = ENTITY_TYPE_NONE;\n                    }\n                }\n            }\n            if ( entity.fType == ENTITY_TYPE_FIREBALL )\n            {\n                if ( Fireball_Hit( entity, otherEntity ) )\n                {\n                    entity.fSubType = ENTITY_SUB_TYPE_FIREBALL_IMPACT;\n                    entity.fTimer = 0.3;\n                }\n            }\n            \n            \/\/ Process damage from other\n            if ( otherEntity.fType == ENTITY_TYPE_BULLET )\n            {\n                \/\/ Bullet is applying damage to this entity\n                if ( otherEntity.fTarget == entity.fId )\n                {\n                    Entity_ApplyDamage( entity, otherEntity.fHealth, otherEntity.fArmor );\n                }\n            }\n            else\n            if ( otherEntity.fType == ENTITY_TYPE_FIREBALL )\n            {\n                if ( Fireball_Hit( otherEntity, entity ) )\n                {\n                    Entity_ApplyDamage( entity, otherEntity.fHealth, otherEntity.fArmor );\n                }\n            }\n            else\n            if ( otherEntity.fType == ENTITY_TYPE_BARREL && otherEntity.fSubType == ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE )\n            {\n                \/\/ Todo : trace?\n                float fBlastRadius = 250.0;\n                float fMaxDamage = 50.0;\n                \n                vec3 vSeparation = entity.vPos - otherEntity.vPos;\n                float fDamage = fMaxDamage * clamp( 1.0 - length( vSeparation.xz ) \/ fBlastRadius, 0.0, 1.0 );\n                \n                if ( Entity_CanSee( otherEntity, entity ) )\n                {\n\t\t\t\t    Entity_ApplyDamage( entity, fDamage, otherEntity.fId );\n                }\n            }\n        }        \n    }\n}\n\nvoid Entity_Move( inout Entity entity, float fTimestep )\n{    \n    if( ( entity.fType == ENTITY_TYPE_PLAYER ) \t||\n        ( entity.fType == ENTITY_TYPE_ENEMY ) \t||\n        ( entity.fType == ENTITY_TYPE_BARREL )\n      )\n    {\n        \/\/vec2 vPrevPos = entity.vPos.xz;\n\n        Entity_UpdateSlideBox( entity, fTimestep );\n\n        \/\/Map_UpdateSector( g_mapInfo, vPrevPos, entity.vPos.xz, entity.fSectorId );\n    }\n    \n    if( ( entity.fType == ENTITY_TYPE_PLAYER )\t||\n        ( entity.fType == ENTITY_TYPE_ENEMY )  \t||\n        ( entity.fType == ENTITY_TYPE_BARREL ) \t|| \n        ( entity.fType == ENTITY_TYPE_ITEM ) \t||\n        ( entity.fType == ENTITY_TYPE_DECORATION )\n      )\n    {\n    \tEntity_Fall( entity, fTimestep );    \n    }\n    \n    if ( entity.fType == ENTITY_TYPE_BULLET )\n    {\n        entity.vPos.y += 10.0 * fTimestep;\n    }\n    \n    if ( entity.fType == ENTITY_TYPE_FIREBALL )\n    {\n        if ( entity.fSubType == ENTITY_SUB_TYPE_FIREBALL )\n        {\n\t        vec2 vPrevPos = entity.vPos.xz;\n\n            float fMaxTraceDist = length( entity.vVel ) * fTimestep;\n            vec3 vDir = normalize( entity.vVel );\n\n            TraceResult traceResult = Map_Trace( g_mapInfo, entity.vPos, vDir, entity.fSectorId, fMaxTraceDist );\n\n            if ( traceResult.fDist > 0.0 )\n            {\n            \tentity.vPos += vDir * traceResult.fDist;\n            }\n\n        \tMap_UpdateSector( g_mapInfo, vPrevPos, entity.vPos.xz, entity.fSectorId );\n            \n            if ( traceResult.fDist > 0.0 && traceResult.fDist < fMaxTraceDist  )\n            {\n                entity.fSubType = ENTITY_SUB_TYPE_FIREBALL_IMPACT;\n                entity.fTimer = 0.3;\n            }\n\t\t}\n    }\n}\n\nfloat RayCircleIntersect( vec2 vRayOrigin, vec2 vRayDir, vec2 vCircleOrigin, float fRadius2 )\n{\n    vec2 vRayOriginToCircleOrigin = vCircleOrigin - vRayOrigin;\n    float fProjection = dot( vRayOriginToCircleOrigin, vRayDir );        \n    vec2 vClosestPos = vRayOrigin + vRayDir * fProjection;\n    vec2 vClosestToCircle = vCircleOrigin - vClosestPos;\n    float fClosestDist2 = dot( vClosestToCircle, vClosestToCircle );\n    if ( fClosestDist2 < fRadius2 )\n    {\n        float fHalfChordLength = sqrt( fRadius2 - fClosestDist2 );\n        float fHitT = fProjection - fHalfChordLength;\n\n        return fHitT;\n\t}\n\n    return -1.0;\n}\n\nfloat Entity_Trace( vec3 vRayOrigin, vec3 vRayDir, float fIgnoreEnt, out Entity hitEntity )\n{\n    hitEntity.fId = -1.;\n    float fHitEntityDist = FAR_CLIP;\n    \n    float fOrigDirLen = length( vRayDir.xz );\n    \n    vec2 vFlatRayDir = vRayDir.xz \/ fOrigDirLen;\n\n    for ( int iTraceEntityIndex=0; iTraceEntityIndex<int(ENTITY_MAX_COUNT); iTraceEntityIndex++ )\n    {\n        float fEntityIndex = float(iTraceEntityIndex);\n        \n        if ( fEntityIndex == fIgnoreEnt )\n            continue;\n        \n        Entity entity = Entity_Read( fEntityIndex );\n\n        \n        \/\/ TODO: Entity_GetSize function?\n        float fRadius = 0.0;\n        float fHeight = 0.0;\n        if ( entity.fType == ENTITY_TYPE_BARREL )\n        {\n            fRadius = 12.0;\n            fHeight = 32.0;            \n        }\n        \n        if ( entity.fType == ENTITY_TYPE_ENEMY || entity.fType == ENTITY_TYPE_PLAYER )\n        {\n            fRadius = 15.0;\n            fHeight = 54.0;            \n        }\n \n        if ( fRadius > 0.0 )\n        {\n            float fHitT = RayCircleIntersect( vRayOrigin.xz, vFlatRayDir, entity.vPos.xz, fRadius * fRadius );\n            fHitT \/= fOrigDirLen;\n\t\t\tif ( fHitT > 0.0 && fHitT < fHitEntityDist )\n            {\n                float fEntHitY = vRayOrigin.y + vRayDir.y * fHitT - entity.vPos.y;\n                \n                if ( fEntHitY > 0. && fEntHitY < fHeight )\n                {\n                    fHitEntityDist = fHitT;\n                    hitEntity = entity;\n                }\n            }\n \t   }\n\t}\n    \n    return fHitEntityDist;\n}\n\nfloat Entity_GetSpawnQueueSlotType( float fSpawnQueueSlot, inout Entity spawningEntity, out float fSpawnSubType )\n{\n    fSpawnSubType = 0.0;\n    \n    float fOtherSpawnQueueSlot = 0.0;\n    for ( int iOtherEntityIndex=0; iOtherEntityIndex<int(ENTITY_MAX_COUNT); iOtherEntityIndex++ )\n    {\n        float fOtherEntityIndex = float(iOtherEntityIndex);\n        spawningEntity = Entity_Read( fOtherEntityIndex );\n\n        \/\/ spawn fired bullets\n        if ( FlagSet( spawningEntity.fFrameFlags, ENTITY_FRAME_FLAG_FIRE_WEAPON ) )\n        {\n            WeaponDef weaponDef = Entity_GetWeaponDef( spawningEntity );\n\n            float fNewSlot = fOtherSpawnQueueSlot + weaponDef.fProjectileCount;\n            if ( fNewSlot >= fSpawnQueueSlot ) \n            {\n                if ( weaponDef.fWeaponType == WEAPON_TYPE_FIREBALL )\n                {\n\t                return ENTITY_TYPE_FIREBALL;\n                }\n                else\n                {\n\t                return ENTITY_TYPE_BULLET;\n                }                    \n            }\n            fOtherSpawnQueueSlot = fNewSlot;\n        }\n        \n        \/\/ spawn dropped items\n        \/\/ spawn fired bullets\n        if ( FlagSet( spawningEntity.fFrameFlags, ENTITY_FRAME_FLAG_DROP_ITEM ) )\n        {\n            bool doSpawn = false;\n            \n            if ( spawningEntity.fSubType == ENTITY_SUB_TYPE_ENEMY_SERGEANT )\n            {\n                fSpawnSubType = ENTITY_SUB_TYPE_ITEM_SHOTGUN;\n                doSpawn = true;\n            }\n            \n            if ( doSpawn )\n            {\n                float fNewSlot = fOtherSpawnQueueSlot + 1.;\n                if ( fNewSlot >= fSpawnQueueSlot ) \n                {                \n                    return ENTITY_TYPE_ITEM;                    \n                }\n\t            fOtherSpawnQueueSlot = fNewSlot;\n            }\n        }\n        \n    }\n    \n    return ENTITY_TYPE_NONE;\n}\n\nbool Entity_SpawnOther( inout Entity entity )\n{\n    if ( entity.fType == ENTITY_TYPE_NONE )\n    {\n        Entity spawningEntity;\n        \n        float fSpawnQueueSlot = entity.fTarget;\n        float fSpawnSubType;\n        float fSpawnType = Entity_GetSpawnQueueSlotType( fSpawnQueueSlot, spawningEntity, fSpawnSubType );\n        \n        if ( fSpawnType == ENTITY_TYPE_BULLET )\n        {\n            Entity_Clear( entity );\n            entity.fType = ENTITY_TYPE_BULLET;\n            entity.fSubType = ENTITY_SUB_TYPE_BULLET_WALL;\n            \n            WeaponDef weaponDef = Entity_GetWeaponDef( spawningEntity );\n            \n            vec3 vRayOrigin = spawningEntity.vPos + vec3(0,40.,0);\n            \/\/ adjust Y to aim at target\n            float dy = tan(spawningEntity.fPitch);\n            if ( spawningEntity.fTarget != ENTITY_NONE )\n            {\n\t\t        Entity targetEntity;\n                \n                targetEntity = Entity_Read( spawningEntity.fTarget );\n                \n                vec3 vTargetPos = targetEntity.vPos;\n                \n                if( targetEntity.fType == ENTITY_TYPE_BARREL )\n                {\n                    vTargetPos.y += 30.0;\n                }\n                else\n                {\n                    vTargetPos.y += 40.0;                    \n\t\t\t\t}\n                \n                vec3 vToTarget = vTargetPos - vRayOrigin;\n                dy = vToTarget.y \/ length(vToTarget.xz);\n            }\n            float fSRand = Hash(fSpawnQueueSlot + iGlobalTime) * 2.0 - 1.0;\n            float fSpread = weaponDef.fSpread;\n            float fYaw = spawningEntity.fYaw + fSRand * fSpread;            \n            vec3 vRayDir = normalize( vec3(sin(fYaw), dy, cos(fYaw)) );\n\n            Entity hitEntity;\n            float fHitDist = Entity_Trace( vRayOrigin, vRayDir, spawningEntity.fId, hitEntity );\n            \n            TraceResult traceResult = Map_Trace( g_mapInfo, vRayOrigin, vRayDir, spawningEntity.fSectorId, fHitDist );\n\t\t\t\n            if ( hitEntity.fType == ENTITY_TYPE_ENEMY || hitEntity.fType == ENTITY_TYPE_PLAYER )\n            {\n\t            entity.fSubType = ENTITY_SUB_TYPE_BULLET_FLESH;                \n            }\n            \n            \/\/ Not sure why this > 0 test is required. Oh well...\n            if ( traceResult.fDist > 0.0 &&  traceResult.fDist < fHitDist  )\n            {\n                fHitDist = traceResult.fDist;\n                hitEntity.fId = -1.;\n\t            entity.fSubType = ENTITY_SUB_TYPE_BULLET_WALL;\n            }\n            \n            entity.vPos = vRayOrigin + vRayDir * fHitDist + vec3(0,-8,0);\n            float fRand = Hash(fSpawnQueueSlot + iGlobalTime + 1.234);\n            entity.fHealth = weaponDef.fBaseDamagePerProjectile + weaponDef.fRandomDamagePerProjectile * fRand; \/\/ Damage to deal\n            entity.fTimer = 0.3; \/\/ Impact effect timer\n            entity.fTarget = hitEntity.fId; \/\/ Which entity did we hit (cleared on first frame)\n            entity.fArmor = spawningEntity.fId; \/\/ Who fired the bullet\n            entity.fSectorId = traceResult.fSector;\n\n            return true;\n        }\n        else\n        if ( fSpawnType == ENTITY_TYPE_FIREBALL )\n        {\n            Entity_Clear( entity );\n            entity.fType = ENTITY_TYPE_FIREBALL;\n            entity.fSubType = ENTITY_SUB_TYPE_FIREBALL;\n            \n            WeaponDef weaponDef = Entity_GetWeaponDef( spawningEntity );\n            \n            entity.vPos = spawningEntity.vPos + vec3(0,40.,0);\n            \/\/ adjust Y to aim at target\n            float dy = 0.0;\n            if ( spawningEntity.fTarget != ENTITY_NONE )\n            {\n\t\t        Entity targetEntity;\n                \n                targetEntity = Entity_Read( spawningEntity.fTarget );\n                \n                vec3 vTargetPos = targetEntity.vPos;\n                \n                if( targetEntity.fType == ENTITY_TYPE_BARREL )\n                {\n                    vTargetPos.y += 30.0;\n                }\n                else\n                {\n                    vTargetPos.y += 40.0;                    \n\t\t\t\t}\n                \n                vec3 vToTarget = vTargetPos - entity.vPos;\n                dy = vToTarget.y \/ length(vToTarget.xz);\n            }\n            float fSRand = Hash(fSpawnQueueSlot + iGlobalTime) * 2.0 - 1.0;\n            float fSpread = weaponDef.fSpread;\n            float fYaw = spawningEntity.fYaw + fSRand * fSpread;            \n            entity.vVel = normalize( vec3(sin(fYaw), dy, cos(fYaw)) );\n            float fMoveSpeed = 200.0;\n            entity.vVel *= fMoveSpeed;\n\n            entity.fHealth = weaponDef.fBaseDamagePerProjectile; \/\/ Damage to deal\n            entity.fTimer = 5.0; \/\/ Travel timeout\n            entity.fArmor = spawningEntity.fId; \/\/ Who fired the bullet\n            entity.fSectorId = spawningEntity.fSectorId;\n\n            return true;\n        }\n        else\n        if ( fSpawnType == ENTITY_TYPE_ITEM )\n        {\n            Entity_Clear( entity );\n            entity.fType = ENTITY_TYPE_ITEM;\n            entity.fSubType = fSpawnSubType;\n            entity.vPos = spawningEntity.vPos + vec3(0, 24, 0);\n            entity.vVel = vec3(0, 2, 0);\n            entity.fSectorId = spawningEntity.fSectorId;            \n            \n            return true;\n        }            \n    }\n    \n    return false;\n}\n\nvoid Entity_Update( inout Entity entity, float fTimestep )\n{    \n    entity.fFrameFlags = 0.;     \n    entity.fEvent = 0.;\n    entity.fTookDamage = 0.;\n\n    \/\/ This is first to ensure consistent state\n    if( Entity_SpawnOther( entity ) )\n    {\n        return;\n    }\n        \n    Entity_Think( entity, fTimestep );\n\n    Entity_Interact( entity, fTimestep );\n    \n    Entity_Move( entity, fTimestep );    \n}\n\nvec4 DrawMap( vec2 vTexCoord )\n{\n    if ( vTexCoord.y < 0.0 )\n    {\n        return vec4(0,0,0,1);\n    }    \n        \n    float fScale = 10.0;\n        \n    vec2 vPixelWorldPos = vTexCoord;    \n    vPixelWorldPos -= vec2(200, 150); \n    vPixelWorldPos *= fScale;\n    vPixelWorldPos += vec2(1056, -3616);\n    \n    fScale *= 1.1;\n    \n    for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    {\n        float fSectorId = float(iSectorIndex);\n\n        if ( fSectorId > g_mapInfo.fSectorCount )\n            break;\n\n        Sector sector = Map_ReadSector( fSectorId );\n\n        \/*if ( Map_PointInSector( vPixelWorldPos, sector ) )\n{\nvResult = vec3(1,0,0);\n}*\/\n\n\n        for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n        {\n            float fSideDefIndex = float(iSideDefIndex);\n\n            SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n\n            if ( sideDef.fLength <= 0.0)\n            {\n                break;\n            }\n\n            vec2 vSideDir = normalize( sideDef.vB - sideDef.vA );\n\n            float fProj = dot( vSideDir, vPixelWorldPos - sideDef.vA );\n            fProj = clamp( fProj, 0.0, sideDef.fLength );\n\n            vec2 vClosest = sideDef.vA + vSideDir * fProj;\n            float fDist = length( vClosest - vPixelWorldPos );\n\n            if (fDist < fScale * .5 )\n            {\n                if ( sideDef.fNextSector != SECTOR_NONE )\n                {\n                    return vec4(1,1,0,1);\n                }\n                else\n                {\n                    return vec4(1,0,0,1);\n                }\n            }\n        }\t\t\t\n    }\n        \n    return vec4(0.0);\n    \n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{    \n    fragColor = vec4(0.0);\n\n    g_controls = ReadControls();\n    \n    g_mapInfo = ReadMapInfo();\n    g_gameState = GameState_Read();\n    \n    float fTimestep = iTimeDelta;\/\/1.0 \/ 60.0;\n\n    bool bShouldOutputGameState = all( lessThanEqual( floor(fragCoord.xy), vec2( 2, 0 ) ) );\n    float fOutputEntityId = Entity_GetOutputId( fragCoord );\n    bool bShouldOutputEntity = Entity_IdValid( fOutputEntityId );\n    \n    if ( !bShouldOutputEntity && !bShouldOutputGameState )\n    {\n#ifdef ALLOW_MAP        \n        if ( iFrame != 1 )\n#endif            \n        {\n        \tfragColor = texture2D( iChannel1, fragCoord \/ iResolution.xy );\n\t        return;\n        }\n        \n#ifdef ALLOW_MAP        \n        fragColor = DrawMap( fragCoord - vec2(0, 32));\n        return;\n#endif        \n        \n        \/\/fragColor.rgb = vec3( 1,0,0);\n        \/\/discard;\n    }\n    \n    if ( bShouldOutputGameState )\n    {\n        if ( iFrame == 0 )\n        {\n            GameState_Reset( g_gameState );\n        }        \n    }\n    float fMainGameState = g_gameState.fMainState;\n        \n    if ( bShouldOutputEntity )\n    {\n        Entity outputEntity;\n        outputEntity = Entity_Read( fOutputEntityId );\n        \n        if ( fMainGameState == MAIN_GAME_STATE_BOOT )\n        {\n            Entity_Clear( outputEntity );\n        }\n\n        if ( fMainGameState == MAIN_GAME_STATE_INIT_LEVEL )\n        {\n            Entity_MapSpawn( outputEntity, fOutputEntityId );\n        }               \n        else if ( fMainGameState == MAIN_GAME_STATE_GAME_RUNNING )\n        {        \n        \tEntity_Update( outputEntity, fTimestep );\n        }\n        \n        Entity_Store( outputEntity, fragColor, fragCoord );        \n    }\n    \n    if ( bShouldOutputGameState )\n    {\n        \/\/ Update GameState  \n\n        Entity playerEnt;\n        playerEnt = Entity_Read( 0. );\n                \n\t\tg_gameState.fStateTimer += fTimestep;\n        \n        if ( fMainGameState == MAIN_GAME_STATE_BOOT )\n        {\n            g_gameState.fMainState = MAIN_GAME_STATE_SKILL_SELECT;\t\t\t\n        }\n        \n        if ( fMainGameState == MAIN_GAME_STATE_SKILL_SELECT )\n        {\n            if ( g_controls.menuConfirm || g_gameState.fStateTimer > 2.0 )\n            {\n                g_gameState.fMainState = MAIN_GAME_STATE_INIT_LEVEL;\n\t            g_gameState.fStateTimer = 0.0;\n            }            \n        }\n        \n        if ( fMainGameState == MAIN_GAME_STATE_GAME_RUNNING )\n        {\n        \tg_gameState.fGameTime += fTimestep;        \n\n            \n            bool bPlayerNearExit = (distance( playerEnt.vPos.xz, vec2( 2930, -4768 ) ) < 100.0);        \n            if ( bPlayerNearExit && g_controls.open )\n            {\n                g_gameState.fMainState = MAIN_GAME_STATE_WIN;\n\t            g_gameState.fStateTimer = 0.0;\n            }   \n\n            if ( playerEnt.fHealth <= 0.0 && playerEnt.fTimer <= 0.0 )\n            {\n                if ( g_controls.menuConfirm )\n                {\n                    g_gameState.fMainState = MAIN_GAME_STATE_INIT_LEVEL;\n\t\t            g_gameState.fStateTimer = 0.0;\n                }\n            }\n            \n            if ( playerEnt.fHealth > 0.0 )\n            {\n                \/\/ This does debounce logic for us\n                if ( Key_IsToggled( KEY_TAB ) )\n                {\n                    g_gameState.fMap = 1.0;\n                }\n                else\n                {\n                    g_gameState.fMap = 0.0;                \n                }\n            }\n            \n            \/\/ Apply \/ update HUD effects\n            {\n                if ( playerEnt.fEvent == EVENT_HEALTH_BONUS )\n                {\n                    g_gameState.fHudFx += 0.25;\n\n                    g_gameState.fMessage = MESSAGE_HEALTH_BONUS;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.fEvent == EVENT_ARMOR_BONUS )\n                {\n                    g_gameState.fHudFx += 0.25;\n\n                    g_gameState.fMessage = MESSAGE_ARMOR_BONUS;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.fEvent == EVENT_STIMPACK )\n                {\n                    g_gameState.fHudFx += 0.5;\n\n                    g_gameState.fMessage = MESSAGE_STIMPACK;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.fEvent == EVENT_MEDIKIT )\n                {\n                    g_gameState.fHudFx += 0.5;\n\n                    g_gameState.fMessage = MESSAGE_MEDIKIT;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.fEvent == EVENT_GREENARMOR )\n                {\n                    g_gameState.fHudFx += 1.0;\n                    \n                    g_gameState.fMessage = MESSAGE_GREENARMOR;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.fEvent == EVENT_BLUEARMOR )\n                {\n                    g_gameState.fHudFx += 1.0;\n                    \n                    g_gameState.fMessage = MESSAGE_BLUEARMOR;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n                else if ( playerEnt.fEvent == EVENT_DIED )\n                {\n                    g_gameState.fHudFx -= 1.0;\n                } \n                else if ( playerEnt.fEvent == EVENT_SHOTGUN)\n                {\n                    g_gameState.fMessage = MESSAGE_SHOTGUN;\n                    g_gameState.fMessageTimer = 3.0;\n                }\n\n                if ( playerEnt.fTookDamage > 0.0 )\n                {\n                    g_gameState.fHudFx -= playerEnt.fTookDamage \/ 8.0;\n                }\n                \n                if ( g_gameState.fHudFx > 0.0 )\n                {\n                    g_gameState.fHudFx = max( 0.0, g_gameState.fHudFx - fTimestep );\n                }        \n                else\n                if ( g_gameState.fHudFx < 0.0 )\n                {\n                    g_gameState.fHudFx = min( 0.0, g_gameState.fHudFx + fTimestep );            \n                }     \n                g_gameState.fHudFx = clamp( g_gameState.fHudFx, -1.0, 1.0 );                \n                \n                \/\/ Update message timer;\n                g_gameState.fMessageTimer = max( 0.0, g_gameState.fMessageTimer - fTimestep );\n            }\n            \n        }\n\n        if ( fMainGameState == MAIN_GAME_STATE_INIT_LEVEL )\n        {\n\t\t\tg_gameState.fGameTime = 0.0;\n\t\t\tg_gameState.fMainState = MAIN_GAME_STATE_GAME_RUNNING;\n            g_gameState.fStateTimer = 0.0;\n        }\n        \n        g_gameState.vPrevMouse = iMouse;\n                \n        GameState_Store( g_gameState, fragColor, fragCoord );\n    }        \n}","name":"Buf C","description":"","type":"buffer"},{"inputs":[{"id":257,"src":"\/presets\/previz\/buffer00.png","ctype":"buffer","channel":0,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":258,"src":"\/presets\/previz\/buffer01.png","ctype":"buffer","channel":2,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}},{"id":259,"src":"\/presets\/previz\/buffer02.png","ctype":"buffer","channel":1,"sampler":{"filter":"nearest","wrap":"clamp","vflip":"true","srgb":"false","internal":"byte"}}],"outputs":[{"id":260,"channel":0}],"code":"\/\/ Scene Rendering\n\n\/\/#define DEBUG_IDENTIFY_TEXTURES\n\/\/#define DEBUG_IDENTIFY_TEXTURE 21.\n\/\/#define DEBUG_IDENTIFY_UNDEFINED_TEXTURES\n\/\/#define DEBUG_ENTITY_INFO\n\/\/#define DEBUG_VALUES\n\/\/#define TEXTURE_PREVIEW 54.0\n\n#define MAP_CHANNEL iChannel0\n#define STATE_CHANNEL iChannel1\n\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\/\/ Common code follows\n\n#define FAR_CLIP 1000000.0\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Util\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 Quantize( const in vec3 col, float fLevels )\n{\n\treturn floor( col * fLevels + 0.5 ) * (1.0 \/ fLevels);\n}\n\nfloat Cross2d( const in vec2 vA, const in vec2 vB )\n{   \n    return vA.x * vB.y - vA.y * vB.x;\n}\n\nfloat Hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvoid SetFlag( inout float fBits, float fFlag )\n{\n    \/\/ TODO: flag mask logic \n    fBits = fFlag;\n}\n\n\nbool FlagSet( float fBits, float fFlag )\n{\n    return fract( floor( fBits \/ fFlag ) * 0.5 ) >= 0.5;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Keyboard\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nconst float KEY_SPACE = 32.5\/256.0;\nconst float KEY_LEFT  = 37.5\/256.0;\nconst float KEY_UP    = 38.5\/256.0;\nconst float KEY_RIGHT = 39.5\/256.0;\nconst float KEY_DOWN  = 40.5\/256.0;\nconst float KEY_A     = 65.5\/256.0;\nconst float KEY_B     = 66.5\/256.0;\nconst float KEY_C     = 67.5\/256.0;\nconst float KEY_D     = 68.5\/256.0;\nconst float KEY_E     = 69.5\/256.0;\nconst float KEY_F     = 70.5\/256.0;\nconst float KEY_G     = 71.5\/256.0;\nconst float KEY_H     = 72.5\/256.0;\nconst float KEY_I     = 73.5\/256.0;\nconst float KEY_J     = 74.5\/256.0;\nconst float KEY_K     = 75.5\/256.0;\nconst float KEY_L     = 76.5\/256.0;\nconst float KEY_M     = 77.5\/256.0;\nconst float KEY_N     = 78.5\/256.0;\nconst float KEY_O     = 79.5\/256.0;\nconst float KEY_P     = 80.5\/256.0;\nconst float KEY_Q     = 81.5\/256.0;\nconst float KEY_R     = 82.5\/256.0;\nconst float KEY_S     = 83.5\/256.0;\nconst float KEY_T     = 84.5\/256.0;\nconst float KEY_U     = 85.5\/256.0;\nconst float KEY_V     = 86.5\/256.0;\nconst float KEY_W     = 87.5\/256.0;\nconst float KEY_X     = 88.5\/256.0;\nconst float KEY_Y     = 89.5\/256.0;\nconst float KEY_Z     = 90.5\/256.0;\nconst float KEY_COMMA = 188.5\/256.0;\nconst float KEY_PER   = 190.5\/256.0;\n\nconst float KEY_1 = \t49.5\/256.0;\nconst float KEY_2 = \t50.5\/256.0;\nconst float KEY_3 = \t51.5\/256.0;\nconst float KEY_ENTER = 13.5\/256.0;\nconst float KEY_SHIFT = 16.5\/256.0;\nconst float KEY_CTRL  = 17.5\/256.0;\nconst float KEY_ALT   = 18.5\/256.0;\nconst float KEY_TAB\t  = 9.5\/256.0;\n\nbool Key_IsPressed(float key)\n{\n    return texture2D( iChannel3, vec2(key, 0.0) ).x > 0.0;\n}\n\nbool Key_IsToggled(float key)\n{\n    return texture2D( iChannel3, vec2(key, 1.0) ).x > 0.0;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Packing\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat BytePack2( vec2 val )\n{ \n    return dot( floor(val), vec2(1, 256) );\n}\n\nfloat BytePack2( float x, float y )\n{\n    return BytePack2( vec2( x, y ) );\n}\n\nvec2 ByteUnpack2( float x )\n{\n    return mod( floor(vec2(x) \/ vec2(1, 256)), 256. );\n}\n\nfloat BytePack3( vec3 val )\n{ \n    return dot( floor(val), vec3(1, 256, 65536) );\n}\n\nfloat BytePack3( float x, float y, float z )\n{\n    return BytePack3( vec3( x, y, z ) );\n}\n\nvec3 ByteUnpack3( float x )\n{\n    return mod( floor(vec3(x) \/ vec3(1, 256, 65536)), 256. );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Data Storage\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec4 LoadVec4( sampler2D sampler, in vec2 vAddr )\n{\n    vec2 vUV = (vAddr + 0.5) \/ iChannelResolution[0].xy;\n    return texture2D( sampler, vUV, -100.0 );\n}\n\nvec3 LoadVec3( sampler2D sampler, in vec2 vAddr )\n{\n    return LoadVec4( sampler, vAddr ).xyz;\n}\n\nbool AtAddress( vec2 p, vec2 c ) { return all( equal( floor(p), floor(c) ) ); }\n\nvoid StoreVec4( in vec2 vAddr, in vec4 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    fragColor = AtAddress( fragCoord, vAddr ) ? vValue : fragColor;\n}\n\nvoid StoreVec3( in vec2 vAddr, in vec3 vValue, inout vec4 fragColor, in vec2 fragCoord )\n{\n    StoreVec4( vAddr, vec4( vValue, 0.0 ), fragColor, fragCoord);\n}\n\n\nvec4 ReadMapData( vec2 address )\n{\n    return LoadVec4( MAP_CHANNEL, address );\n}\n    \nvec4 ReadStateData( vec2 address )\n{\n    return LoadVec4( STATE_CHANNEL, address );\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Game State\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define MAIN_GAME_STATE_BOOT\t\t\t0.\n#define MAIN_GAME_STATE_SKILL_SELECT\t1.\n#define MAIN_GAME_STATE_INIT_LEVEL\t\t2.\n#define MAIN_GAME_STATE_GAME_RUNNING\t3.\n#define MAIN_GAME_STATE_WIN\t\t\t\t4.\n\nstruct GameState\n{\n    float fMainState;\n    float fStateTimer;\n    float fSkill;\n    float fGameTime;\n    \n    vec4 vPrevMouse;\n    \n    float fMap;\n    float fHudFx;\n    \n    float fMessage;\n    float fMessageTimer;\n};\n\nvoid GameState_Reset( out GameState gameState )\n{\n    gameState.fMainState = MAIN_GAME_STATE_BOOT;\n\tgameState.fSkill = 0.;\n    gameState.fGameTime = 0.;\n    gameState.fStateTimer = 0.;\n    \n    gameState.vPrevMouse = iMouse;\n    \n    gameState.fMap = 0.0;\n    gameState.fHudFx = 0.0;\n    \n    gameState.fMessage = -1.0;\n    gameState.fMessageTimer = 0.0;\n}\n\nGameState GameState_Read()\n{\n    GameState gameState;\n    \n    vec2 vAddress = vec2( 0 );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.x++;\n\n    gameState.fMainState = vData0.x;\n    gameState.fSkill = vData0.y;\n    gameState.fGameTime = vData0.z;\n    gameState.fStateTimer = vData0.w;    \n\n    gameState.vPrevMouse = vData1;\n    \n    gameState.fMap = vData2.x;\n    gameState.fHudFx = vData2.y;\n\n    gameState.fMessage = vData2.z;\n    gameState.fMessageTimer = vData2.w;\n    \n    return gameState;\n}\n\nvoid GameState_Store( GameState gameState, inout vec4 fragColor, in vec2 fragCoord )\n{    \n    vec4 vData0 = vec4( gameState.fMainState, gameState.fSkill, gameState.fGameTime, gameState.fStateTimer );    \n\n    vec4 vData1 = vec4( gameState.vPrevMouse );    \n\n    vec4 vData2 = vec4( gameState.fMap, gameState.fHudFx, gameState.fMessage, gameState.fMessageTimer );    \n\n    vec2 vAddress = vec2( 0 );\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.x++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.x++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Map Data\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n    \n#define MAX_SECTOR_COUNT 96\n#define MAX_SIDEDEF_COUNT 32\n\n#define SECTOR_NONE -1.\n\nstruct MapInfo\n{\n    float fSectorCount;\n};\n    \nMapInfo ReadMapInfo()\n{\n    MapInfo mapInfo;\n    \n    vec4 vData = ReadMapData( vec2(0.0, 0.0) );\n    \n    mapInfo.fSectorCount = vData.x;\n    \n    return mapInfo;\n}\n\nstruct Sector\n{\n    float fSectorId;\n    float fLightLevel;\n\n    float fFloorHeight;\n    float fCeilingHeight;\n\n    float fFloorTexture;\n    float fCeilingTexture;\n};\n    \nvec2 GetSectorAddress( float fSectorId )\n{\n    return vec2(0.0, 1.0 + fSectorId );\n}\n\nvec2 GetSideDefAddress( float fSectorId, float fSideDefIndex )\n{\n    return vec2(2.0 + fSideDefIndex * 3.0, 1.0 + fSectorId );\n}\n    \nSector Map_ReadSector( float fSectorId )\n{\n    Sector sector;\n    \n    sector.fSectorId = fSectorId;\n    \n    vec2 vAddress = GetSectorAddress( fSectorId );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n\n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sector.fLightLevel = vData0.x;\n\n    sector.fFloorHeight = vData1.x;\n    sector.fCeilingHeight = vData1.y;\n    sector.fFloorTexture = vData1.z;\n    sector.fCeilingTexture = vData1.w;\n    \n    return sector;\n}\n\nstruct SideDef\n{\n    vec2 vA;\n    vec2 vB;\n    float fLength;\n    \n    float fNextSector;\n    \n    float fLightLevel;\n    \n    float fUpperTexture;\n    float fMiddleTexture;\n    float fLowerTexture;    \n    \n    float fFlags;\n};\n\nSideDef Map_ReadSideDefInfo( float fSectorId, float fSideDefIndex )\n{\n    SideDef sideDef;\n    \n    vec2 vAddress = GetSideDefAddress( fSectorId, fSideDefIndex );\n    \n    vec4 vData0 = ReadMapData(vAddress);\n    vAddress.x += 1.0;                       \n\n    sideDef.vA = vData0.xy;\n    sideDef.vB = vData0.zw;\n    \n    vec4 vData1 = ReadMapData(vAddress);\n    vAddress.x += 1.0;\n\n    sideDef.fLength = vData1.x;\n    sideDef.fLightLevel = vData1.y;    \n    sideDef.fMiddleTexture = vData1.z;\n    sideDef.fNextSector = vData1.w;\n    \n    vec4 vData2 = ReadMapData(vAddress);\n    sideDef.fLowerTexture = vData2.x;\n    sideDef.fUpperTexture = vData2.y;\n    sideDef.fFlags = vData2.z;\n    \n    return sideDef;\n}\n\n\/\/ Return:\n\/\/   ray t value\n\/\/   sidedef u value\n\/\/   edge crossing direction\nvec3 Map_SideDefIntersectLine( SideDef sideDef, vec2 vRayPos, vec2 vRayDir )\n{\n    vec2 vEdgeDir = sideDef.vB - sideDef.vA;\n    vec2 vOA = sideDef.vA - vRayPos;\n    float fDenom = Cross2d( vRayDir, vEdgeDir );\n    float fRcpDenom = 1.0 \/ fDenom;\n    \n    vec3 vHitTUD;\n    vHitTUD.x = Cross2d( vOA, vEdgeDir ) * fRcpDenom;\n    vHitTUD.y = Cross2d( vOA, vRayDir ) * fRcpDenom;\n    vHitTUD.z = fDenom;\n    \n    return vHitTUD;    \n}\n\nbool Map_ValidSectorId( MapInfo mapInfo, float fSectorId )\n{\n    return ( fSectorId >= 0.0 && fSectorId < mapInfo.fSectorCount );\n}\n\nbool Map_PointInSector( vec2 vPos, Sector sector )\n{\n    float fInOutTest = 0.0;\n    \n    for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n    {\n        float fSideDefIndex = float(iSideDefIndex);\n        \n        SideDef sideDef = Map_ReadSideDefInfo( sector.fSectorId, fSideDefIndex );                        \n        \n        if ( sideDef.fLength <= 0.0)\n        {\n            break;\n        }\n\n        vec2 vPosToA = sideDef.vA - vPos;\n        vec2 vPosToB = sideDef.vB - vPos;\n        \n        if ( vPosToA.y > 0.0 && vPosToB.y > 0.0 )\n        \tcontinue;\n        if ( vPosToB.y <= 0.0 && vPosToA.y <= 0.0 )\n        \tcontinue;               \n        \n        float fCross = Cross2d( vPosToA, vPosToB );\n        if ( vPosToA.y > vPosToB.y )\n            fCross = -fCross;\n        if ( fCross < 0.0 )\n        {\n            fInOutTest++;\n        }        \n    }\n    \n    return mod( fInOutTest, 2.0 ) >= 1.0;    \n}\n\nbool Map_PointInSector( MapInfo mapInfo, vec2 vPos, float fSectorId )\n{\n    if ( !Map_ValidSectorId(mapInfo, fSectorId) )\n    {\n        return false;\n    }\n\n    Sector sector = Map_ReadSector( fSectorId );\n\n    return Map_PointInSector( vPos, sector );\n}\n\nfloat Map_SeekSector( MapInfo mapInfo, vec2 vPos )\n{    \n    for(int iSectorIndex=0; iSectorIndex<MAX_SECTOR_COUNT; iSectorIndex++)\n    {\n        float fSectorId = float(iSectorIndex);\n        \n        if ( !Map_ValidSectorId( mapInfo, fSectorId ) )\n        {\n            break;\n        }\n\n        if ( Map_PointInSector( mapInfo, vPos, fSectorId ) )\n        {\n            return fSectorId;\n        }        \n    }\n\n    return SECTOR_NONE;\n}\n\n\nvoid Map_UpdateSector( MapInfo mapInfo, vec2 vPrev, vec2 vPos, inout float fSectorId )\n{    \n    if ( vPrev == vPos )\n    {\n        return;\n    }\n    \n    if ( !Map_PointInSector( mapInfo, vPos, fSectorId ) )\n    {\n        float fNewSectorId = Map_SeekSector( mapInfo, vPos );\n        \n        if ( fNewSectorId != SECTOR_NONE )\n        {\n        \tfSectorId = fNewSectorId;\n        }                \n    }\n}\n\nstruct TraceResult\n{\n    float fDist;\n    vec3 vTexture; \/\/ UV \/ TexureId during trace. Resolved to RGB for sprite rendering\n  \tfloat fLightLevel;\n    float fSector;\n};\n\nstruct TraceSectorState\n{\n    float fEnterDist;\n    float fExitY;\n    float fNextSector;\n    bool bNoUpper;\n};\n\nvoid TraceSideDef( vec3 vRayOrigin, vec3 vRayDir, inout TraceResult result, inout TraceSectorState sectorState, Sector sector, SideDef sideDef )\n{    \n\tvec3 vHitTUD = Map_SideDefIntersectLine( sideDef, vRayOrigin.xz, vRayDir.xz );\n    float fHitT = vHitTUD.x;\n    float fHitU = vHitTUD.y;\n    float fDenom = vHitTUD.z;\n\n    if( \n        \/\/ We hit the edge between the endpoints\n        (fHitU >= 0.0) && (fHitU < 1.0) &&\n        \/\/ Hit point is further than sector entrance distance\n        (fHitT > sectorState.fEnterDist) && \n        \/\/ Track closest hit\n        (fHitT < result.fDist) && \n        \/\/ Ignore faces entering sector\n        (fDenom < 0.0)\n      )\n    {\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        sectorState.fExitY = fHitY;\n        result.fDist = fHitT;\n        \n        if( (sectorState.fExitY > sector.fFloorHeight) )                \n        {\n            sectorState.fNextSector = SECTOR_NONE;\n            if( sideDef.fNextSector == SECTOR_NONE && sideDef.fMiddleTexture != 0.0 && (sectorState.fExitY < sector.fCeilingHeight ) )\n            {\n                result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY);\n                result.vTexture.z = sideDef.fMiddleTexture;\n                result.fLightLevel = sideDef.fLightLevel;\n                sectorState.bNoUpper = false;\n            }\n            else\n            {\n                Sector nextSector = Map_ReadSector( sideDef.fNextSector );\n                                \n\t\t        bool bNoUpper = mod(sideDef.fFlags, 2.0) != 0.0;\n\n\t            if (sectorState.fExitY < sector.fCeilingHeight || bNoUpper )\n                {                                    \n                    if( nextSector.fFloorHeight > sector.fFloorHeight && fHitY > sector.fFloorHeight && fHitY < nextSector.fFloorHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fFloorHeight);\n                        result.vTexture.z = sideDef.fLowerTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }            \n                    else\n                    if( sideDef.fUpperTexture != 0.0 && nextSector.fCeilingHeight < sector.fCeilingHeight && fHitY < sector.fCeilingHeight && fHitY > nextSector.fCeilingHeight)\n                    {\n                        result.vTexture.st = vec2(fHitU * sideDef.fLength, fHitY - nextSector.fCeilingHeight);\n                        result.vTexture.z = sideDef.fUpperTexture;\n                        result.fLightLevel = sideDef.fLightLevel;\n                        sectorState.bNoUpper = false;\n                    }\n                    else\n                    {\n                        sectorState.bNoUpper = bNoUpper;\n                        sectorState.fNextSector = sideDef.fNextSector;                          \n                    }\n                }\n            }\n        }\n    }\n}\n\nTraceResult Map_Trace( MapInfo mapInfo, vec3 vRayOrigin, vec3 vRayDir, float fSectorId, float fMaxDist )\n{\n    TraceResult result;\n    \n    result.vTexture = vec3(0.0);\n    result.fDist = 0.0;\n    result.fLightLevel = 0.0;\n    result.fSector = SECTOR_NONE;\n    \n    for(int iSectorIndex=0; iSectorIndex<20; iSectorIndex++)\n    {\n        if ( fSectorId == SECTOR_NONE )\n        {\n            break;\n        }\n        \n        Sector sector = Map_ReadSector( fSectorId );\n        \n        TraceSectorState sectorState;\n        sectorState.fNextSector = SECTOR_NONE;        \n        sectorState.fEnterDist = result.fDist;\n        sectorState.bNoUpper = false;\n        result.fDist = fMaxDist;\n        result.fSector = fSectorId;\n        \n        for(int iSideDefIndex=0; iSideDefIndex<MAX_SIDEDEF_COUNT; iSideDefIndex++)\n        {\n            float fSideDefIndex = float(iSideDefIndex);\n            \n            SideDef sideDef = Map_ReadSideDefInfo( fSectorId, fSideDefIndex );                        \n            \n            if ( sideDef.fLength <= 0.0)\n            {\n\t\t\t\tbreak;\n            }\n\n            TraceSideDef( vRayOrigin, vRayDir, result, sectorState, sector, sideDef );\n        }\n\n        \/\/ Test floor \/ ceiling\n        if ( sectorState.fExitY < sector.fFloorHeight )\n        {\n            result.fDist = (sector.fFloorHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vFloorPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vFloorPos.xz );\n            result.vTexture.z = sector.fFloorTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }\n        else\n        if ( sectorState.fExitY > sector.fCeilingHeight && !sectorState.bNoUpper )\n        {\n            result.fDist = (sector.fCeilingHeight - vRayOrigin.y) \/ vRayDir.y;\n            vec3 vCeilingPos = vRayOrigin + vRayDir * result.fDist;\n            result.vTexture.st = vec2( vCeilingPos.xz );\n            result.vTexture.z = sector.fCeilingTexture;\n            result.fLightLevel = 0.0;\n            sectorState.fNextSector = SECTOR_NONE;\n        }        \n\n        fSectorId = sectorState.fNextSector;\n    }\n    \n    if ( result.vTexture.z == 1.0 )\n        result.fDist = FAR_CLIP;\n    \n    return result;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Entity Management\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define ENTITY_TYPE_NONE -1.\n\nstruct Entity\n{\n    float fId;\n    \n    float fType;\n    float fSubType;\n    float fSectorId;    \n\n    vec3 vPos;\n    float fYaw;\n    float fPitch;\n    \n    vec3 vVel;\n    float fYawVel;\n    \n    float fHealth;\n    float fArmor;    \n    \n    float fUseWeapon;    \n    float fHaveShotgun;\n    \n    float fTookDamage; \/\/ For HUD damage indicator\n    float fEvent; \/\/ Message event for UI \"Picked up an armor bonus\" etc.\n    \n    float fTimer; \/\/ Weapon reload for player, think timer for AI\n    float fTarget; \/\/ AI nemesis and also used for player aim up \/ down \n    float fFrameFlags;\n};\n    \n#define ENTITY_DATA_YPOS 8.\n#define ENTITY_DATA_SIZE 4.\n\n#define ENTITY_MAX_COUNT 128.\n    \n#define ENTITY_NONE -1.\n    \nfloat Entity_GetOutputId( vec2 fragCoord )\n{\n    if (\n           fragCoord.y < ENTITY_DATA_YPOS\n        || fragCoord.y >= (ENTITY_DATA_YPOS + ENTITY_DATA_SIZE)\n        || fragCoord.x >= ENTITY_MAX_COUNT\n       )\n    {\n        return ENTITY_NONE;        \n    }\n\n    return floor(fragCoord.x);\n}\n\nbool Entity_IdValid( float fEntityId )\n{\n    return ( fEntityId >= 0. && fEntityId < ENTITY_MAX_COUNT );\n}\n\nvoid Entity_Clear( inout Entity entity )\n{\n    entity.fType = ENTITY_TYPE_NONE;\n    entity.vPos = vec3(0);\n    entity.fSectorId = SECTOR_NONE;\n    entity.fYaw = 0.0;\n    entity.vVel = vec3(0);\n    entity.fYawVel = 0.0;\n    entity.fPitch = 0.0;\n    entity.fHealth = 0.0;\n    entity.fArmor = 0.0;\n    entity.fTimer = 0.0;\n    entity.fTarget = ENTITY_NONE;\n    entity.fFrameFlags = 0.0;    \n    entity.fUseWeapon = 1.;\n    entity.fHaveShotgun = 0.;\n    entity.fTookDamage = 0.;\n    entity.fEvent = 0.;\n}\n\nEntity Entity_Read( float fEntityId )\n{\n    Entity entity;\n    \n    entity.fId = fEntityId;\n    \n    vec2 vAddress = vec2( fEntityId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = ReadStateData( vAddress );\n    vec3 vUnpacked0x = ByteUnpack3( vData0.x ) - 1.;\n    vAddress.y++;\n    \n    \n    entity.fType = vUnpacked0x.x;\n    entity.fSubType = vUnpacked0x.y;\n    entity.fSectorId = vUnpacked0x.z;\n    \n    entity.fFrameFlags = vData0.y;\n    \n    entity.fTarget = vData0.z;\n    entity.fTimer = vData0.w;\n    \n    vec4 vData1 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vPos = vData1.xyz;\n    entity.fYaw = vData1.w;\n\n    vec4 vData2 = ReadStateData( vAddress );\n    vAddress.y++;\n\n    entity.vVel = vData2.xyz;\n    entity.fYawVel = vData2.w;\n\n    vec4 vData3 = ReadStateData( vAddress );\n    vec2 vUnpacked3x = ByteUnpack2(vData3.x);\n    vec2 vUnpacked3y = ByteUnpack2(vData3.y);\n    vec2 vUnpacked3z = ByteUnpack2(vData3.z) -1.;\n    vAddress.y++;\n    \n    entity.fHealth = vUnpacked3x.x;\n    entity.fArmor = vUnpacked3x.y;\n    float fPackedWeaponInfo = vData3.y;\n    entity.fUseWeapon = vUnpacked3y.x;\n    entity.fHaveShotgun = vUnpacked3y.y;\n    entity.fTookDamage = vUnpacked3z.x;\n    entity.fEvent = vUnpacked3z.y;\n    entity.fPitch = vData3.w;\n    \n    return entity;\n}\n\nvoid Entity_Store( Entity entity, inout vec4 fragColor, in vec2 fragCoord )\n{\n    if ( !Entity_IdValid( entity.fId ) ) \n        return;\n\n    float fPacked0 = BytePack3( vec3(entity.fType, entity.fSubType, entity.fSectorId ) + 1. );\n\n    entity.fHealth = floor( clamp( entity.fHealth, 0.0, 255.0 ) );\n    entity.fArmor = floor( clamp( entity.fArmor, 0.0, 255.0 ) );\n    float fPackedHealthAndArmor = BytePack2( vec2( entity.fHealth, entity.fArmor ) ); \n\tfloat fPackedWeaponInfo = BytePack2( vec2( entity.fUseWeapon, entity.fHaveShotgun ) );\n\tfloat fPackedEvents = BytePack2( vec2( entity.fTookDamage, entity.fEvent ) + 1. );\n    \n    vec2 vAddress = vec2( entity.fId, ENTITY_DATA_YPOS );\n    \n    vec4 vData0 = vec4( fPacked0, entity.fFrameFlags, entity.fTarget, entity.fTimer );    \n    vec4 vData1 = vec4( entity.vPos, entity.fYaw );\n    vec4 vData2 = vec4( entity.vVel, entity.fYawVel );\n    vec4 vData3 = vec4( fPackedHealthAndArmor, fPackedWeaponInfo, fPackedEvents, entity.fPitch );\n\n    StoreVec4( vAddress, vData0, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData1, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData2, fragColor, fragCoord );\n    vAddress.y++;\n\n    StoreVec4( vAddress, vData3, fragColor, fragCoord );\n    vAddress.y++;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Weapon Defs\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define WEAPON_TYPE_PISTOL\t\t0.\n#define WEAPON_TYPE_SHOTGUN\t\t1.\n#define WEAPON_TYPE_FIREBALL\t2.\n\nstruct WeaponDef\n{\n    float fWeaponType;\n    float fReloadTime;\n    float fProjectileCount;\n    float fBaseDamagePerProjectile;\n    float fRandomDamagePerProjectile;\n    float fSpread;\n};\n\nWeaponDef Weapon_GetDef( float fWeaponType, bool bEnemy )\n{\n    WeaponDef weaponDef;\n\n    if ( fWeaponType == WEAPON_TYPE_SHOTGUN )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_SHOTGUN;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = bEnemy ? 3.0 : 7.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = radians(4.0);\n    }\n    else\n    if ( fWeaponType == WEAPON_TYPE_FIREBALL )\n    {\n        weaponDef.fWeaponType = WEAPON_TYPE_FIREBALL;\n        weaponDef.fReloadTime = 1.0;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = 5.0;\n        weaponDef.fRandomDamagePerProjectile = 0.0;\n        weaponDef.fSpread = radians(0.0);\n    }\n    else\n    {\n        \/\/ Pistol\n        weaponDef.fWeaponType = WEAPON_TYPE_PISTOL;\n        weaponDef.fReloadTime = 0.5;\n        weaponDef.fProjectileCount = 1.0;\n        weaponDef.fBaseDamagePerProjectile = bEnemy ? 3.0 : 5.0;\n        weaponDef.fRandomDamagePerProjectile = bEnemy ? 12.0 : 10.0;\n        weaponDef.fSpread = bEnemy ? radians(4.0) : 0.0;\n    }\n    \n    return weaponDef;\n}\n    \n#define ENTITY_TYPE_PLAYER \t0.\n\n#define ENTITY_TYPE_BARREL \t1.\n#define ENTITY_SUB_TYPE_BARREL_INACTIVE\t\t\t0.\n#define ENTITY_SUB_TYPE_BARREL_EXPLODING\t\t1.\n#define ENTITY_SUB_TYPE_BARREL_APPLY_DAMAGE\t\t2.\n\n#define ENTITY_TYPE_ITEM \t2.\n#define ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS \t0.\n#define ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS \t1.\n#define ENTITY_SUB_TYPE_ITEM_SHOTGUN \t\t2.\n#define ENTITY_SUB_TYPE_ITEM_STIMPACK\t\t3.\n#define ENTITY_SUB_TYPE_ITEM_GREENARMOR\t\t4.\n#define ENTITY_SUB_TYPE_ITEM_BLUEARMOR\t\t5.\n#define ENTITY_SUB_TYPE_ITEM_MEDIKIT\t\t6.\n\n#define ENTITY_TYPE_DECORATION 3.\n#define ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS\t\t\t0.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER\t\t\t1.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT\t\t2.\n#define ENTITY_SUB_TYPE_DECORATION_DEAD_IMP\t\t\t\t3.\n#define ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR\t4.\n#define ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP\t\t\t5.\n\n#define ENTITY_TYPE_ENEMY\t4.\n#define ENTITY_SUB_TYPE_ENEMY_TROOPER \t\t0.\n#define ENTITY_SUB_TYPE_ENEMY_IMP \t\t\t1.\n#define ENTITY_SUB_TYPE_ENEMY_SERGEANT \t\t2.\n\n#define ENTITY_TYPE_BULLET 5.\n#define\tENTITY_SUB_TYPE_BULLET_WALL\t\t\t0.\n#define\tENTITY_SUB_TYPE_BULLET_FLESH\t\t1.\n\n#define ENTITY_TYPE_DOOR 6.\n\n#define ENTITY_TYPE_PLATFORM 7.\n\n#define ENTITY_TYPE_FIREBALL 8.\n#define ENTITY_SUB_TYPE_FIREBALL 0.\n#define ENTITY_SUB_TYPE_FIREBALL_IMPACT 1.\n\n\n#define ENTITY_FRAME_FLAG_FIRE_WEAPON\t\t1.\n#define ENTITY_FRAME_FLAG_DROP_ITEM\t\t\t2.\n\n\n#define ENEMY_STATE_IDLE\t\t\t\t0.\n#define ENEMY_STATE_PAIN\t\t\t\t1.\n#define ENEMY_STATE_WALK_RANDOM\t\t\t2.\n#define ENEMY_STATE_WALK_TO_TARGET\t\t3.\n#define ENEMY_STATE_STAND\t\t\t\t4.\n#define ENEMY_STATE_FIRE\t\t\t\t5.\n#define ENEMY_STATE_DIE\t\t\t\t\t6.\n\n\n#define EVENT_HEALTH_BONUS \t1.\n#define EVENT_ARMOR_BONUS \t2.\n#define EVENT_SHOTGUN \t\t3.\n#define EVENT_STIMPACK\t\t4.\n#define EVENT_GREENARMOR\t5.\n#define EVENT_BLUEARMOR\t\t6.\n#define EVENT_MEDIKIT\t\t7.\n#define EVENT_DIED\t\t\t8.\n\n#define MESSAGE_NONE\t\t\t-1.\n#define MESSAGE_HEALTH_BONUS \t0.\n#define MESSAGE_ARMOR_BONUS \t1.\n#define MESSAGE_SHOTGUN \t\t2.\n#define MESSAGE_STIMPACK\t\t3.\n#define MESSAGE_GREENARMOR\t\t4.\n#define MESSAGE_BLUEARMOR\t\t5.\n#define MESSAGE_MEDIKIT\t\t\t6.\n#define MESSAGE_HUD_TEXT\t\t7.\n#define MESSAGE_CHOOSE_SKILL\t8.\n#define MESSAGE_SKILL_1\t\t\t9.\n#define MESSAGE_SKILL_2\t\t\t10.\n#define MESSAGE_SKILL_3\t\t\t11.\n#define MESSAGE_SKILL_4\t\t\t12.\n#define MESSAGE_SKILL_5\t\t\t13.\n#define MESSAGE_HANGAR\t\t\t14.\n#define MESSAGE_FINISHED\t\t15.\n#define MESSAGE_KILLS\t\t\t16.\n#define MESSAGE_ITEMS\t\t\t17.\n#define MESSAGE_SECRET\t\t\t18.\n#define MESSAGE_TIME\t\t\t19.\n#define MESSAGE_SELECT\t\t\t20.\n#define MESSAGE_COUNT\t\t\t21.\n\n\n\/\/ End of common code\n\/\/ ----------------- 8< -------------------------- 8< -------------------------- 8< --------------\n\n\/\/ ---- 8< ---- GLSL Number Printing - @P_Malin ---- 8< ----\n\/\/ Creative Commons CC0 1.0 Universal (CC-0) \n\/\/ https:\/\/www.shadertoy.com\/view\/4sBSWW\n\nfloat DigitBin(const in int x)\n{\n    return x==0?480599.0:x==1?139810.0:x==2?476951.0:x==3?476999.0:x==4?350020.0:x==5?464711.0:x==6?464727.0:x==7?476228.0:x==8?481111.0:x==9?481095.0:0.0;\n}\n\nfloat PrintValue(const in vec2 vStringUV, const in float fValue, const in float fMaxDigits, const in float fDecimalPlaces)\n{\n    if ((vStringUV.y < 0.0) || (vStringUV.y >= 1.0)) return 0.0;\n\tfloat fLog10Value = log2(abs(fValue)) \/ log2(10.0);\n\tfloat fBiggestIndex = max(floor(fLog10Value), 0.0);\n\tfloat fDigitIndex = fMaxDigits - floor(vStringUV.x);\n\tfloat fCharBin = 0.0;\n\tif(fDigitIndex > (-fDecimalPlaces - 1.01)) {\n\t\tif(fDigitIndex > fBiggestIndex) {\n\t\t\tif((fValue < 0.0) && (fDigitIndex < (fBiggestIndex+1.5))) fCharBin = 1792.0;\n\t\t} else {\t\t\n\t\t\tif(fDigitIndex == -1.0) {\n\t\t\t\tif(fDecimalPlaces > 0.0) fCharBin = 2.0;\n\t\t\t} else {\n\t\t\t\tif(fDigitIndex < 0.0) fDigitIndex += 1.0;\n\t\t\t\tfloat fDigitValue = (abs(fValue \/ (pow(10.0, fDigitIndex))));\n                float kFix = 0.0001;\n                fCharBin = DigitBin(int(floor(mod(kFix+fDigitValue, 10.0))));\n\t\t\t}\t\t\n\t\t}\n\t}\n    return floor(mod((fCharBin \/ pow(2.0, floor(fract(vStringUV.x) * 4.0) + (floor(vStringUV.y * 5.0) * 4.0))), 2.0));\n}\n\n\/\/ ---- 8< -------- 8< -------- 8< -------- 8< ----\n\n#define ENABLE_SPRITES\n\n#define DRAW_SKY\n#define HEAD_BOB\n\n#define QUANTIZE_FINAL_IMAGE\n#define QUANTIZE_TEXTURES\n#define PIXELATE_TEXTURES\n\n\n#define DISCARD_BACKGROUND\n\nconst float kDepthFadeScale = (1.0 \/ 3500.0);\nconst float kExtraLight = 0.0;\n\nvec3 SampleTexture( float fTexture, const in vec2 vUV );\n\nvec3 GetCameraRayDir( const in vec2 vWindow, const in vec3 vCameraPos, const in vec3 vCameraTarget )\n{\n\tvec3 vForward = normalize(vCameraTarget - vCameraPos);\n\tvec3 vRight = normalize(cross(vec3(0.0, 1.0, 0.0), vForward));\n\tvec3 vUp = normalize(cross(vForward, vRight));\n\t\n    const float kFOV = 1.8;\n    \n\tvec3 vDir = normalize(vWindow.x * vRight + vWindow.y * vUp + vForward * kFOV);\n\n\treturn vDir;\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\n#ifdef ENABLE_SPRITES\n\nvoid Sprite( vec3 vRayOrigin, vec3 vRayDir, vec3 vPos, vec2 vSpriteDir, float fSectorId, vec4 vSpriteInfo, inout TraceResult traceResult )\n{\n\tif ( vSpriteInfo.z <= 0.0 )\n        return;\n    \n    vec2 vSize = vSpriteInfo.zw;\n    \n\tvec2 vA = vPos.xz - vSpriteDir * 0.5 * vSize.x;\n\tvec2 vB = vPos.xz + vSpriteDir * 0.5 * vSize.x;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;   \n    \n    float fDepthBias = 0.0;\/\/-vSize.x * .5;\n    \n    if ( fHitT > 0.0 && (fHitT + fDepthBias) < traceResult.fDist )\n    {\n\t    float fHitU = Cross2d( vOA, vRayDir.xz ) * rcpdenom;\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        float fSpriteX = fHitU * vSize.x;\n        float fSpriteY = fHitY - vPos.y;\n        if( (fSpriteX >= 0.0) && (fSpriteX < vSize.x) )\n        {\n            if( (fSpriteY >= 0.0 ) && (fSpriteY < vSize.y) )\n            {             \t\t\t\t\n                vec2 vSpritePixel = floor( vec2( fSpriteX, fSpriteY ) );\n                vec2 vUV = (vSpritePixel + vSpriteInfo.xy + 0.5 ) \/ iChannelResolution[2].xy;                \n                if ( vUV.x > 1.0 ) vUV.x = 2.0 - vUV.x;\n                vec4 vSpriteSample = texture2D( iChannel2, vUV );\n                if ( vSpriteSample.a > 0.0 )\n                {\n\t\t\t\t\ttraceResult.fDist = fHitT;                    \n                    traceResult.vTexture.rgb = vSpriteSample.rgb;\n                    traceResult.fSector = fSectorId;\n                    traceResult.fLightLevel = 0.0;\n                }                \n            }\n        }\n    }   \n}\n\n#endif\n\nvoid DebugValueSprite( vec3 vRayOrigin, vec3 vRayDir, vec3 vPos, vec2 vSpriteDir, float fValue, vec3 vColor, bool bNoDepthTest, inout TraceResult traceResult )\n{    \n    vec2 vSize = vec2(4.0, 6.0);\n    \n\tvec2 vA = vPos.xz;\n\tvec2 vB = vPos.xz + vSpriteDir;\n    vec2 vD = vB - vA;\n    vec2 vOA = vA - vRayOrigin.xz;\n    float rcpdenom = 1.0 \/ Cross2d( vRayDir.xz, vD ); \n    float fHitT = Cross2d( vOA, vD ) * rcpdenom;    \n    \n    if ( fHitT > 0.0 && (fHitT < traceResult.fDist || bNoDepthTest ) )\n    {\n\t    float fHitU = Cross2d( vOA, vRayDir.xz ) * rcpdenom;\n        float fHitY = vRayDir.y * fHitT + vRayOrigin.y;\n        float fSpriteX = fHitU;\n        float fSpriteY = fHitY - vPos.y;\n\n        {                        \n            vec2 vSpritePixel = vec2( fSpriteX, fSpriteY ) \/ vSize;\n\n            float fText = PrintValue( vSpritePixel, fValue, 4.0, 2.0 );\n\n            if ( fText > 0.0 )\n            {\n                traceResult.fDist = fHitT;                    \n                traceResult.vTexture.rgb = vColor;\n                traceResult.fSector = 0.0;\n                traceResult.fLightLevel = 0.0;\n            }                \n        }\n    }   \n}\n\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Sprite Crop Sheet Info\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n#define SPR_RIGHT(V) vec2((V.x + V.z), V.y)\n#define SPR_ABOVE(V) vec2(V.x, (V.y + V.w))\n\nconst vec4 kSpriteNone\t\t\t\t= vec4( 0 );\n\nconst vec4 kSpriteBarrel\t\t\t= vec4(\tSPR_RIGHT(kSpriteNone),\t\t\t\t\t23,32);\nconst vec4 kSpriteBarrelExpl\t\t= vec4(\tSPR_RIGHT(kSpriteBarrel),\t\t\t\t32,32);\n\nconst vec4 kSpriteFireball\t\t\t= vec4(\tSPR_RIGHT(kSpriteBarrelExpl),\t\t\t20,20);\nconst vec4 kSpriteFireball2\t\t\t= vec4(\tSPR_RIGHT(kSpriteFireball),\t\t\t\t24,24);\n\nconst vec4 kSpriteHealthBonus\t\t= vec4(\tSPR_RIGHT(kSpriteFireball2),\t\t\t16,16);\nconst vec4 kSpriteArmorBonus\t\t= vec4(\tSPR_ABOVE(kSpriteHealthBonus),\t\t\t16,15);\nconst vec4 kSpriteMedikit\t\t\t= vec4(\tSPR_RIGHT(kSpriteHealthBonus),\t\t\t28,19);\nconst vec4 kSpriteStimpack\t\t\t= vec4(\tSPR_RIGHT(kSpriteMedikit),\t\t\t\t16,19);\nconst vec4 kSpriteBlueArmor\t\t\t= vec4(\tSPR_RIGHT(kSpriteStimpack),\t\t\t\t32,24);\nconst vec4 kSpriteGreenArmor\t\t= vec4(\tSPR_RIGHT(kSpriteBlueArmor),\t\t\t32,24);\nconst vec4 kSpriteShotgun\t\t\t= vec4(\tSPR_RIGHT(kSpriteGreenArmor),\t\t\t32,16);\n\nconst vec4 kSpriteWallImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteShotgun),\t\t\t\t6,6);\nconst vec4 kSpriteWallSmokeImpact1\t= vec4(\tSPR_RIGHT(kSpriteWallImpact1),\t\t\t8,16);\nconst vec4 kSpriteFleshImpact1\t\t= vec4(\tSPR_RIGHT(kSpriteWallSmokeImpact1),\t\t8,8);\n\nconst vec4 kSpriteBloodyMess\t\t= vec4(\tSPR_RIGHT(kSpriteFleshImpact1) + vec2(0,16),\t\t42,16);\nconst vec4 kSpriteDeadTrooper \t\t= vec4(\tSPR_RIGHT(kSpriteBloodyMess),\t\t\t42,16);\nconst vec4 kSpriteDeadSergeant \t\t= vec4(\tSPR_RIGHT(kSpriteDeadTrooper),\t\t\t42,16);\nconst vec4 kSpriteDeadImp \t\t\t= vec4(\tSPR_RIGHT(kSpriteDeadSergeant),\t\t\t42,16);\n\nconst vec4 kSpriteBarrelExpl2\t\t= vec4(\t480,0,\t\t\t\t\t\t\t\t\t38,48);\n\nconst vec4 kSpriteFloorLamp\t\t\t= vec4(\t480,48,\t\t\t\t\t\t\t\t\t23,48);\nconst vec4 kSpriteTallTechnoPillar\t= vec4(\tSPR_ABOVE(kSpriteFloorLamp),\t\t\t38,128);\n\nconst vec4 kSpriteEnemyBegin = vec4(0, 32., 32, 52);\n\n\n#define SPRITE_ENEMY_ACTION_STAND \t\t0.\n#define SPRITE_ENEMY_ACTION_ATTACK\t\t1.\n#define SPRITE_ENEMY_ACTION_WALK1 \t\t2.\n#define SPRITE_ENEMY_ACTION_WALK2 \t\t3.\n#define SPRITE_ENEMY_ACTION_PAIN \t\t4.\n#define SPRITE_ENEMY_ACTION_DIE \t\t5.\n\n#define SPRITE_ENEMY_ACTION_COUNT \t\t6\n\n#define SPRITE_ENEMY_ACTION_DEAD\t\t10.\n\n#define SPRITE_ENEMY_TYPE_TROOPER \t0.\n#define SPRITE_ENEMY_TYPE_IMP \t\t1.\n#define SPRITE_ENEMY_TYPE_SERGEANT \t2.\n\n#define SPRITE_ENEMY_TYPE_COUNT     3\n\nvec4 GetEnemySprite( float fType, float fAction, float fDirection )\n{\n    vec2 vGridPos = vec2( fType + fDirection * float(SPRITE_ENEMY_TYPE_COUNT), fAction );\n    vec2 vPos = kSpriteEnemyBegin.xy +kSpriteEnemyBegin.zw * vGridPos;\n\treturn vec4( vPos, kSpriteEnemyBegin.zw );\n}\n\n#ifdef TEXTURE_PREVIEW\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n    float fTexture = TEXTURE_PREVIEW;\n    \n    vec2 vTexCoord = floor( fragCoord.xy ) \/ 2.5;\n    fragColor.rgb = SampleTexture( fTexture, vTexCoord );    \n    fragColor.a = 1.0;\n}\n#else\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord )\n{\n\tvec2 vOrigUV = fragCoord.xy \/ iResolution.xy;\n    \n    vec2 vResolution = min( iResolution.xy, vec2( 320.0, 200.0 - 32.0 ) );\n    \n    vec2 vUV = fragCoord.xy \/ vResolution;\n    if ( any( lessThan( vUV, vec2(0) ) ) ||  any( greaterThanEqual( vUV, vec2(1.) )) )\n             discard;\n    \n\tvec3 vCameraPos = vec3(0.0);\n\tvec3 vCameraTarget = vec3(0.0);\n        \n    vec2 vMouse = (iMouse.xy \/ iResolution.xy);\n\t\n    \n    Entity playerEnt = Entity_Read( 0.0 );\n    vCameraPos = playerEnt.vPos;\n    \n    float fDeathFall = 0.0;\n    \n    \/\/ Death\n    if( playerEnt.fHealth <= 0.0 )\n    {\n        fDeathFall = 1.0 - (playerEnt.fTimer \/ 1.5);\n    }\n    \n    vCameraPos.y += 6.0 + 34.0 * (1.0 - fDeathFall);\n\n    Sector playerSector = Map_ReadSector( playerEnt.fSectorId );\n\n    \n    #ifdef HEAD_BOB\n\tfloat fBob = sin(vCameraPos.x* 0.04) * 4.0; \/\/ head bob\n    vCameraPos.y += fBob;\n    #endif\n        \n    \/\/ Door crush\n    vCameraPos.y = min( vCameraPos.y, playerSector.fCeilingHeight - 1.0 );\n    vCameraPos.y = max( vCameraPos.y, playerSector.fFloorHeight + 0.001 );\n    \n    vCameraTarget = vCameraPos;\n\n    \/\/ Mouselook\n    float fSinPitch = sin(playerEnt.fPitch);\n    float fCosPitch = cos(playerEnt.fPitch);\n    vCameraTarget.y += fSinPitch;\n    \/\/playerEnt.fYaw += (vMouse.x - 0.5 )* 3.0;\n\n    vCameraTarget.x += sin( playerEnt.fYaw ) * fCosPitch;\n    vCameraTarget.z += cos( playerEnt.fYaw ) * fCosPitch;\n    \n    \n    vec2 vWindowCoord =\t(vUV * 2.0 - 1.0) * vec2(vResolution.x \/ vResolution.y, 1.0);\n\t\n    vec3 vRayOrigin = vCameraPos;\n    vec3 vRayDir = GetCameraRayDir( vWindowCoord, vCameraPos, vCameraTarget );\n    \n    float fNoFog = 0.0;\n\tMapInfo mapInfo = ReadMapInfo();\n    \n\tTraceResult traceResult;\t\n    traceResult = Map_Trace( mapInfo, vRayOrigin, vRayDir, playerEnt.fSectorId, FAR_CLIP );\n\n\tvec3 vForwards = normalize(vCameraTarget - vCameraPos); \n    \n    \/\/ sky    \n    #ifdef DRAW_SKY\n    float fDoSky = step(0.9, traceResult.vTexture.z) * step(traceResult.vTexture.z, 1.1);\n    \n    fNoFog = max(fNoFog, fDoSky);\n    float fSkyU = (atan(vForwards.x, vForwards.z) * 768.0 \/ radians(180.0)) + vUV.x * vResolution.x;\n    float fSkyV = (vUV.y + fSinPitch) * 210.0 + 41.0;\n    fSkyV = min( fSkyV, 255.0 );\n    traceResult.vTexture.st = mix( traceResult.vTexture.st, vec2(fSkyU, fSkyV), fDoSky);\n    \/\/ add extra light for sky, will be clamped to 1.0 later\n    traceResult.fLightLevel = mix( traceResult.fLightLevel, 100.0, fDoSky );\n\t#endif    \n\n    \/\/ Resovle level textures here\n\ttraceResult.vTexture.rgb = SampleTexture( traceResult.vTexture.z, traceResult.vTexture.st );    \n    \n\n    #ifdef ENABLE_SPRITES\n\tvec2 vSpriteDir = -normalize(vec2(-vForwards.z, vForwards.x));\n\t    \n    for( int iEnt=0; iEnt<int(ENTITY_MAX_COUNT); iEnt++)\n    {\n        float fFlipSprite = 1.0;\n        vec4 vSpriteInfo = kSpriteNone;\n\t\tEntity entity = Entity_Read( float(iEnt) );\n        if ( entity.fType == ENTITY_TYPE_BARREL )\n        {\n            if( entity.fSubType == ENTITY_SUB_TYPE_BARREL_EXPLODING && entity.fTimer < 0.05 )\n            {\n                vSpriteInfo = kSpriteBarrelExpl2;                                      \n\t\t\t\tentity.fSectorId = 0.; \/\/ hack fullbright\n    \t\t}\n            else\n            if( entity.fSubType == ENTITY_SUB_TYPE_BARREL_EXPLODING && entity.fTimer < 0.2 )\n            {                   \n                vSpriteInfo = kSpriteBarrelExpl;\n\t\t\t\tentity.fSectorId = 0.; \/\/ hack fullbright\n            }\n            else\n            {\n                vSpriteInfo = kSpriteBarrel;                \n            }\n        }            \n        else\n        if ( entity.fType == ENTITY_TYPE_ITEM )\n        {\n            if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_HEALTH_BONUS )\n            {\n\t            vSpriteInfo = kSpriteHealthBonus;\n            }\n            else if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_ARMOR_BONUS )\n            {\n\t            vSpriteInfo = kSpriteArmorBonus;\n            }\n            else if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_MEDIKIT )\n            {\n\t            vSpriteInfo = kSpriteMedikit;\n            }\n            else if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_STIMPACK )\n            {\n\t            vSpriteInfo = kSpriteStimpack;\n            }\n            else if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_GREENARMOR )\n            {\n\t            vSpriteInfo = kSpriteGreenArmor;\n            }\n            else if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_BLUEARMOR )\n            {\n\t            vSpriteInfo = kSpriteBlueArmor;\n            }\n            else if ( entity.fSubType == ENTITY_SUB_TYPE_ITEM_SHOTGUN )\n            {\n\t            vSpriteInfo = kSpriteShotgun;\n            }\n            \n            else\n            {\n\t            vSpriteInfo = kSpriteFireball;                \n            }            \n        }\n        else\n        if ( entity.fType == ENTITY_TYPE_DECORATION )\n        {\n    \t    if ( entity.fSubType == ENTITY_SUB_TYPE_DECORATION_BLOODY_MESS )\n\t        {\n\t            vSpriteInfo = kSpriteBloodyMess;\n            }\n            else\n    \t    if ( entity.fSubType == ENTITY_SUB_TYPE_DECORATION_DEAD_TROOPER )\n\t        {\n\t            vSpriteInfo = kSpriteDeadTrooper;\n            }\n            else\n    \t    if ( entity.fSubType == ENTITY_SUB_TYPE_DECORATION_DEAD_SERGEANT )\n\t        {\n\t            vSpriteInfo = kSpriteDeadSergeant;\n            }\n            else\n    \t    if ( entity.fSubType == ENTITY_SUB_TYPE_DECORATION_DEAD_IMP )\n\t        {\n\t            vSpriteInfo = kSpriteDeadImp;\n            }      \n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_DECORATION_FLOOR_LAMP )\n            {\n                vSpriteInfo = kSpriteFloorLamp;\n                entity.fSectorId = 0.; \/\/ hack fullbright\n            }\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_DECORATION_TALL_TECHNO_PILLAR )\n            {\n                vSpriteInfo = kSpriteTallTechnoPillar;\n            }\n        }            \n        else\n        if ( entity.fType == ENTITY_TYPE_ENEMY )\n        {\n            float fAction = SPRITE_ENEMY_ACTION_STAND;\n            \n            if ( entity.fArmor == ENEMY_STATE_FIRE )\n            {\n                fAction = SPRITE_ENEMY_ACTION_ATTACK;\n            }\n            else\n            if ( entity.fArmor == ENEMY_STATE_PAIN )\n            {\n                fAction = SPRITE_ENEMY_ACTION_PAIN;\n\t\t\t}\n            else\n            if ( entity.fArmor == ENEMY_STATE_DIE )\n            {\n                if ( iChannelResolution[2].y < 360.0 )\n                {\t                    \n            \t\tfAction = SPRITE_ENEMY_ACTION_PAIN;\n                }\n                else\n                {\n            \t\tfAction = SPRITE_ENEMY_ACTION_DIE;\n                }\n            }\n            else\n                if ( entity.fArmor == ENEMY_STATE_WALK_RANDOM || entity.fArmor == ENEMY_STATE_WALK_TO_TARGET )\n                {\n                    if( fract( entity.fTimer ) < 0.5 )\n                    {\n                        fAction = SPRITE_ENEMY_ACTION_WALK1;\n                    }\n                    else\n                    {\n                        fAction = SPRITE_ENEMY_ACTION_WALK2;\n                    }\n                }\n            else\n            {\n                fAction = SPRITE_ENEMY_ACTION_STAND;\n            }\n            \n            vec3 vCamToEnt = entity.vPos - playerEnt.vPos;\n            float fCameraYaw = atan( vCamToEnt.z, vCamToEnt.x );\n            float fRelativeYaw = fCameraYaw + entity.fYaw + radians(90.0 + 22.5);\n            float fDirection = (fRelativeYaw \/ radians(45.0)) + 16.0;\n            fDirection = mod( floor(fDirection), 8.0 );\n            if ( fDirection > 4.0 ) \n            {\n                fDirection = 8.0 - fDirection;\n                fFlipSprite = -1.0;\n            }\n            \n            vSpriteInfo = GetEnemySprite( entity.fSubType, fAction, fDirection );\n        }\n        else if ( entity.fType == ENTITY_TYPE_BULLET )\n        {\n            if ( entity.fSubType == ENTITY_SUB_TYPE_BULLET_WALL )\n            {\n                if ( entity.fTimer > (0.3 - 0.1) )\n                {                    \n            \t\tvSpriteInfo = kSpriteWallImpact1;\n                    \/\/ entity.fSectorId = 0.; hack fullbright\n                    \n                }\n                else\n                {\n            \t\tvSpriteInfo = kSpriteWallSmokeImpact1;\n                }\n            }\n            else\n            if ( entity.fSubType == ENTITY_SUB_TYPE_BULLET_FLESH )\n            {\n            \tvSpriteInfo = kSpriteFleshImpact1;\n            }                \n        }    \n        else if ( entity.fType == ENTITY_TYPE_FIREBALL )\n        {\n            entity.vPos.y -= 16.0; \/\/ Centre fireball\n            if ( entity.fSubType == ENTITY_SUB_TYPE_FIREBALL ) \n            {                \n\t\t\t\tvSpriteInfo = kSpriteFireball;\n                entity.fSectorId = 0.; \/\/ hack fullbright\n            }\n            else\n            {\n                vSpriteInfo = kSpriteFireball2;\n                entity.fSectorId = 0.; \/\/ hack fullbright\n            }\n        }\n        \n        Sprite( vRayOrigin, vRayDir, entity.vPos, fFlipSprite * vSpriteDir, entity.fSectorId, vSpriteInfo, traceResult );\n        \n        \/\/ Debug\n\t\t#ifdef DEBUG_ENTITY_INFO\n\t\t{\n            bool bNoDepthTest = false;\n            if( entity.fType == ENTITY_TYPE_ENEMY )\n            {\n            \tDebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,48,0), vSpriteDir, entity.fArmor, vec3(1), bNoDepthTest, traceResult );\n            }\n\n            if( entity.fType != ENTITY_TYPE_NONE )\n            {\n\t            \/\/ Show health\n            \tDebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,32,0), vSpriteDir, entity.fHealth, vec3(1,0,0), bNoDepthTest, traceResult );\n\t            \/\/ Show timer\n            \tDebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,24,0), vSpriteDir, entity.fTimer, vec3(0,0,1), bNoDepthTest, traceResult );\n\n                \/\/ Show sector id\n                \/\/DebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,16,0), vSpriteDir, entity.fSectorId, vec3(1), bNoDepthTest, traceResult );\n                DebugValueSprite( vRayOrigin, vRayDir, entity.vPos + vec3(0,16,0), vSpriteDir, entity.fSubType, vec3(1), bNoDepthTest, traceResult );\n            }\n        }\n        #endif\n    }        \n    #endif\t\n    \n    \/\/ Calculate light levels\n    Sector sector = Map_ReadSector( traceResult.fSector );    \n\ttraceResult.fLightLevel = clamp( sector.fLightLevel + traceResult.fLightLevel + kExtraLight, 0.0, 1.0);\n\n    float fFlash = 0.0;\n    {\n        if(  playerEnt.fHealth > 0.0 )\n        {    \n            float fIntensity;\n            float fReloadTime;\n            float fTimeScale;\n            if ( playerEnt.fUseWeapon == 2.0 )\n            {\n                fReloadTime = 1.0;\n                fTimeScale = 15.0;\n                fIntensity = 0.2;\n                fFlash = 1.0 -  playerEnt.fTimer;\n            }\n            else\n            {\n                fReloadTime = 0.5;\n                fIntensity = 0.1;\n                fTimeScale = 20.0;\n            }\t  \n            fFlash = (fReloadTime -  playerEnt.fTimer) * fTimeScale;\n            fFlash = (1.0 - clamp(fFlash, 0.0, 1.0)) * fIntensity;\n        }        \n    }\n    \n    float fLightLevel = clamp( traceResult.fLightLevel, 0.0, 1.0 );\n    fLightLevel = pow( fLightLevel, 1.5);\n    float fDepth = dot(vRayDir, vForwards) * traceResult.fDist;\n    float fDepthFade = fDepth * kDepthFadeScale;\n    float fApplyFog = 1.0 - fNoFog;\n    fDepthFade -= fFlash;\n    fLightLevel = clamp( fLightLevel - fDepthFade * fApplyFog, 0.0, 1.0 );   \n    \/\/fLightLevel = fLightLevel * fLightLevel;\n    \n    vec3 vResult = traceResult.vTexture.rgb * fLightLevel;\n    \n    vResult = clamp(vResult * 1.2, 0.0, 1.0);\n\n    \n\t\/*\n\t\t\/\/ Debug entity trace\n        \n        float fEntId = -1.0;\n\t\tfloat fEntTraceDist = Entity_Trace( vRayOrigin, vRayDir, 0.0, fEntId );\n        \n        if ( fEntTraceDist < FAR_CLIP )\n        {\n            if ( fEntTraceDist < traceResult.fDist )\n            {\n\t            vResult = vec3( 1, 0, 0 );\n            }\n            else\n            {\n\t            vResult = vec3( 0, 0, 0.5 );                \n\t\t\t}\n        }\n    }*\/\n    \n    #ifdef DISCARD_BACKGROUND    \n    if(traceResult.fSector == SECTOR_NONE)\n    {\n        vResult.rgb = vec3(1,0,1);\n        \/\/discard;\n    }\n\t#endif    \n    \n    #ifdef QUANTIZE_FINAL_IMAGE\n    vResult = Quantize(vResult, 32.0);\n    #endif\n    \n\tfragColor = vec4(vResult, 1.0);\n\n\t#ifdef DEBUG_VALUES\n    vec2 vFontUV = fragCoord \/ vec2( 8, 16 );\n    vFontUV.y -= 7.0;\n    float fFontX = vFontUV.x;\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1), PrintValue(vFontUV, playerEnt.vPos.x, 4., 0.) ); \n    vFontUV.x -= 8.;\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1), PrintValue(vFontUV, playerEnt.vPos.y, 4., 0.) ); \n    vFontUV.x -= 8.;\n    fragColor.rgb = mix( fragColor.rgb, vec3(0,0,1), PrintValue(vFontUV, playerEnt.vPos.z, 4., 0.) ); \n\tvFontUV.x = fFontX;\n    \n    vFontUV.y -= 1.2;\n    fragColor.rgb = mix( fragColor.rgb, vec3(1,0,1), PrintValue(vFontUV, playerEnt.fSectorId, 4., 0.) );\n    #endif\n}\n#endif\n\n\/\/ Textures\n#define TEX_X 0.0\n#define TEX_F_SKY1 1.0\n#define TEX_NUKAGE3 2.0\n#define TEX_FLOOR7_1 3.0\n#define TEX_FLOOR4_8 4.0\n#define TEX_CEIL5_1 5.0\n#define TEX_FLAT5_5 6.0\n#define TEX_FLAT20 7.0\n#define TEX_FLOOR5_1 8.0\n#define TEX_CEIL5_2 9.0\n#define TEX_CEIL3_5 10.0\n#define TEX_TLITE6_5 11.0\n#define TEX_FLAT14 12.0\n#define TEX_FLAT18 13.0\n#define TEX_TLITE6_4 14.0\n#define TEX_FLOOR7_2 15.0\n#define TEX_STEP2 16.0\n#define TEX_TLITE6_1 17.0\n#define TEX_FLOOR1_1 18.0\n#define TEX_FLOOR5_2 19.0\n#define TEX_FLOOR6_2 20.0\n#define TEX_FLAT23 21.0\n#define TEX_TLITE6_6 22.0\n#define TEX_DOOR3 23.0\n#define TEX_LITE3 24.0\n#define TEX_STARTAN3 25.0\n#define TEX_BROWN1 26.0\n#define TEX_DOORSTOP 27.0\n#define TEX_COMPUTE2 28.0\n#define TEX_STEP6 29.0\n#define TEX_BROWN144 30.0\n#define TEX_SUPPORT2 31.0\n#define TEX_STARG3 32.0\n#define TEX_DOORTRAK 33.0\n#define TEX_SLADWALL 34.0\n#define TEX_TEKWALL4 35.0\n#define TEX_SW1COMP 36.0\n#define TEX_BIGDOOR2 37.0\n#define TEX_STARGR1 38.0\n#define TEX_BROWNGRN 39.0\n#define TEX_NUKE24 40.0\n#define TEX_BROWN96 41.0\n#define TEX_BRNBIGR 42.0\n#define TEX_BRNBIGL 43.0\n#define TEX_BRNBIGC 44.0\n#define TEX_STARTAN1 45.0\n#define TEX_EXITDOOR 46.0\n#define TEX_SW1STRTN 47.0\n#define TEX_BIGDOOR4 48.0\n#define TEX_EXITSIGN 49.0\n#define TEX_TEKWALL1 50.0\n#define TEX_COMPTALL 51.0\n#define TEX_COMPSPAN 52.0\n#define TEX_PLANET1 53.0\n#define TEX_COMPTILE 54.0\n#define TEX_STEP1 55.0\n#define TEX_COMPUTE3 56.0\n\n\n\/*\nfloat hash(float p)\n{\n\tvec2 p2 = fract(vec2(p * 5.3983, p * 5.4427));\n    p2 += dot(p2.yx, p2.xy + vec2(21.5351, 14.3137));\n\treturn fract(p2.x * p2.y * 95.4337);\n}\n\nvec3 SampleTexture( const in float fTexture, const in vec2 _vUV )\n{\n    vec2 vTexureSize = vec2(64);    \n    float fXCount = 10.0; \/\/ TODO : base on resolution?\n    \n    vec2 vTexturePos = vec2( mod( floor(fTexture), fXCount ), floor( fTexture \/ fXCount ) ) * vTexureSize;\n    \n    vec2 vPixel = vTexturePos + fract(_vUV \/ vTexureSize) * vTexureSize;\n    \n    vec2 vSampleUV = vPixel \/ iChannelResolution[1].xy;\n    \n    vec4 vSample = texture2D( iChannel1, vSampleUV );\n    \n    return vSample.xyz;\n}\n*\/\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Texture Helpers\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nfloat hash2D(vec2 p)\n{\n\treturn Hash( dot( p, vec2(1.0, 41.0) ) );\t\n}\n\nfloat noise1D( float p )\n{\n\tfloat fl = floor(p);\n\t\n\tfloat h0 = Hash( fl );\n\tfloat h1 = Hash( fl + 1.0 );\n\t\n\tfloat fr = p - fl;\n\tfloat fr2 = fr * fr;\n\tfloat fr3 = fr2 * fr;\n\t\n\tfloat t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tfloat t0 = 1.0 - t1;\n\t\n\treturn h0 * t0\n\t\t + h1 * t1;\n}\n\nfloat noise2D( vec2 p, float r )\n{\n\tvec2 fl = floor(p);\n\n\tfloat h00 = hash2D( mod(fl + vec2(0.0, 0.0), r) );\n\tfloat h10 = hash2D( mod(fl + vec2(1.0, 0.0), r) );\n\tfloat h01 = hash2D( mod(fl + vec2(0.0, 1.0), r) );\n\tfloat h11 = hash2D( mod(fl + vec2(1.0, 1.0), r) );\n\t\n\tvec2 fr = p - fl;\n\t\n\tvec2 fr2 = fr * fr;\n\tvec2 fr3 = fr2 * fr;\n\t\n\tvec2 t1 = 3.0 * fr2 - 2.0 * fr3;\t\n\tvec2 t0 = 1.0 - t1;\n\t\n\treturn h00 * t0.x * t0.y\n\t\t + h10 * t1.x * t0.y\n\t\t + h01 * t0.x * t1.y\n\t\t + h11 * t1.x * t1.y;\n}\n\nfloat fbm( vec2 p, float per )\n{\n\tfloat val = 0.0;\n\tfloat tot = 0.0;\n\tfloat mag = 0.5;\n\n\tp += 0.5;\n\tp = p * (1.0 \/ 8.0);\n\tval += noise2D(p, 4.0) * mag; tot+=mag; p=p*2.0 + 1.234; mag*=per;\t\n\tval += noise2D(p, 8.0) * mag; tot+=mag; p=p*2.0 + 2.456; mag*=per;\n\tval += noise2D(p, 16.0) * mag; tot+=mag; p=p*2.0 + 3.678; mag*=per;\n\tval += noise2D(p, 32.0) * mag; tot+=mag;\n\n\treturn val * (1.0 \/ tot);\n}\n\nfloat Indent(vec2 vTexCoord, vec2 vHigh, vec2 vLow, float fHighIntensity, float fLowIntensity)\n{\n\tvec2 vMin = min(vLow, vHigh);\n\tvec2 vMax = max(vLow, vHigh);\n\tif((vTexCoord.x < vMin.x) || (vTexCoord.x > vMax.x) || (vTexCoord.y < vMin.y) || (vTexCoord.y > vMax.y))\n\t\treturn 1.0;\n\n\tif((vTexCoord.x == vHigh.x) || (vTexCoord.y == vHigh.y))\n\t{\n\t\treturn fHighIntensity;\n\t}\n\t\n\tif((vTexCoord.x == vLow.x) || (vTexCoord.y == vLow.y))\n\t{\n\t\treturn fLowIntensity;\n\t}\n\t\n\treturn 1.0;\n}\n\nvec4 SmoothBump(const in vec2 vTexCoord, const in vec2 vMin, const in vec2 vMax, const in vec2 vLightDir, const in float fSize)\n{\n\tvec2 vNearest = min( max(vTexCoord, vMin), vMax );\n\tvec2 vDelta = vNearest - vTexCoord;\n    float fDeltaLen = length(vDelta);\n\tfloat fDist = (fDeltaLen - fSize) \/ fSize;\n\tvec2 vDir = vDelta;\n    if(fDeltaLen > 0.0) vDir = vDir \/ fDeltaLen;\n\tfloat fShade = dot(vDir, vLightDir);\n\t\/\/return clamp(1.0 - (fDist \/ fSize), 0.0, 1.0) * fShade;\n\tfShade *= clamp(1.0 - abs((fDist)), 0.0, 1.0);\n\treturn vec4( fShade, fDist, (vTexCoord - vMin + fSize) \/ (vMax - vMin + fSize * 2.0) );\n}\n\n\nfloat wrap( const in float x , const in float r )\n{\n\treturn fract( x * (1.0 \/ r) ) * r;\n}\n\nvec4 Hexagon( vec2 vUV )\n{\n\tvec2 vIndex;\n\t\n\tfloat fRow = floor(vUV.y);\n\t\n\tvec2 vLocalUV = vUV;\n\tfloat fRowEven = wrap(fRow, 2.0);\n\tif(fRowEven < 0.5)\n\t{\n\t\tvLocalUV.x += 0.5;\n\t}\n\t\n\tvIndex = floor(vLocalUV);\n\t\n\tvec2 vTileUV = fract(vLocalUV);\n\t{\n\t\tfloat m = 2.0 \/ 3.0;\n\t\tfloat c = 2.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven < 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x -= 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\t{\n\t\tfloat m = -2.0 \/ 3.0;\n\t\tfloat c = 4.0 \/ 3.0;\n\t\tif((vTileUV.x *m + c) < vTileUV.y)\n\t\t{\n\t\t\tif(fRowEven >= 0.5)\n\t\t\t{\n\t\t\t\tvIndex.x += 1.0;\n\t\t\t}\n\t\t\tfRowEven = 1.0 - fRowEven;\t\t\t\t\n\t\t\tvIndex.y += 1.0;\n\t\t}\n\t}\n\t\n\tvec2 vCenter = vIndex - vec2(0.0, -1.0 \/ 3.0);\n\tif(fRowEven > 0.5)\n\t{\n\t\tvCenter.x += 0.5;\n\t}\n\t\n\tvec2 vDelta = vUV - vCenter;\n\t\n\t\/\/vDelta = abs(vDelta);\n\t\n\tfloat d1 = vDelta.x;\n\tfloat d2 = dot(vDelta, normalize(vec2(2.0\/3.0, 1.0)));\n\tfloat d3 = dot(vDelta, normalize(vec2(-2.0\/3.0, 1.0)));\n\t\n\td2 *= 0.9;\n\td3 *= 0.9;\n\t\n\tfloat fDist = max( abs(d1), abs(d2) );\n\tfDist = max( fDist, abs(d3) );\n\t\n\tfloat fTest = max(max(-d1, -d2), d3);\n\t\n\treturn vec4(vIndex, abs(fDist), fTest);\n}\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\n\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\/\/ Textures\n\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\/\n\nvec3 TexNukage3( vec2 vTexCoord, float fRandom)\n{\n\tfloat fBlend = 0.0;\n\tfBlend = smoothstep(0.8, 0.0, fRandom);\n\tfBlend = min(fBlend, smoothstep(1.0, 0.8, fRandom));\n\tfBlend *= 1.5;\n\tvec3 col = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fBlend) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid AddMountain( inout float fShade, const in vec2 vUV, const in float fRandom, const in float fHRandom, const in float fXPos, const in float fWidth, const in float fHeight, const in float fFog)\n{\n\tfloat fYPos = 1.0 - smoothstep( 0.0, 1.0, abs(fract(fXPos - vUV.x + vUV.y * 0.05 + 0.5) - 0.5) * fWidth );\n\tfYPos += fHRandom * 0.05 + fRandom * 0.05;\n\tfYPos *= fHeight;\n\tfloat fDist = fYPos - vUV.y;\n\tif(fDist > 0.0)\n\t{\n\t\tfShade = fRandom * ((1.0 - clamp(sqrt(fDist) * 2.0, 0.0, 1.0)) * 0.3 + 0.1);\n\t\tfShade = mix(fShade, 0.6 + 0.1 * fRandom, fFog);\n\t}\t\n}\n\nvec3 TexFSky1(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fShade = 0.6 + 0.1 * fRandom;\n\t\n\tvec2 vUV = vTexCoord * (1.0 \/ vec2(256.0, 128.0));\n\tvUV.y = 1.0 - vUV.y;\n\t\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 0.25, 1.0, 0.85, 0.5 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.5, 4.0, 0.78, 0.2 );\n\tAddMountain( fShade, vUV, fRandom, fHRandom, 1.94, 2.51, 0.8, 0.0 );\n\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexFloor7_1( vec2 vTexCoord, float fRandom, vec3 vCol1, vec3 vCol2 )\n{\n\tvec3 col = mix( vCol1, vCol2, fRandom * fRandom * 2.5) \/ 255.0;\n\t\n\treturn col;\n}\n\nvec3 TexFlat5_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(63.0, 47.0, 23.0), vec3(147.0, 123.0, 99.0), fRandom) \/ 255.0;\n\t\n\tcol *= mod(vTexCoord.x, 2.0) * 0.15 + 0.85;\n\t\n\treturn col;\n}\n\nvec3 TexFloor4_8( vec2 vTexCoord, float fRandom, vec3 vColA, vec3 vColB )\n{\n\tvec3 col = mix( vColA, vColB, fRandom * fRandom) \/ 255.0;\n\n\tvec4 vHex = Hexagon( vTexCoord.yx \/ 32.0 );\n    \n    float fShadow = (clamp((0.5 - vHex.z) * 15.0, 0.0, 1.0) * 0.5 + 0.5);\n    float fHighlight = 1.0 + clamp(1.0 - (abs(0.45 - vHex.w)) * 32.0, 0.0, 1.0) * 0.5;\n    \n\tcol = col * (clamp((0.5 - vHex.z) * 2.0, 0.0, 1.0) * 0.25 + 0.75);\n    col = col * fHighlight;\n\tcol = col * fShadow;\n\t\n\treturn col;\n}\n\nvec3 TexCeil3_5( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = vec3(1.0);\n\t\n\tvec2 vTileCoord = vTexCoord;\n\tvTileCoord.x -= 17.0;\n\tif( (vTileCoord.x >= 0.0) && (vTileCoord.x < 32.0) ) \n\t\tvTileCoord.y -= 58.0;\n\telse \n\t\tvTileCoord.y -= 11.0;\n\tvTileCoord.x = mod(vTileCoord.x, 32.0);\n\tvTileCoord.y = mod(vTileCoord.y, 64.0);\n\t\t\n\tvec2 vBoxClosest = clamp(vTileCoord, vec2(4.0, 4.0), vec2(28.0, 60.0));\n\tvec2 vDelta = vTileCoord - vBoxClosest;\n\tfloat fDist2 = dot(vDelta, vDelta);\n\n\tconst float fLight1 = 59.0 \/ 255.0;\n\tconst float fMed1 = 55.0 \/ 255.0;\n\tconst float fDark1 = 47.0 \/ 255.0;\n\tconst float fDark2 = 39.0 \/ 255.0;\n\n\tfloat fShade = fMed1;\t\n\tfShade = mix( fShade, fLight1, smoothstep(0.6, 0.45, fRandom) );\n\tfShade = mix( fShade, fDark1, smoothstep(0.45, 0.35, fRandom) );\n\t\n\tfShade = mix( fShade, fDark1, step(1.5, fDist2) );\n\tfShade = mix( fShade, fDark2, step(13.5, fDist2) );\n\t\t\n\tcol *= fShade;\n\t\n\tif((vTileCoord.x < 12.0) || (vTileCoord.x > 20.0) || (vTileCoord.y < 12.0) || (vTileCoord.y > 52.0))\n\t{\n\t\tfloat fRRow = floor(mod(vTileCoord.y - 3.5, 7.5));\n\t\tfloat fRColumn = mod(vTileCoord.x - 15.0, 10.0);\n\t\tif((fRRow == 2.0) && (fRColumn == 0.0))\n\t\t{\n\t\t\tcol -= 0.05;\n\t\t}\n\t\tif((fRRow <= 2.0) && (fRColumn <= 2.0))\n\t\t{\n\t\t\tvec2 vOffset = vec2(fRRow - 1.0, fRColumn - 1.0);\n\t\t\tfloat fDist2 = dot(vOffset, vOffset) \/ 2.0;\n\t\t\tcol += clamp(1.0 - fDist2, 0.0, 1.0) * 0.05;\n\t\t}\n\t}\n\t\n\treturn col;\n}\n\nvec3 TexRandom( vec2 vTexCoord, float fRandom, vec3 vCol0, vec3 vCol1 )\n{\n\treturn mix( vCol0, vCol1, fRandom * fRandom);\n}\n\nfloat SdBox( vec2 vPos, vec2 vSize )\n{\n  vec2 d = abs(vPos) - vSize;\n  return min(max(d.x,d.y),0.0) + length(max(d,0.0));\n}\n\nfloat SdBox( vec2 vPos, vec2 vMin, vec2 vMax )\n{\n    vec2 vMid = (vMin + vMax) * .5;\n    return SdBox( vPos - vMid, (vMax - vMin) * .5 );\n}\n\nfloat BigDoorYellowStripes( vec2 vTexCoord )\n{\n    float fDist = 0.0;\n\n    float fIndentSize = 5.0;\n\n    vTexCoord.x = 64. - abs(vTexCoord.x - 64.);\n    \n    vTexCoord.x = 32. - abs(vTexCoord.x - 32.);\n    \n    float d;\n    d =  min( fIndentSize, -SdBox( vTexCoord, vec2(13,116), vec2(48, 124) ) );\n    fDist = max( fDist, d );\n    \n    float fCorner = clamp( vTexCoord.x - vTexCoord.y + 105., 0.0, 5.0 );\n    fDist = min( fDist, fCorner );\n    \n    return fDist;\n}\n\nfloat BigDoorIndent( vec2 vTexCoord )\n{\n    float fDist = 0.0;\n\n    float d;\n\n    float fIndentSize = 4.0;    \n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(82,19), vec2(93,75) ) );\n    fDist = max( fDist, d );\n        \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(54,20), vec2(68,74) ) );\n    fDist = max( fDist, d );\n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(15, 19), vec2(68, 49) ) );\n    float fCorner = clamp( vTexCoord.x + vTexCoord.y - 50.0, 0.0, 5.0 );\n    d = min( d, fCorner );    \n    fDist = max( fDist, d );\n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(100, 21), vec2(112, 74) ) );    \n    fDist = max( fDist, d );\n\n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(50,123), vec2(79,126) ) );\n    fDist = max( fDist, d );\n    \n    fIndentSize = 2.0;\n    \n    d = min( fIndentSize, -SdBox( vTexCoord, vec2(41,59), vec2(50,110) ) );\n    fDist = max( fDist, d );\n    \n    fIndentSize = 0.5;\n\n    d = min( fIndentSize, SdBox( vTexCoord, vec2(1, 114), vec2(126, 126) ) );\n    fDist = max( fDist, d );\n    \n    \/\/ Rivets\n    {\n        vec2 vCoord = vTexCoord;\n\n        float m = 10.0;\n        float yMax = 128.0;\n        fIndentSize = 0.5;\n        \n        vCoord.x = 64. - abs(vCoord.x - 64.);\n        \n        if ( vCoord.x > 10.0 )\n        {\n            vCoord.x -= 8.0;\n            m = 6.0;\n            \n            yMax = 80.;\n            fIndentSize = 0.25;\n        }\n\n        if ( vCoord.y < yMax )\n        {\n            vCoord.y = mod(vCoord.y, m);\n\n            d = min( 0.0, -fIndentSize + SdBox( vCoord, vec2(2, 3), vec2(4, 5) ) );\n            fDist += d;\n        }\n    }\n    \n    d = min( 1.0, BigDoorYellowStripes( vTexCoord ) );\n    fDist += d;\n \n    return fDist \/ 5.0;\n}\n\nvec3 TexBigDoor2( vec2 vTexCoord, float fRandom, float fHRandom, vec3 vCol0 )\n{\n    float fShade = 1.0;\n    \n    fShade = 1.0 + (BigDoorIndent( vTexCoord ) - BigDoorIndent( vTexCoord  + vec2(.5, 1.))) * 2.0;\n    \n    vec3 vCol = vCol0 * (0.8 + fHRandom * 0.2);\n    \n\tfloat fMirrorX = 64. - abs(vTexCoord.x - 64.);\n    if ( fMirrorX < 6.0 )\n    {\n        vCol *= 0.75;\n    }\n\n    \n    float f = BigDoorYellowStripes( vTexCoord );\n    if ( f > 0.0 )\n    {\n        if ( mod(vTexCoord.x + vTexCoord.y, 16.0) > 8.0)\n        {\n    \t\tvCol = vec3(175,123,31) \/255.;\n\t\t}\n        else\n        {\n    \t\tvCol = vec3(47)\/255.;\n        }\n    }\n    \n    vCol *= (fHRandom + vTexCoord.y \/ 128.0) * 0.2 + 0.8;\n    vCol *= fRandom * 0.3 + 0.7;\n    \n    float fStreak = 1.0 - clamp( fract(fHRandom * 8.0 + vTexCoord.y \/ 128.0) * 3.0, 0.0, 1.0);\n    fStreak = fStreak * (fHRandom * fHRandom * 0.7 + 0.3);\n    vCol = mix(vCol, vec3(95,67,35)\/255., fStreak );\n    \n\treturn vCol * fShade; \n}\n\nvec3 TexDoor3(vec2 vTexCoord, float fRandom, float fHRandom)\n{\n\tfloat fVNoise = fHRandom + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\n\tfloat fShade = 1.0;\n\t\n\tfShade = 1.0 - abs((vTexCoord.y \/ 72.0) - 0.5) * 2.0;\n\tfShade = fShade * fShade;\n\tfShade = fShade * 0.2 + 0.3;\n\t\n\tfShade = fShade * (fHRandom * 0.2 + 0.8);\n\t\n\tfShade *= Indent( vTexCoord, vec2(8.0, 8.0), vec2(64.0 - 8.0, 72.0 - 16.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(8.0, 72.0 - 15.0), vec2(64.0 - 8.0, 72.0 - 8.0), 0.8, 1.2);\n\t\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 46.0), vec2(46.0, 32.0), 0.8, 1.2);\n\tfShade *= Indent( vTexCoord, vec2(64.0 - 11.0, 56.0), vec2(46.0, 52.0), 0.8, 1.2);\n\t\n\tfShade += fRandom * 0.1;\n\n\tfloat fStreakTopAmount = smoothstep( 32.0, 0.0, vTexCoord.y );\n\tfloat fStreakBottomAmount = smoothstep( 72.0 -32.0, 72.0, vTexCoord.y );\n\t\n\tfShade *= 1.0 - fStreak * max(fStreakTopAmount, fStreakBottomAmount) * 0.2;\n\t\n\tif( (vTexCoord.x > 8.0) && (vTexCoord.x < 52.0) )\n\t{\n\t\tvec2 vRepeatCoord = mod( vTexCoord, vec2( 8.0, 48.0 ) );\n\t\tvRepeatCoord += vec2(4.0, -12.0);\n\t\tif( vRepeatCoord.x == 4.0 )\n\t\t{\n\t\t\tif(vRepeatCoord.y == 0.0)\n\t\t\t{\n\t\t\t\tfShade += 0.1;\n\t\t\t}\n\t\t\tif(vRepeatCoord.y > 0.0)\n\t\t\t{\n\t\t\t\tfShade *= clamp(vRepeatCoord.y \/ 16.0, 0.0, 1.0) * 0.3 + 0.7;\n\t\t\t}\n\t\t}\n\t}\n\t\n\treturn vec3(fShade);\n}\n\nvec3 TexLite3( vec2 vTexCoord )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord.y = mod(vLocalCoord.y, 8.0 );\n\t\n\tvec2 vClosest = min( max( vLocalCoord, vec2(4.0, 3.5) ), vec2(32.0 - 5.0, 3.5) );\n\tvec2 vDelta = vLocalCoord - vClosest;\n\tfloat fDist = max(abs(vDelta.x), abs(vDelta.y)) \/ 3.9;\n\t\n\treturn vec3(1.0 - fDist * 0.65);\n}\n\nvec3 TexTLite6_4( vec2 vTexCoord, float fRandom, vec3 vFlatCol, vec3 vLightCol )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord = mod(vLocalCoord, 64.0 );\n\t\n    vec2 vAbsLocal = abs( vLocalCoord - 32. );\n    \n    float fDist = (vAbsLocal.x + vAbsLocal.y) \/ 16.0;\n    fDist = fDist * fDist;\n    \n    if ( fDist > 1.0 )\n    {\n        return vFlatCol * (0.5 + fRandom * 0.5);\n    }\n    \n    float fLight = clamp(1.0 - fDist * fDist, 0.0, 1.0);\n\treturn min( vec3(1.0), vLightCol * (fLight * 0.75 + 0.25) + pow( fLight, 5.0 ) * 0.4);    \n}\n\nvec3 TexTLite6_5( vec2 vTexCoord, float fRandom, vec3 vFlatCol, vec3 vLightCol )\n{\n\tvec2 vLocalCoord = vTexCoord;\n\tvLocalCoord = mod(vLocalCoord, 32.0 );\n\t\n    float fDist = length( vLocalCoord - 16. ) \/ 8.0;\n    \n    if ( fDist > 1.0 )\n    {\n        return vFlatCol * (0.5 + fRandom * 0.5);\n    }\n    \n    float fLight = clamp(1.0 - fDist * fDist, 0.0, 1.0);\n\treturn min( vec3(1.0), vLightCol * (fLight * 0.75 + 0.25) + pow( fLight, 5.0 ) * 0.4);    \n}\n   \n\nvec3 TexStartan3( vec2 vTexCoord, float fRandom, vec3 col0, vec3 col1 )\n{\n\tvec3 col = col0;\n\t\n\tfloat fVNoise = noise1D(vTexCoord.x * 0.5) - ((vTexCoord.y) \/ 128.0) + fRandom;\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\t\t\n\tfloat fBlend2 = smoothstep( 0.0, 32.0, abs(vTexCoord.x - 64.0) );\n\tfBlend2 *= fBlend2;\n\tfBlend2 *= fStreak * 0.5 + 0.5;\n\tcol = mix( col, col1, fBlend2 * 0.5);\n\t\n\tfloat fBlend = smoothstep( 24.0, 56.0, abs(vTexCoord.x - 64.0) );\n\tfBlend *= fBlend;\n\tfBlend *= fStreak * 0.7 + 0.3;\n\tcol = mix( col, col1 * 1.1, fBlend);\n\t\n\tcol *= fRandom * fRandom * 0.3 + 0.7;\n\n\tvec2 vCoord = vTexCoord;\n\tvCoord.x = mod(vCoord.x, 32.0);\n\t\n\tfloat fStreakHL = fStreak * 0.075 + 0.075;\n\t\n\tfloat fDistMin = 1.0;\n\tfloat fShade = 0.0;\n\t\n\tvec4 vBump = SmoothBump( vCoord, vec2(6.0, 8.0), vec2(32.0 - 5.0, 9.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfDistMin = min(fDistMin, vBump.y);\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tvBump = SmoothBump( vCoord, vec2(6.0, 20.0), vec2(32.0 - 6.0, 40.0), normalize(vec2(0.0, 1.0)), 3.0 ); \n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vCoord, vec2(6.0, 64.0), vec2(32.0 - 6.0, 65.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vCoord, vec2(6.0, 76.0), vec2(32.0 - 6.0, 110.0), normalize(vec2(0.0, 1.0)), 3.0 ) ;\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 50.0), vec2(256.0, 52.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.1;\n\tfShade += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (1.0 - vBump.w) * fStreakHL : 0.0;\n\tfDistMin = min(fDistMin, vBump.y);\n\tvBump = SmoothBump( vTexCoord, vec2(-16.0, 122.0), vec2(256.0, 200.0), normalize(vec2(0.0, 1.0)), 3.0 );\n\tfShade += vBump.x * 0.05;\n\tfDistMin = min(fDistMin, vBump.y);\n\n\tcol *= 1.0 + fShade * 3.0;\n\n\tcol *= clamp((1.0 - fDistMin) * 1.0, 0.0, 1.0) * 0.3 + 0.7;\n\n\treturn col;\n}\n\nvec3 TexBrown1( vec2 vTexCoord, float fRandom, float fHRandom, vec3 vColA, vec3 vColB, vec3 vDirtCol )\n{\n\tvec3 col = mix( vColA, vColB, fRandom * fRandom) \/ 255.0;\n\n\tif(vTexCoord.x >= 64.0)\n\t{\n\t\tcol = col * vec3(1.0, 0.848, 0.646);\n\t\t\n\t\tcol = mix( col, vec3( 0.111, 0.414, 0.3), clamp((fRandom -0.5) * 2.0, 0.0, 1.0)); \/\/ green bits\n\t}\n\t\n\tfloat fVNoise = fHRandom + fRandom;\n\t\n\tfloat fStreak = clamp(abs(fract(fVNoise) - 0.5) * 3.0, 0.0, 1.0);\n\tfStreak = fStreak * fStreak;\n\n\tvec2 vRepeatCoord = vTexCoord;\n\tvRepeatCoord.x = mod(vRepeatCoord.x, 13.0);\n\t\n\tvec4 vBump = SmoothBump( vRepeatCoord, vec2( 5.0, 6.0 ), vec2( 5.0, 12.0), vec2(0.0, 1.0), 1.5);\n\tfloat fMask = clamp(1.0 - vBump.y, 0.0, 1.0);\n\t\n\tfloat fStreakAmount = 1.0;\n\tfStreakAmount *= smoothstep( 0.0, 8.0, vRepeatCoord.y );\n\tfloat fStreakWidth = smoothstep( 64.0, 12.0, vRepeatCoord.y );\n\tfloat fBase1Dist = smoothstep( 24.0, 75.0, vRepeatCoord.y ) * step(vRepeatCoord.y, 75.0);\n\tfloat fBase2Dist = smoothstep( 96.0, 127.0, vRepeatCoord.y );\/\/ * step(75.0, vRepeatCoord.y);\n\tfloat fBaseDist = max(fBase1Dist, fBase2Dist);\n\tfStreakWidth = max( fStreakWidth, fBaseDist);\n\tfloat fTop2Dist = smoothstep( 127.0, 75.0, vRepeatCoord.y ) * step(75.0, vRepeatCoord.y);\n\tfStreakWidth = max(fStreakWidth, fTop2Dist);\n\tfloat fStreakX = abs(vRepeatCoord.x - 5.0) \/ 8.0;\n\tfStreakAmount *= fStreakWidth;\n\tfStreakAmount *= smoothstep( fStreakWidth, 0.0, fStreakX);\n\tfStreakAmount = max(fStreakAmount, (fBaseDist - 0.75) * 4.0);\n\tfStreakAmount *= 1.0 - fMask; \n\tcol = mix(col, vDirtCol, fStreakAmount * (fStreak * 0.5 + 0.5) );\n\t\n\tcol += ((vBump.w >= 0.0) && (vBump.w <= 1.0)) ? (vBump.w) * (1.0-vBump.y) * 0.05 : 0.0;\n\t\n\tif((vTexCoord.y == 17.0) || (vTexCoord.y == 73.0)) col *= 0.9;\n\tif((vTexCoord.y == 19.0) || (vTexCoord.y == 75.0)) col *= 1.2;\n\n\tcol *= 1.0 + clamp(vBump.x, -1.0, 0.0) * 0.6;\n\t\t\n\treturn col;\n}\n\nvec3 TexDoorstop( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = 1.0 - abs(vTexCoord.x - 3.4) \/ 4.0;\n\t\n\tfShade = fShade * 0.2 + 0.2;\n\t\n\tfloat fSin = sin((vTexCoord.y - 16.0) * 3.14150 * 4.0 \/ 128.0) * 0.5 + 0.5;\n\tfShade *= 0.8 + fRandom * 1.2 * fSin;\n\t\n\treturn vec3(fShade);\n}\n\nvoid DrawScreen(inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, const in vec3 vCol)\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n\t\tcol = vCol;\n\t}\n}\n\nbool Screen( inout vec3 col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, out vec2 vUV )\n{\n\tvec2 vScreenCoord = vTexCoord - vPos;\n\tcol *= Indent( vScreenCoord, vSize, vec2(-1.0), 1.2, 0.5);\n\n    vUV = vScreenCoord \/ vSize;\n    \n\tif((vScreenCoord.x >= 0.0) && (vScreenCoord.y >= 0.0) && (vScreenCoord.x < vSize.x) && (vScreenCoord.y < vSize.y))\n\t{\n        return true;\n\t}\n    return false;\n}\n\n\nvec3 TexCompute2( vec2 vTexCoord, float fRandom )\n{\n    fRandom = 1.0 - fRandom * fRandom;\n\tvec3 col = vec3(35.0 \/ 255.0);\n\t\n\tcol *= Indent( vTexCoord, vec2( -8.0, 0.0), vec2(300.0, 10.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 11.0), vec2(300.0, 27.0), 1.3, 0.5);\n\tcol *= Indent( vTexCoord, vec2( -8.0, 28.0), vec2(300.0, 43.0), 1.3, 0.5);\n\t{\n\t\tvec2 vLocalCoord = vTexCoord;\n\t\tvLocalCoord.x = mod(vLocalCoord.x, 21.0);\n\t\tcol *= Indent( vLocalCoord, vec2( 0.0, 44.0), vec2(20.0, 55.0), 1.3, 0.5);\n\t}\n\n\tif(vTexCoord.y < 40.0)\n\t{\n\t\tvec2 vTileSize = vec2(48.0, 14.0);\n\t\tvec2 vIndex = floor(vTexCoord \/ vTileSize);\n\n\t\tfloat fIndex = vIndex.x + vIndex.y * 13.0;\n\t\tvec2 vMin = vIndex * vTileSize + vec2(Hash(fIndex) * 32.0, 4.0);\n\t\tvec2 vSize = vec2(8.0 + Hash(fIndex + 1.0) * 32.0, 4.0);\n\n\t\tvec3 vCol = vec3(0.0);\n\t\tfloat iIndex = floor(mod(fIndex, 5.0));\n\t\tif( iIndex < 0.5 ) \n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.5, 0.0), vec3(0.0, 0.25, 0.0), fRandom);\n\t\t}\n\t\telse if(iIndex < 1.5)\n\t\t{\n\t\t\tvCol = mix(vec3(1.0, 0.6, 0.02), vec3(0.1), fRandom);\n\t\t}\n\t\telse if(iIndex < 2.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.5);\n\t\t}\n\t\telse if(iIndex < 3.5)\n\t\t{\n\t\t\tvCol = vec3(fRandom * 0.25);\n\t\t}\n\t\telse if(iIndex < 4.5)\n\t\t{\n\t\t\tvCol = mix(vec3(0.0, 0.0, 0.5), vec3(0.1), fRandom);\n\t\t}\n\t\tDrawScreen(col, vTexCoord, vMin, vSize, vCol);\n\t}\n\n\treturn col;\n}\n\nvec3 TexStep6( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(87.0, 67.0, 51.0), vec3(119.0, 95.0, 75.0), fRandom) \/ 255.0;\n\n\tcol *= Indent( vTexCoord, vec2(-1.0, 3.0), vec2(32.0, 1.0), 1.3, 0.7);\n\tcol *= Indent( vTexCoord, vec2(-1.0, 8.0), vec2(32.0, 0.0), 1.3, 0.9);\n\n\tfloat fStreak = clamp((vTexCoord.y \/ 16.0) * 1.5 - fHRandom, 0.0, 1.0);\n\n\tcol *= fStreak * 0.3 + 0.7;\n\t\n\treturn col;\n}\n\nvec3 TexSupport2( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col;\n\tfloat fShade = 0.5;\n\t\n\tfloat f1 = abs(fract((vTexCoord.y + 32.0) \/ 70.0) - 0.5) * 2.0;\n\tfloat f2 = abs(fract((vTexCoord.x + 16.0) \/ 16.0) - 0.5) * 2.0;\n\tfShade += f1 * 0.75 + f2 * 0.25;\n\tfShade = fShade * fShade;\n\n\tfShade = fShade * 0.2 + 0.05;\n\tfShade *= 1.0 + fRandom * 0.4;\n\n\tvec2 vLocalCoord = vTexCoord;\n\tif((vLocalCoord.y < 64.0) || (vLocalCoord.y > 75.0))\n\t{\n\t\tif(vLocalCoord.y > 64.0) vLocalCoord.y -= 8.0;\n\t\tvLocalCoord = mod( vLocalCoord, vec2(20.0, 16.0));\n\t\tfloat fIndent = Indent( vLocalCoord, vec2(8.0, 8.0), vec2(16.0, 15.0), 0.9, 1.1);\n\t\tfShade += fIndent - 1.0;\n\t}\n\t\n\tcol = vec3(fShade);\n\t\n\treturn col;\n}\n\nvec3 TexDoorTrak( vec2 vTexCoord, float fRandom )\n{\n\tfloat fShade = fRandom * 0.5;\n\tfShade *= mod(vTexCoord.x, 2.0) * 0.6 + 0.4;\n\treturn vec3(fShade);\n}\n\nvec3 TexBrown144( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 43.0, 19.0), fRandom) \/ 255.0;\n\t\n\tfloat fBlend = fHRandom - 0.1;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n\tcol = mix( col, col * 2.0 * vec3(0.893, 0.725, 0.161), fBlend);\n\treturn col;\n}\n\nvec3 TexNuke24( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n\tvec3 col = mix( vec3(51.0, 43.0, 19.0), vec3(79.0, 59, 35.0), fRandom) \/ 255.0;\n\tvec3 colNuke = mix( vec3(11.0, 23.0, 7.0), vec3(46.0, 83, 39.0), fRandom) * 2.5 \/ 255.0;\n\tfloat fBlend = -0.25 -fHRandom + vTexCoord.y \/ 12.0;\/\/ * 3.0;\n\tfBlend = clamp(fBlend, 0.0, 1.0);\n    fBlend= fBlend * fBlend;\n\tcol = mix( col, colNuke, fBlend);    \n\treturn col;\n}\n\nvec3 TexPlanet1( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    float fShade;\n    float fMirrorY = 64.0 - abs(vTexCoord.y - 64.0);\n    \n    fShade = cos( 3.14 * (fMirrorY - 36.0) \/ 36.0 ) * 0.5 + 0.5;\n    fShade *= fRandom * 0.5 + 0.5;\n\n    float fStreak = clamp(0.0, 1.0, fHRandom + fMirrorY \/ 32.0);\n    fShade *= fStreak;\n    \n\tvec3 col = mix( vec3(59), vec3(147), fShade) \/ 255.0;\n\n    vec2 vMin = vec2(4,7);\n    vec2 vMax = vec2(58,60);\n    \n    float fIndex = 0.0;\n    \n    if ( vTexCoord.x > 128.0 )\n    {\n        vMin.x += 128.;\n        vMax.x += 128.;\n        \n        fIndex += 2.0;\n    }\n    else\n    if ( vTexCoord.x > 64.0 )\n    {\n        vMin.x += 64.;\n        vMax.x += 64.;\n        \n        fIndex += 1.0;\n    }\n    \n    if ( vTexCoord.y > 64.0 )\n    {\n        vMin.y += 62.;\n        vMax.y += 62.;\n        \n        fIndex += 3.0;\n    }\n    \n    if ( all( greaterThanEqual( vTexCoord, vMin ) ) &&\n         all( lessThanEqual( vTexCoord, vMax ) ))\n    {\n        col = vec3(0.0);\n        \n        vec2 vUV = (vTexCoord - (vMin + 1.0)) \/ (vMax - vMin - 2.);\n\t    if ( all( greaterThanEqual( vUV, vec2(0.0) ) ) &&\n    \t     all( lessThan( vUV, vec2(1.0) ) ))\n    \t{\n            col = vec3(0.0);\n\n            float fSize = mod((1.0 + fIndex) * 1.45, 1.0);\n            float fOffset = mod((1.0 + fIndex) * 1.84, 1.0);\n            \n            vec2 vXY = vUV * 2.0 - 1.0;\n            vXY += fOffset;\n            float l = length(vXY);\n\n            vec3 vPlanetCol = vec3(0.5,0.2,.4) + vec3(8.3,2.24,5.89) * fIndex;\n            vPlanetCol = mod( vPlanetCol, vec3(1));\n            vPlanetCol *= vec3(1., .2, .01);\n            vPlanetCol = normalize(vPlanetCol);\n            \n            if ( fIndex == 4.0 )\n            {\n            \tcol = vPlanetCol * max( 0.0, fRandom - l * 0.5 );\n            }\n            else\n            {\n            \t\/\/ planet                       \n                if ( l < fSize )\n                {                \n                    col = vPlanetCol;\n\n                    vec3 vLight = vec3(0.1,0.5,.4) + vec3(5.435,32.345,32.923) * fIndex;\n                    vLight = mod( vLight, 1.0);\n                    vLight.xy = vLight.xy * 2.0 - 1.0;\n                    vLight = normalize(vLight);\n\n\n                    vec2 vD = vXY;\n                    vec3 vNorm = vec3(vD, sqrt( fSize * fSize - l * l ));\n                    float fPlanetShade = max(0.0, dot( vNorm, vLight));\n                    col *= fPlanetShade; \n                }\n                else\n                {\n                    float f = min(1.0, fRandom \/ .75);\n                    col = vec3(1.) * pow( f, 100.0) * 0.25;\n                    \/*\n                    if ( fRandom > 0.75 )\n                    {\n                        col = vec3(0.5);\n                    }*\/\n                }\n            }\n            \n            \n            col += 0.1;\n            \/\/ sheen\n            col += max(0.0, 1.0 - (vUV.x + vUV.y) * 2.0) * 0.3;\n        }\n        \n    }\n\t\/\/if( Screen( col, const in vec2 vTexCoord, const in vec2 vPos, const in vec2 vSize, out vec2 vUV )\n    \n    \n\treturn col;    \n}\n\nfloat Line( vec2 vCoord, vec2 vA, vec2 vB )\n{\n    vec2 vDelta = vB - vA;\n    vec2 vDir = normalize(vDelta);\n    vec2 vOffset = vCoord - vA;\n    \n    float fProj = dot( vOffset, vDir );\n    \n     fProj = clamp( fProj, 0.0, length(vDelta) );\n    vec2 vClosest = vA + vDir * fProj;\n    \n    float d = max(0.0, 1.0 - length( vClosest - vCoord ) * 0.25);\n    return d * d * d;\n    \/\/return 0.0;\n}\n\nvec3 TexExitSign( vec2 vTexCoord, float fRandom, float fHRandom )\n{\n    vec3 vCol = vec3(59) \/ 255.;\n    \n    vec2 vBevelMin = vec2(1,1);\n    vec2 vBevelMax = vec2(30,14);\n   \n    if ( vTexCoord.y == (vBevelMin.y-1.) )\n    {\n        vCol *= 1.5;\n    }\n    if ( vTexCoord.y == (vBevelMax.y+1.) )\n    {\n        vCol *= 0.5;\n    }\n    if ( vTexCoord.x == (vBevelMin.x-1.) )\n    {\n        vCol *= 1.1;\n    }\n    if ( vTexCoord.x == (vBevelMax.x+1.) )\n    {\n        vCol *= 0.75;\n    }\n    \n    if ( all( greaterThanEqual(vTexCoord, vec2(2,2) ) ) &&\n        all( lessThanEqual(vTexCoord, vec2(29,13) ) )         \n    )\n    {\n        vCol = vec3(0.0);\n        \n        vec3 vLetterCol = vec3(227,0,0) \/ 255.;\n        vLetterCol *= 1.0 - (vTexCoord.y \/ 30.0);\n        \n        \/\/ Verticals\n        vec2 vA = vec2(4,4);\n        vec2 vB = vec2(4,11);\n        \n        if ( vTexCoord.x > 23. ) \n        {\n            vA.x = vB.x = 25.0;\n    \t}\n        else\n        if ( vTexCoord.x > 15. ) \n        {\n            vA.x = vB.x = 20.0;\n            \n        }\n                \n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vA, vB ) );\n        \n        \/\/ Horizontals\n        vA = vec2(4,4);\n        vB = vec2(9,4);\n        \n        if ( vTexCoord.x > 20. ) \n        {\n            vA.x = 22.;\n            vB.x = 28.;\n        }\n        else\n        if ( vTexCoord.y > 10. ) \n        {\n            vA.y = 11.;\n            vB.y = 11.;\n        }\n        else\n        if ( vTexCoord.y > 4. ) \n        {\n            vA.y = 7.;\n            vB.y = 7.;\n            vB.x = 7.;\n        }\n        \n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vA, vB ) );\n                \n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vec2(11,4), vec2(18,11) ) );\n        vCol = mix( vCol, vLetterCol, Line( vTexCoord, vec2(11,11), vec2(18,4) ) );\n    }\n    \n    return vCol;\n}\n\n\n\nfloat IsTile( vec2 vTexCoord )\n{\n    float y = 63.5 - abs( vTexCoord.y - 63.5);\n    \n    float f = y - 5.0;\n    float fm = f;\n    \n    float fRepeat = 29. - 13.;\n    \n    float x = 64. - abs(vTexCoord.x - 64.);\n    \n    if ( f > 0.0 && f < fRepeat * 3.5 )\n    {\n    \tfm = mod( fm, fRepeat ); \n    }\n    else\n    {\n        fm = 0.0;\n    }\n        \n    if ( fm > 7.0)\n    {\n\t    if ( x > 23. )\n            return 1.0;\n    }\n    else\n    {\n\t    if ( x > 31. )\n            return 1.0;\n    }\n    return 0.0;\n}\n\nvec3 TexCompTile( vec2 vTexCoord, float fRandom )\n{   \n    \/\/ Blue\n    vec3 vCol0 = vec3(0.0, 0.0, 35.0 \/ 255.0);\n    vec3 vCol1 = vec3(0.0, 0.0, 200.0 \/ 255.0);\n    vec3 blueCol = mix( vCol0, vCol1, fRandom * fRandom * 2.5);\n    \n    if ( IsTile(vTexCoord) > 0.0 )\n    {\n        return blueCol;\n    }\n    \n    vec3 col = vec3(39.\/255.);\n    if ( IsTile( vTexCoord - 1. ) > 0.0 )\n    {\n        col += 0.1;\n    }\n    else\n    if ( IsTile( vTexCoord + 1. ) > 0.0 )\n    {\n        col -= 0.1;\n    }\n    \n    if ( vTexCoord.x == 0.0 ) col += 0.1;\n    if ( vTexCoord.x == 127.0 ) col -= 0.1;\n    if ( vTexCoord.y == 0.0 ) col += 0.1;\n    if ( vTexCoord.y == 127.0 ) col -= 0.1;\n    if ( vTexCoord.y == 64.0 ) col += 0.1;\n    if ( vTexCoord.y == 63.0 ) col -= 0.1;\n    \n    \n    return col;\n}\n\nvec3 TexTekWall1( vec2 vTexCoord, float fRandom )\n{\n\tvec3 col = mix( vec3(39.0, 39.0, 39.0), vec3(51.0, 51.0, 51.0), fRandom * fRandom) \/ 255.0;\n\t\n\treturn col;\n}\n\nvoid TexAddSwitch( inout vec3 col, vec2 vTexCoord, float fRandom )\n{    \n    vec2 vMin = vec2(16., 72.);\n    vec2 vMax = vec2(47., 103.);\n\n    if ( all( greaterThanEqual( vTexCoord, vMin ) ) && \n        all( lessThanEqual( vTexCoord, vMax ) ))\n    {\n        col = vec3( 0.5 );\n        \n        col *= Indent(vTexCoord, vMax, vMin, 0.5, 1.5);\n        \n        DrawScreen( col, vTexCoord, vec2(22,91), vec2(9,8), vec3(1,0,0));\n        DrawScreen( col, vTexCoord, vec2(22,77), vec2(9,8), vec3(0,.3,0));\n        \n        col *= Indent(vTexCoord, vec2(38,79), vec2(39,96), 0.5, 1.1);\n\n        vec2 vSwMin = vec2(37,81);\n        vec2 vSwMax = vSwMin + vec2(3,2);\n        if ( all( greaterThanEqual( vTexCoord, vSwMin ) ) && \n        \tall( lessThanEqual( vTexCoord, vSwMax ) ))\n        {\n            col = vec3(0.5, 0.4, 0.3);\n            col *= Indent(vTexCoord, vSwMax, vSwMin, 0.5, 1.5);\n        }\n        \n        col *= fRandom * 0.5 + 0.5;\n    }    \n}\n\nvec3 SampleTexture( float fTexture, const in vec2 _vUV )\n{\n    vec3 vCol0 = vec3(0.6);\n    vec3 vCol1 = vec3(119.0, 79.0, 43.0) \/ 255.0;\n    vec3 vCol2 = vec3(0);\n    \n    float fOrigTexture = fTexture;\n    \n        \n    vec3 col = vec3(1.0, 1.0, 1.0);\n#ifdef DEBUG_IDENTIFY_UNDEFINED_TEXTURES    \n    col = vec3(1.0, 0.0, 1.0);\n#endif  \n    \n#ifdef DEBUG_IDENTIFY_TEXTURE\n    if ( fTexture == DEBUG_IDENTIFY_TEXTURE && (fract(iGlobalTime) < 0.5))\n    {\n        return vec3(1.0, 0.0, 1.0);\n    }\n#endif     \n    \n    vec2 vUV = _vUV;\n    \n    vec2 vSize = vec2(64.0);\n    float fPersistence = 0.8;\n\tfloat fNoise2Freq = 0.5;\n    vec2 vRandomStreak = vec2(0.0);\n    \n    \/\/ Direct Substitutes\n    if ( fTexture == TEX_FLOOR1_1 )\n    {\n        fTexture = TEX_FLAT14;\n    }\n    else \n    if ( fTexture == TEX_BROWN96 )\n    {\n        fTexture = TEX_BROWN1;\n    }\n    else\n    if ( fTexture == TEX_COMPTALL)\n    {\n        fTexture = TEX_STARGR1;\n    }\n    else\n    if ( fTexture == TEX_DOORSTOP )\n    {\n        fTexture == TEX_DOORTRAK;\n    }\n    else\n    if ( fTexture == TEX_FLAT20 )\n    {\n        fTexture = TEX_DOORSTOP;\n    }\n\telse\n    if (fTexture == TEX_TEKWALL4\n       || fTexture == TEX_STEP2)\n    {\n        \/\/ start area pillars\n        fTexture = TEX_TEKWALL1;\n    }\n    else\n    if (fTexture == TEX_STEP1)\n    {\n        \/\/ Comp room steps (lights added later)\n        fTexture = TEX_STEP6;\n    }\n    else\n    if ( fTexture == TEX_SLADWALL)\n    {\n        fTexture = TEX_BROWNGRN;\n    }\n    else\n    if ( fTexture == TEX_EXITDOOR )\n    {\n        fTexture = TEX_DOOR3;\n    }\n    else\n\tif ( fTexture == TEX_FLAT23 )\n    {\n        fTexture = TEX_FLAT18;\n    }         \n        \n        \n    \n    if ( fTexture == TEX_FLOOR4_8)\n    {\n        \/\/ start area\n\t    vCol0 = vec3(30.0, 30.0, 30.0);\n        vCol1 = vec3(150.0, 150.0, 150.0);\n    }\n\telse        \n    if ( fTexture == TEX_FLOOR5_1)\n    {\n        \/\/ Corridor to outside\n        fTexture = TEX_FLOOR4_8;\n        vCol0 = vec3(51.0, 43.0, 19.0);\n        vCol1 = vec3(150.0, 150.0, 150.0);\n    }\n\telse        \n    if ( fTexture == TEX_FLOOR5_2 )\n    {\n        \/\/ imp\/nukage room\n        fTexture = TEX_FLOOR4_8;\n        vCol0 = vec3(51.0, 43.0, 19.0);\n\t\tvCol1 = vec3(79.0, 59, 35.0);\n    }\n    \n    if ( fTexture == TEX_TLITE6_5)\n    {\n\t\tvCol0 = vec3(.2);        \n\t\tvCol1 = vec3(1,0,0);\n    }\n    if ( fTexture == TEX_TLITE6_6 )\n    {\n        fTexture = TEX_TLITE6_5;\n        vCol0 = vec3(.25, .2, .1);\n        vCol1 = vec3(.8,.6,.4);\n    }\n\n    if ( fTexture == TEX_TLITE6_4 )\n    {\n        vCol0 = vec3(.25, .2, .1);\n        vCol1 = vec3(.8,.6,.4);\n    }\n    else\n    if ( fTexture == TEX_TLITE6_1 )\n    {\n        fTexture = TEX_TLITE6_4;\n\t\tvCol0 = vec3(.2);        \n\t\tvCol1 = vec3(1);\n    }\n\n    if ( fTexture == TEX_BIGDOOR2 )\n    {\n    \tvCol0 = vec3(119) \/255.;\n    }\n    else\n    if ( fTexture == TEX_BIGDOOR4 )\n    {\n        fTexture = TEX_BIGDOOR2;\n    \tvCol0 = vec3(103,83,63) \/255.;\n    }\n    \n    if ( fTexture == TEX_FLOOR7_1 )\n    {\n\t    vCol0 = vec3(51.0, 43.0, 19.0);\n        vCol1 = vec3(79.0, 59, 35.0);\n\t}\n    \n    if ( fTexture == TEX_CEIL5_2 )\n    {\n        fTexture = TEX_FLOOR7_1;\n\t    vCol0 = vec3(51.0, 43.0, 19.0) * .75;\n        vCol1 = vec3(79.0, 59, 35.0) * .75;\n\t}\n    \n    if ( fTexture == TEX_BROWN1 )\n    {\n        vCol0 = vec3(119.0, 95.0, 63.0);\n        vCol1 = vec3(147.0, 123.0, 99.0);\n        vCol2 = vec3(0.3, 0.2, 0.1);\n    }\n    else\n    if ( fTexture == TEX_BROWNGRN )\n    {\n        fTexture = TEX_BROWN1;\n        vCol1 = vec3(43,35,15);\n        vCol0 = vec3(47.0, 47.0, 47.0);\n        \/\/vCol1 = vec3(147.0, 123.0, 99.0);\n        \/\/vCol1 = vec3(123.0, 127.0, 99.0);\n        vCol2 = vec3(19,35,11) \/ 255.;\n    }\n    \n    if ( fTexture == TEX_FLAT14 )\n    {\n        \/\/ Blue noise\n \t\tvCol0 = vec3(0.0, 0.0, 35.0 \/ 255.0);\n        vCol1 = vec3(0.0, 0.0, 200.0 \/ 255.0);\n\t\tfPersistence = 2.0;\n    }\n    else\n    if ( fTexture == TEX_CEIL5_1 )\n    {\n        \/\/ Comp room side ceil\n        fTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(30.0 \/ 255.0);\n        vCol1 = vec3(15.0 \/ 255.0);\n\t\tfPersistence = 2.0;\n    }\n    else\n    if ( fTexture == TEX_FLAT18 )\n    {\n        \/\/ Comp room side floor\n        fTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(70.0 \/ 255.0);\n        vCol1 = vec3(40.0 \/ 255.0);\n\t\tfPersistence = 2.0;\n    }   \n    else\n    if ( fTexture == TEX_COMPSPAN )\n    {\n        \/\/ Comp room wall lower\n        fTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(70.0 \/ 255.0);\n        vCol1 = vec3(30.0 \/ 255.0);\n\t\tfPersistence = 1.0;\n    }\n    else\n    if ( fTexture == TEX_FLOOR6_2 )\n    {\n        \/\/ secret shotgun area ceil\n        fTexture = TEX_FLAT14;        \n \t\tvCol0 = vec3(120.0 \/ 255.0);\n        vCol1 = vec3(0.0 \/ 255.0);\n\t\tfPersistence = 1.25;\n    }\n\n    if ( fTexture == TEX_FLOOR7_2 )\n    {\n        \/\/ Green armor ceil\n        fTexture = TEX_FLAT14;\n \t\tvCol0 = vec3(85,89,60)\/255.;\n        vCol1 = vec3(0.0, 0.0, 0);\n\t\tfPersistence = 0.5;\n    }\n    \n    if ( fTexture == TEX_COMPUTE3 )\n    {\n        fTexture = TEX_COMPUTE2;\n    }       \n\n\tif(fTexture == TEX_NUKAGE3)\n\t{\n        float fTest = fract(floor(iGlobalTime * 6.0) * (1.0 \/ 3.0));\n        if( fTest < 0.3 )\n        {\n\t        vUV += 0.3 * vSize;\n        }\n        else if(fTest < 0.6)\n        {\n            vUV = vUV.yx - 0.3; \n        }\n        else\n        {\n            vUV = vUV + 0.45;\n        }\n\t}\n    \n    if ( fTexture == TEX_STARTAN1 )\n    {\n        fTexture = TEX_STARTAN3;\n        vCol0 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n        vCol1 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n    }\n    else\n    if ( fTexture == TEX_STARG3 )\n    {\n        fTexture = TEX_STARTAN3;\n\t\tvCol0 = vec3(0.6);\n\t\tvCol1 = vec3(123,127,99) \/ 255.0;\n    }\n    else\n    if ( fTexture == TEX_STARGR1 )\n    {\n        fTexture = TEX_STARTAN3;\n\t\tvCol0 = vec3(0.6);\n\t\tvCol1 = vec3(0.6);  \n    }\n    else\n    if ( fTexture == TEX_SW1STRTN )\n    {\n        fTexture = TEX_STARTAN3;\n        vCol0 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n        vCol1 = vec3(131.0, 101.0, 75.0) \/ 255.0;\n    }   \n    \n    \/\/ Should be a sidedef flag\n    if ( fOrigTexture == TEX_TEKWALL1 )\n    {\n        vUV.x = mod(vUV.x + floor(iGlobalTime * 50.0), 64.);\n    }\n    \n\t\n\tif(fTexture == TEX_NUKAGE3) { fPersistence = 1.0; }\n\tif(fTexture == TEX_F_SKY1) { vSize = vec2(256.0, 128.0); fNoise2Freq = 0.3; }\n    if(fTexture == TEX_FLOOR7_1 ||\n      fTexture == TEX_CEIL5_2 ) { vSize = vec2(64.0, 32.0); fPersistence = 1.0; }\t\n    if(fTexture == TEX_FLAT5_5) { fPersistence = 3.0; }\n    if(fTexture == TEX_FLOOR4_8) { fPersistence = 0.3; }\n    if(fTexture == TEX_CEIL3_5) { fPersistence = 0.9; }\t\n    if(fTexture == TEX_DOOR3) { vSize = vec2(64.0, 72.0); }\t\n    if(fTexture == TEX_LITE3) { vSize = vec2(32.0, 128.0); }\t\n    if(fTexture == TEX_STARTAN3) { vSize = vec2(128.0); fPersistence = 1.0; }\t\n    if(fTexture == TEX_STARGR1) { vSize = vec2(128.0); fPersistence = 1.0; }\t    \n    if(fTexture == TEX_BIGDOOR2) { vSize = vec2(128.0, 128.0); fPersistence = 0.5; vRandomStreak = vec2(0,128.); }\t    \n\tif(fTexture == TEX_BROWN1) { vSize = vec2(128.0); fPersistence = 0.7; }\t\n\tif(fTexture == TEX_BROWNGRN) { vSize = vec2(128.0); fPersistence = 0.7; }\t    \n    if(fTexture == TEX_DOORSTOP) { vSize = vec2(8.0, 128.0); fPersistence = 0.7; }\n    if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 56.0); fPersistence = 1.5; }\n    if(fTexture == TEX_STEP6) { vSize = vec2(32.0, 16.0); fPersistence = 0.9; }\n    if(fTexture == TEX_SUPPORT2) { vSize = vec2(64.0, 128.0); }\n    if(fTexture == TEX_DOORTRAK) { vSize = vec2(8.0, 128.0); }\n    if(fTexture == TEX_TEKWALL1) {  fPersistence = 1.0;vSize = vec2(64.0, 64.0); }\n    if(fTexture == TEX_TLITE6_5) { fPersistence = 1.0; vSize = vec2(64.0, 64.0); }\n    if(fTexture == TEX_TLITE6_4) { fPersistence = 1.0; vSize = vec2(64.0, 64.0); }\n    if(fTexture == TEX_NUKE24) { vSize = vec2(64.0,24.0); }\n    if(fTexture == TEX_COMPTILE) { vSize = vec2(128.); vRandomStreak = vec2(16.0, 0); }\n    if(fTexture == TEX_PLANET1) { vSize = vec2(256.0, 128.0); vRandomStreak = vec2(0.0, 255.); }\n    if(fTexture == TEX_EXITSIGN) { vSize = vec2(64,16); }\n\t\n#ifdef PREVIEW\n\t     if(fTexture == TEX_DOOR3) {\tvSize = vec2(128.0, 128.0); }\t\n\telse if(fTexture == TEX_COMPUTE2) { vSize = vec2(256.0, 64.0); }\n#endif\n\t\n\t\n#ifdef PREVIEW\n    vec2 vTexCoord = floor(fract(vUV) * vSize);\n#else\n    vec2 vTexCoord = fract(vUV \/ vSize) * vSize;\n    #ifdef PIXELATE_TEXTURES\n    vTexCoord = floor(vTexCoord);\n    #endif\n    vTexCoord.y = vSize.y - vTexCoord.y - 1.0;\n#endif\n    \n\tfloat fHRandom = noise1D(vTexCoord.x * fNoise2Freq);\n    float fHOffset =  - ((vTexCoord.y) \/ vSize.y);\n\n    vec2 vRandomCoord = vTexCoord + fTexture;\n    vRandomCoord += fHRandom * vRandomStreak;\n\tfloat fRandom = fbm( vRandomCoord, fPersistence );\n\n\tif(fTexture == TEX_NUKAGE3) \tcol = TexNukage3( vTexCoord, fRandom );\n\tif(fTexture == TEX_F_SKY1) \tcol = TexFSky1( vTexCoord, fRandom, fHRandom );\n    if(fTexture == TEX_FLOOR7_1) \tcol = TexFloor7_1( vTexCoord, fRandom, vCol0, vCol1 );\n    if(fTexture == TEX_FLAT5_5) \tcol = TexFlat5_5( vTexCoord, fRandom );\n    if(fTexture == TEX_FLOOR4_8) \tcol = TexFloor4_8( vTexCoord, fRandom, vCol0, vCol1 );\n    if(fTexture == TEX_CEIL3_5) \tcol = TexCeil3_5( vTexCoord, fRandom );\n\tif(fTexture == TEX_FLAT14) \tcol = TexRandom( vTexCoord, fRandom, vCol0, vCol1 );\n\tif(fTexture == TEX_DOOR3) \t\tcol = TexDoor3( vTexCoord, fRandom, fHRandom + fHOffset);\n\tif(fTexture == TEX_LITE3) \t\tcol = TexLite3( vTexCoord );\n    if(fTexture == TEX_STARTAN3) \tcol = TexStartan3( vTexCoord, fRandom, vCol0, vCol1 );\n\tif(fTexture == TEX_BIGDOOR2) \tcol = TexBigDoor2( vTexCoord, fRandom, fHRandom, vCol0 );\n    if(fTexture == TEX_BROWN1) \tcol = TexBrown1( vTexCoord, fRandom, fHRandom + fHOffset, vCol0, vCol1, vCol2 );\n    if(fTexture == TEX_DOORSTOP) \tcol = TexDoorstop( vTexCoord, fRandom );\n    if(fTexture == TEX_COMPUTE2) \tcol = TexCompute2( vTexCoord, fRandom );\n    if(fTexture == TEX_STEP6) \t\tcol = TexStep6( vTexCoord, fRandom, fHRandom + fHOffset );\n    if(fTexture == TEX_SUPPORT2) \tcol = TexSupport2( vTexCoord, fRandom );\n\tif(fTexture == TEX_DOORTRAK) \tcol = TexDoorTrak( vTexCoord, fRandom );\n\tif(fTexture == TEX_BROWN144) \tcol = TexBrown144( vTexCoord, fRandom, fHRandom  + fHOffset );\n    if(fTexture == TEX_TEKWALL1)\tcol = TexTekWall1( vTexCoord, fRandom );\n    if(fTexture == TEX_TLITE6_5)\tcol = TexTLite6_5( vTexCoord, fRandom, vCol0, vCol1 );\n    if(fTexture == TEX_TLITE6_4)\tcol = TexTLite6_4( vTexCoord, fRandom, vCol0, vCol1 );\n    if(fTexture == TEX_NUKE24) \tcol = TexNuke24( vTexCoord, fRandom, fHRandom );\n\tif(fTexture == TEX_PLANET1)\tcol = TexPlanet1( vTexCoord, fRandom, fHRandom );\n\tif(fTexture == TEX_EXITSIGN)\tcol = TexExitSign( vTexCoord, fRandom, fHRandom );\n\t\n    if (fTexture == TEX_COMPTILE)\tcol = TexCompTile( vTexCoord, fRandom );\n        \n    if ( fOrigTexture == TEX_SW1STRTN )\n    {\n        TexAddSwitch( col, vTexCoord, fRandom );\n    }\n    else\n    if (fOrigTexture == TEX_STEP1)\n    {\n        \/\/\/ Add lights\n        vec2 d = vTexCoord - vec2(16,8);\n        col *= max(0.3, 1.0 - 0.005 * dot(d,d) );\n    }    \n        \n    #ifdef QUANTIZE_TEXTURES\n    col = Quantize(col, 32.0);\n    #endif\n   \n#ifdef DEBUG_IDENTIFY_TEXTURES\n    vec2 vFontUV = fract(_vUV * vec2(.08) * vec2(1., 2.) ) * 3.0 \/ vec2(1., 2.);\n    if ( PrintValue(vFontUV, fOrigTexture, 2., 0.) > 0.0 )\n    {\n        col = vec3(1.,0,0);\n    }\n#endif    \n\n    return col;\n}\n\n","name":"Buf D","description":"","type":"buffer"}]}}