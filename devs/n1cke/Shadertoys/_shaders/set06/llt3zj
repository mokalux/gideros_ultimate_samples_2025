{"Shader":{"ver":"0.1","info":{"id":"llt3zj","date":"1470376736","viewed":199,"name":"Dot Line","username":"EanJee","description":"2D composition practice","likes":4,"published":3,"flags":0,"tags":["2d","minimal","dot","point","composition"],"hasliked":0},"renderpass":[{"inputs":[],"outputs":[{"id":37,"channel":0}],"code":"#define PI 3.14159\n\nvec3 drawCircleFill(vec2 st, vec2 resolution, float radius, float fade) {\n    vec2 mappedSt = st * resolution;\n    float maxRadius = min(resolution.x, resolution.y);\n    float pct = smoothstep(radius * maxRadius, (radius + fade) * maxRadius, \n                           length(mappedSt - resolution * 0.5));\n    return vec3(pct);\n}\n\nvoid mainImage( out vec4 fragColor, in vec2 fragCoord ) {\n    vec2 st = fragCoord.xy \/ iResolution.xy;\n\n    \/\/ find orientation\n    float xCoef = iResolution.x > iResolution.y ? 1.0 : 0.0;\n    vec2 coef = vec2(xCoef, 1.0 - xCoef);\n    vec2 coefReversed = 1.0 - coef;\n    \n    \/\/ tile on longer one\n    float repeatTime = 32.0;\n    vec2 repeat = vec2(1.0) + coef * (repeatTime - 1.0);\n    vec2 stTiled = fract(st * repeat);\n    \n    \/\/ get right resolution for each slice\n    vec2 repeatReversed = vec2(1.0) + coefReversed * (repeatTime - 1.0);\n    vec2 resolution = vec2(iResolution.x \/ iResolution.y, 1.0) * repeatReversed;\n    \n    \/\/ transform\n    vec2 sliceIndex = floor(st * repeat);\n    float phase = max(sliceIndex.x, sliceIndex.y) * PI \/ repeatTime * 2.0;\n    float offsetValue = sin(iGlobalTime * 2.5 + phase);\n    vec2 offset = offsetValue * coefReversed * 0.08;\n    stTiled += offset;\n  \n    \/\/ draw circle\n    vec3 color = drawCircleFill(stTiled, resolution, 0.4 * abs(offsetValue), 0.1);\n    fragColor = vec4(color, 1.0);\n}","name":"Image","description":"","type":"image"}]}}